{ ****************************************************************************** }
{ Fast KDTree Currency Type support                                              }
{ ****************************************************************************** }
{ * https://zpascal.net                                                        * }
{ * https://github.com/PassByYou888/zAI                                        * }
{ * https://github.com/PassByYou888/ZServer4D                                  * }
{ * https://github.com/PassByYou888/PascalString                               * }
{ * https://github.com/PassByYou888/zRasterization                             * }
{ * https://github.com/PassByYou888/CoreCipher                                 * }
{ * https://github.com/PassByYou888/zSound                                     * }
{ * https://github.com/PassByYou888/zChinese                                   * }
{ * https://github.com/PassByYou888/zExpression                                * }
{ * https://github.com/PassByYou888/zGameWare                                  * }
{ * https://github.com/PassByYou888/zAnalysis                                  * }
{ * https://github.com/PassByYou888/FFMPEG-Header                              * }
{ * https://github.com/PassByYou888/zTranslate                                 * }
{ * https://github.com/PassByYou888/InfiniteIoT                                * }
{ * https://github.com/PassByYou888/FastMD5                                    * }
{ ****************************************************************************** }

unit FastKDTreeC;

{$INCLUDE zDefine.inc}

interface

uses CoreClasses, PascalStrings, UnicodeMixedLib, KM;

const

  // Currency float: KDTree
  KDT1DC_Axis = 1;
  KDT2DC_Axis = 2;
  KDT3DC_Axis = 3;
  KDT4DC_Axis = 4;
  KDT5DC_Axis = 5;
  KDT6DC_Axis = 6;
  KDT7DC_Axis = 7;
  KDT8DC_Axis = 8;
  KDT9DC_Axis = 9;
  KDT10DC_Axis = 10;
  KDT11DC_Axis = 11;
  KDT12DC_Axis = 12;
  KDT13DC_Axis = 13;
  KDT14DC_Axis = 14;
  KDT15DC_Axis = 15;
  KDT16DC_Axis = 16;
  KDT17DC_Axis = 17;
  KDT18DC_Axis = 18;
  KDT19DC_Axis = 19;
  KDT20DC_Axis = 20;
  KDT21DC_Axis = 21;
  KDT22DC_Axis = 22;
  KDT23DC_Axis = 23;
  KDT24DC_Axis = 24;
  KDT48DC_Axis = 48;
  KDT52DC_Axis = 52;
  KDT64DC_Axis = 64;
  KDT96DC_Axis = 96;
  KDT128DC_Axis = 128;
  KDT156DC_Axis = 156;
  KDT192DC_Axis = 192;
  KDT256DC_Axis = 256;
  KDT384DC_Axis = 384;
  KDT512DC_Axis = 512;
  KDT800DC_Axis = 800;
  KDT1024DC_Axis = 1024;

type

  // Currency float: KDTree
  TKDT1DC = class;  TKDT1DC_VecType = KM.TKMFloat; // 1D
  TKDT2DC = class;  TKDT2DC_VecType = KM.TKMFloat; // 2D
  TKDT3DC = class;  TKDT3DC_VecType = KM.TKMFloat; // 3D
  TKDT4DC = class;  TKDT4DC_VecType = KM.TKMFloat; // 4D
  TKDT5DC = class;  TKDT5DC_VecType = KM.TKMFloat; // 5D
  TKDT6DC = class;  TKDT6DC_VecType = KM.TKMFloat; // 6D
  TKDT7DC = class;  TKDT7DC_VecType = KM.TKMFloat; // 7D
  TKDT8DC = class;  TKDT8DC_VecType = KM.TKMFloat; // 8D
  TKDT9DC = class;  TKDT9DC_VecType = KM.TKMFloat; // 9D
  TKDT10DC = class;  TKDT10DC_VecType = KM.TKMFloat; // 10D
  TKDT11DC = class;  TKDT11DC_VecType = KM.TKMFloat; // 11D
  TKDT12DC = class;  TKDT12DC_VecType = KM.TKMFloat; // 12D
  TKDT13DC = class;  TKDT13DC_VecType = KM.TKMFloat; // 13D
  TKDT14DC = class;  TKDT14DC_VecType = KM.TKMFloat; // 14D
  TKDT15DC = class;  TKDT15DC_VecType = KM.TKMFloat; // 15D
  TKDT16DC = class;  TKDT16DC_VecType = KM.TKMFloat; // 16D
  TKDT17DC = class;  TKDT17DC_VecType = KM.TKMFloat; // 17D
  TKDT18DC = class;  TKDT18DC_VecType = KM.TKMFloat; // 18D
  TKDT19DC = class;  TKDT19DC_VecType = KM.TKMFloat; // 19D
  TKDT20DC = class;  TKDT20DC_VecType = KM.TKMFloat; // 20D
  TKDT21DC = class;  TKDT21DC_VecType = KM.TKMFloat; // 21D
  TKDT22DC = class;  TKDT22DC_VecType = KM.TKMFloat; // 22D
  TKDT23DC = class;  TKDT23DC_VecType = KM.TKMFloat; // 23D
  TKDT24DC = class;  TKDT24DC_VecType = KM.TKMFloat; // 24D
  TKDT48DC = class;  TKDT48DC_VecType = KM.TKMFloat; // 48D
  TKDT52DC = class;  TKDT52DC_VecType = KM.TKMFloat; // 52D
  TKDT64DC = class;  TKDT64DC_VecType = KM.TKMFloat; // 64D
  TKDT96DC = class;  TKDT96DC_VecType = KM.TKMFloat; // 96D
  TKDT128DC = class;  TKDT128DC_VecType = KM.TKMFloat; // 128D
  TKDT156DC = class;  TKDT156DC_VecType = KM.TKMFloat; // 156D
  TKDT192DC = class;  TKDT192DC_VecType = KM.TKMFloat; // 192D
  TKDT256DC = class;  TKDT256DC_VecType = KM.TKMFloat; // 256D
  TKDT384DC = class;  TKDT384DC_VecType = KM.TKMFloat; // 384D
  TKDT512DC = class;  TKDT512DC_VecType = KM.TKMFloat; // 512D
  TKDT800DC = class;  TKDT800DC_VecType = KM.TKMFloat; // 800D
  TKDT1024DC = class;  TKDT1024DC_VecType = KM.TKMFloat; // 1024D










  // Currency float: KDTree


  TKDT1DC = class(TCoreClassObject)
  public type
    // code split
    TKDT1DC_Vec = array [0 .. KDT1DC_Axis - 1] of TKDT1DC_VecType;
    PKDT1DC_Vec = ^TKDT1DC_Vec;

    TKDT1DC_DynamicVecBuffer = array of TKDT1DC_Vec;
    PKDT1DC_DynamicVecBuffer = ^TKDT1DC_DynamicVecBuffer;

    TKDT1DC_Source = record
      buff: TKDT1DC_Vec;
      Index: Int64;
      Token: TPascalString;
    end;

    PKDT1DC_Source = ^TKDT1DC_Source;
    TKDT1DC_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT1DC_Source) - 1] of PKDT1DC_Source;
    PKDT1DC_SourceBuffer = ^TKDT1DC_SourceBuffer;

    TKDT1DC_DyanmicSourceBuffer = array of PKDT1DC_Source;
    PKDT1DC_DyanmicSourceBuffer = ^TKDT1DC_DyanmicSourceBuffer;

    TKDT1DC_DyanmicStoreBuffer = array of TKDT1DC_Source;
    PKDT1DC_DyanmicStoreBuffer = ^TKDT1DC_DyanmicStoreBuffer;

    PKDT1DC_Node = ^TKDT1DC_Node;

    TKDT1DC_Node = record
      Parent, Right, Left: PKDT1DC_Node;
      Vec: PKDT1DC_Source;
    end;

    TKDT1DC_BuildCall = procedure(const IndexFor: NativeInt; var Source: TKDT1DC_Source; const Data: Pointer);
    TKDT1DC_BuildMethod = procedure(const IndexFor: NativeInt; var Source: TKDT1DC_Source; const Data: Pointer) of object;
{$IFDEF FPC}
    TKDT1DC_BuildProc = procedure(const IndexFor: NativeInt; var Source: TKDT1DC_Source; const Data: Pointer) is nested;
{$ELSE FPC}
    TKDT1DC_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT1DC_Source; const Data: Pointer);
{$ENDIF FPC}
  private
    KDStoreBuff: TKDT1DC_DyanmicStoreBuffer;
    KDBuff: TKDT1DC_DyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes: array of PKDT1DC_Node;
    TestBuff: TKDT1DC_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT1DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1DC_Node;
    function GetData(const Index: NativeInt): PKDT1DC_Source;
  public
    RootNode: PKDT1DC_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT1DC_DyanmicStoreBuffer;
    property SourceP[const Index: NativeInt]: PKDT1DC_Source read GetData; default;

    { bakcall build }
    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1DC_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1DC_BuildMethod);
    procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1DC_BuildProc);
    { fill k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1DC_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT1DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT1DC_BuildMethod); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT1DC_BuildProc); overload;
    { search }
    function Search(const buff: TKDT1DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1DC_Node; overload;
    function Search(const buff: TKDT1DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1DC_Node; overload;
    function Search(const buff: TKDT1DC_Vec; var SearchedDistanceMin: Double): PKDT1DC_Node; overload;
    function Search(const buff: TKDT1DC_Vec): PKDT1DC_Node; overload;
    function SearchToken(const buff: TKDT1DC_Vec): TPascalString;
    { parallel search }
    procedure Search(const inBuff: TKDT1DC_DynamicVecBuffer; var OutBuff: TKDT1DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;
    procedure Search(const inBuff: TKDT1DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);
    procedure SaveToFile(FileName: SystemString);
    procedure LoadFromFile(FileName: SystemString);
    procedure PrintNodeTree(const NodePtr: PKDT1DC_Node);
    procedure PrintBuffer;
    class function Vec(const s: SystemString): TKDT1DC_Vec; overload;
    class function Vec(const v: TKDT1DC_Vec): SystemString; overload;
    class function Distance(const v1, v2: TKDT1DC_Vec): Double;
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT1DC_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT2DC = class(TCoreClassObject)
  public type
    // code split
    TKDT2DC_Vec = array [0 .. KDT2DC_Axis - 1] of TKDT2DC_VecType;
    PKDT2DC_Vec = ^TKDT2DC_Vec;

    TKDT2DC_DynamicVecBuffer = array of TKDT2DC_Vec;
    PKDT2DC_DynamicVecBuffer = ^TKDT2DC_DynamicVecBuffer;

    TKDT2DC_Source = record
      buff: TKDT2DC_Vec;
      Index: Int64;
      Token: TPascalString;
    end;

    PKDT2DC_Source = ^TKDT2DC_Source;
    TKDT2DC_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT2DC_Source) - 1] of PKDT2DC_Source;
    PKDT2DC_SourceBuffer = ^TKDT2DC_SourceBuffer;

    TKDT2DC_DyanmicSourceBuffer = array of PKDT2DC_Source;
    PKDT2DC_DyanmicSourceBuffer = ^TKDT2DC_DyanmicSourceBuffer;

    TKDT2DC_DyanmicStoreBuffer = array of TKDT2DC_Source;
    PKDT2DC_DyanmicStoreBuffer = ^TKDT2DC_DyanmicStoreBuffer;

    PKDT2DC_Node = ^TKDT2DC_Node;

    TKDT2DC_Node = record
      Parent, Right, Left: PKDT2DC_Node;
      Vec: PKDT2DC_Source;
    end;

    TKDT2DC_BuildCall = procedure(const IndexFor: NativeInt; var Source: TKDT2DC_Source; const Data: Pointer);
    TKDT2DC_BuildMethod = procedure(const IndexFor: NativeInt; var Source: TKDT2DC_Source; const Data: Pointer) of object;
{$IFDEF FPC}
    TKDT2DC_BuildProc = procedure(const IndexFor: NativeInt; var Source: TKDT2DC_Source; const Data: Pointer) is nested;
{$ELSE FPC}
    TKDT2DC_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT2DC_Source; const Data: Pointer);
{$ENDIF FPC}
  private
    KDStoreBuff: TKDT2DC_DyanmicStoreBuffer;
    KDBuff: TKDT2DC_DyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes: array of PKDT2DC_Node;
    TestBuff: TKDT2DC_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT2DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT2DC_Node;
    function GetData(const Index: NativeInt): PKDT2DC_Source;
  public
    RootNode: PKDT2DC_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT2DC_DyanmicStoreBuffer;
    property SourceP[const Index: NativeInt]: PKDT2DC_Source read GetData; default;

    { bakcall build }
    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT2DC_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT2DC_BuildMethod);
    procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT2DC_BuildProc);
    { fill k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT2DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT2DC_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT2DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT2DC_BuildMethod); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT2DC_BuildProc); overload;
    { search }
    function Search(const buff: TKDT2DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT2DC_Node; overload;
    function Search(const buff: TKDT2DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT2DC_Node; overload;
    function Search(const buff: TKDT2DC_Vec; var SearchedDistanceMin: Double): PKDT2DC_Node; overload;
    function Search(const buff: TKDT2DC_Vec): PKDT2DC_Node; overload;
    function SearchToken(const buff: TKDT2DC_Vec): TPascalString;
    { parallel search }
    procedure Search(const inBuff: TKDT2DC_DynamicVecBuffer; var OutBuff: TKDT2DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;
    procedure Search(const inBuff: TKDT2DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);
    procedure SaveToFile(FileName: SystemString);
    procedure LoadFromFile(FileName: SystemString);
    procedure PrintNodeTree(const NodePtr: PKDT2DC_Node);
    procedure PrintBuffer;
    class function Vec(const s: SystemString): TKDT2DC_Vec; overload;
    class function Vec(const v: TKDT2DC_Vec): SystemString; overload;
    class function Distance(const v1, v2: TKDT2DC_Vec): Double;
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT2DC_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT3DC = class(TCoreClassObject)
  public type
    // code split
    TKDT3DC_Vec = array [0 .. KDT3DC_Axis - 1] of TKDT3DC_VecType;
    PKDT3DC_Vec = ^TKDT3DC_Vec;

    TKDT3DC_DynamicVecBuffer = array of TKDT3DC_Vec;
    PKDT3DC_DynamicVecBuffer = ^TKDT3DC_DynamicVecBuffer;

    TKDT3DC_Source = record
      buff: TKDT3DC_Vec;
      Index: Int64;
      Token: TPascalString;
    end;

    PKDT3DC_Source = ^TKDT3DC_Source;
    TKDT3DC_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT3DC_Source) - 1] of PKDT3DC_Source;
    PKDT3DC_SourceBuffer = ^TKDT3DC_SourceBuffer;

    TKDT3DC_DyanmicSourceBuffer = array of PKDT3DC_Source;
    PKDT3DC_DyanmicSourceBuffer = ^TKDT3DC_DyanmicSourceBuffer;

    TKDT3DC_DyanmicStoreBuffer = array of TKDT3DC_Source;
    PKDT3DC_DyanmicStoreBuffer = ^TKDT3DC_DyanmicStoreBuffer;

    PKDT3DC_Node = ^TKDT3DC_Node;

    TKDT3DC_Node = record
      Parent, Right, Left: PKDT3DC_Node;
      Vec: PKDT3DC_Source;
    end;

    TKDT3DC_BuildCall = procedure(const IndexFor: NativeInt; var Source: TKDT3DC_Source; const Data: Pointer);
    TKDT3DC_BuildMethod = procedure(const IndexFor: NativeInt; var Source: TKDT3DC_Source; const Data: Pointer) of object;
{$IFDEF FPC}
    TKDT3DC_BuildProc = procedure(const IndexFor: NativeInt; var Source: TKDT3DC_Source; const Data: Pointer) is nested;
{$ELSE FPC}
    TKDT3DC_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT3DC_Source; const Data: Pointer);
{$ENDIF FPC}
  private
    KDStoreBuff: TKDT3DC_DyanmicStoreBuffer;
    KDBuff: TKDT3DC_DyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes: array of PKDT3DC_Node;
    TestBuff: TKDT3DC_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT3DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT3DC_Node;
    function GetData(const Index: NativeInt): PKDT3DC_Source;
  public
    RootNode: PKDT3DC_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT3DC_DyanmicStoreBuffer;
    property SourceP[const Index: NativeInt]: PKDT3DC_Source read GetData; default;

    { bakcall build }
    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3DC_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3DC_BuildMethod);
    procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3DC_BuildProc);
    { fill k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT3DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT3DC_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT3DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT3DC_BuildMethod); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT3DC_BuildProc); overload;
    { search }
    function Search(const buff: TKDT3DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT3DC_Node; overload;
    function Search(const buff: TKDT3DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT3DC_Node; overload;
    function Search(const buff: TKDT3DC_Vec; var SearchedDistanceMin: Double): PKDT3DC_Node; overload;
    function Search(const buff: TKDT3DC_Vec): PKDT3DC_Node; overload;
    function SearchToken(const buff: TKDT3DC_Vec): TPascalString;
    { parallel search }
    procedure Search(const inBuff: TKDT3DC_DynamicVecBuffer; var OutBuff: TKDT3DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;
    procedure Search(const inBuff: TKDT3DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);
    procedure SaveToFile(FileName: SystemString);
    procedure LoadFromFile(FileName: SystemString);
    procedure PrintNodeTree(const NodePtr: PKDT3DC_Node);
    procedure PrintBuffer;
    class function Vec(const s: SystemString): TKDT3DC_Vec; overload;
    class function Vec(const v: TKDT3DC_Vec): SystemString; overload;
    class function Distance(const v1, v2: TKDT3DC_Vec): Double;
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT3DC_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT4DC = class(TCoreClassObject)
  public type
    // code split
    TKDT4DC_Vec = array [0 .. KDT4DC_Axis - 1] of TKDT4DC_VecType;
    PKDT4DC_Vec = ^TKDT4DC_Vec;

    TKDT4DC_DynamicVecBuffer = array of TKDT4DC_Vec;
    PKDT4DC_DynamicVecBuffer = ^TKDT4DC_DynamicVecBuffer;

    TKDT4DC_Source = record
      buff: TKDT4DC_Vec;
      Index: Int64;
      Token: TPascalString;
    end;

    PKDT4DC_Source = ^TKDT4DC_Source;
    TKDT4DC_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT4DC_Source) - 1] of PKDT4DC_Source;
    PKDT4DC_SourceBuffer = ^TKDT4DC_SourceBuffer;

    TKDT4DC_DyanmicSourceBuffer = array of PKDT4DC_Source;
    PKDT4DC_DyanmicSourceBuffer = ^TKDT4DC_DyanmicSourceBuffer;

    TKDT4DC_DyanmicStoreBuffer = array of TKDT4DC_Source;
    PKDT4DC_DyanmicStoreBuffer = ^TKDT4DC_DyanmicStoreBuffer;

    PKDT4DC_Node = ^TKDT4DC_Node;

    TKDT4DC_Node = record
      Parent, Right, Left: PKDT4DC_Node;
      Vec: PKDT4DC_Source;
    end;

    TKDT4DC_BuildCall = procedure(const IndexFor: NativeInt; var Source: TKDT4DC_Source; const Data: Pointer);
    TKDT4DC_BuildMethod = procedure(const IndexFor: NativeInt; var Source: TKDT4DC_Source; const Data: Pointer) of object;
{$IFDEF FPC}
    TKDT4DC_BuildProc = procedure(const IndexFor: NativeInt; var Source: TKDT4DC_Source; const Data: Pointer) is nested;
{$ELSE FPC}
    TKDT4DC_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT4DC_Source; const Data: Pointer);
{$ENDIF FPC}
  private
    KDStoreBuff: TKDT4DC_DyanmicStoreBuffer;
    KDBuff: TKDT4DC_DyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes: array of PKDT4DC_Node;
    TestBuff: TKDT4DC_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT4DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT4DC_Node;
    function GetData(const Index: NativeInt): PKDT4DC_Source;
  public
    RootNode: PKDT4DC_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT4DC_DyanmicStoreBuffer;
    property SourceP[const Index: NativeInt]: PKDT4DC_Source read GetData; default;

    { bakcall build }
    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT4DC_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT4DC_BuildMethod);
    procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT4DC_BuildProc);
    { fill k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT4DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT4DC_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT4DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT4DC_BuildMethod); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT4DC_BuildProc); overload;
    { search }
    function Search(const buff: TKDT4DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT4DC_Node; overload;
    function Search(const buff: TKDT4DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT4DC_Node; overload;
    function Search(const buff: TKDT4DC_Vec; var SearchedDistanceMin: Double): PKDT4DC_Node; overload;
    function Search(const buff: TKDT4DC_Vec): PKDT4DC_Node; overload;
    function SearchToken(const buff: TKDT4DC_Vec): TPascalString;
    { parallel search }
    procedure Search(const inBuff: TKDT4DC_DynamicVecBuffer; var OutBuff: TKDT4DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;
    procedure Search(const inBuff: TKDT4DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);
    procedure SaveToFile(FileName: SystemString);
    procedure LoadFromFile(FileName: SystemString);
    procedure PrintNodeTree(const NodePtr: PKDT4DC_Node);
    procedure PrintBuffer;
    class function Vec(const s: SystemString): TKDT4DC_Vec; overload;
    class function Vec(const v: TKDT4DC_Vec): SystemString; overload;
    class function Distance(const v1, v2: TKDT4DC_Vec): Double;
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT4DC_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT5DC = class(TCoreClassObject)
  public type
    // code split
    TKDT5DC_Vec = array [0 .. KDT5DC_Axis - 1] of TKDT5DC_VecType;
    PKDT5DC_Vec = ^TKDT5DC_Vec;

    TKDT5DC_DynamicVecBuffer = array of TKDT5DC_Vec;
    PKDT5DC_DynamicVecBuffer = ^TKDT5DC_DynamicVecBuffer;

    TKDT5DC_Source = record
      buff: TKDT5DC_Vec;
      Index: Int64;
      Token: TPascalString;
    end;

    PKDT5DC_Source = ^TKDT5DC_Source;
    TKDT5DC_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT5DC_Source) - 1] of PKDT5DC_Source;
    PKDT5DC_SourceBuffer = ^TKDT5DC_SourceBuffer;

    TKDT5DC_DyanmicSourceBuffer = array of PKDT5DC_Source;
    PKDT5DC_DyanmicSourceBuffer = ^TKDT5DC_DyanmicSourceBuffer;

    TKDT5DC_DyanmicStoreBuffer = array of TKDT5DC_Source;
    PKDT5DC_DyanmicStoreBuffer = ^TKDT5DC_DyanmicStoreBuffer;

    PKDT5DC_Node = ^TKDT5DC_Node;

    TKDT5DC_Node = record
      Parent, Right, Left: PKDT5DC_Node;
      Vec: PKDT5DC_Source;
    end;

    TKDT5DC_BuildCall = procedure(const IndexFor: NativeInt; var Source: TKDT5DC_Source; const Data: Pointer);
    TKDT5DC_BuildMethod = procedure(const IndexFor: NativeInt; var Source: TKDT5DC_Source; const Data: Pointer) of object;
{$IFDEF FPC}
    TKDT5DC_BuildProc = procedure(const IndexFor: NativeInt; var Source: TKDT5DC_Source; const Data: Pointer) is nested;
{$ELSE FPC}
    TKDT5DC_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT5DC_Source; const Data: Pointer);
{$ENDIF FPC}
  private
    KDStoreBuff: TKDT5DC_DyanmicStoreBuffer;
    KDBuff: TKDT5DC_DyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes: array of PKDT5DC_Node;
    TestBuff: TKDT5DC_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT5DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT5DC_Node;
    function GetData(const Index: NativeInt): PKDT5DC_Source;
  public
    RootNode: PKDT5DC_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT5DC_DyanmicStoreBuffer;
    property SourceP[const Index: NativeInt]: PKDT5DC_Source read GetData; default;

    { bakcall build }
    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT5DC_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT5DC_BuildMethod);
    procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT5DC_BuildProc);
    { fill k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT5DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT5DC_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT5DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT5DC_BuildMethod); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT5DC_BuildProc); overload;
    { search }
    function Search(const buff: TKDT5DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT5DC_Node; overload;
    function Search(const buff: TKDT5DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT5DC_Node; overload;
    function Search(const buff: TKDT5DC_Vec; var SearchedDistanceMin: Double): PKDT5DC_Node; overload;
    function Search(const buff: TKDT5DC_Vec): PKDT5DC_Node; overload;
    function SearchToken(const buff: TKDT5DC_Vec): TPascalString;
    { parallel search }
    procedure Search(const inBuff: TKDT5DC_DynamicVecBuffer; var OutBuff: TKDT5DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;
    procedure Search(const inBuff: TKDT5DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);
    procedure SaveToFile(FileName: SystemString);
    procedure LoadFromFile(FileName: SystemString);
    procedure PrintNodeTree(const NodePtr: PKDT5DC_Node);
    procedure PrintBuffer;
    class function Vec(const s: SystemString): TKDT5DC_Vec; overload;
    class function Vec(const v: TKDT5DC_Vec): SystemString; overload;
    class function Distance(const v1, v2: TKDT5DC_Vec): Double;
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT5DC_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT6DC = class(TCoreClassObject)
  public type
    // code split
    TKDT6DC_Vec = array [0 .. KDT6DC_Axis - 1] of TKDT6DC_VecType;
    PKDT6DC_Vec = ^TKDT6DC_Vec;

    TKDT6DC_DynamicVecBuffer = array of TKDT6DC_Vec;
    PKDT6DC_DynamicVecBuffer = ^TKDT6DC_DynamicVecBuffer;

    TKDT6DC_Source = record
      buff: TKDT6DC_Vec;
      Index: Int64;
      Token: TPascalString;
    end;

    PKDT6DC_Source = ^TKDT6DC_Source;
    TKDT6DC_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT6DC_Source) - 1] of PKDT6DC_Source;
    PKDT6DC_SourceBuffer = ^TKDT6DC_SourceBuffer;

    TKDT6DC_DyanmicSourceBuffer = array of PKDT6DC_Source;
    PKDT6DC_DyanmicSourceBuffer = ^TKDT6DC_DyanmicSourceBuffer;

    TKDT6DC_DyanmicStoreBuffer = array of TKDT6DC_Source;
    PKDT6DC_DyanmicStoreBuffer = ^TKDT6DC_DyanmicStoreBuffer;

    PKDT6DC_Node = ^TKDT6DC_Node;

    TKDT6DC_Node = record
      Parent, Right, Left: PKDT6DC_Node;
      Vec: PKDT6DC_Source;
    end;

    TKDT6DC_BuildCall = procedure(const IndexFor: NativeInt; var Source: TKDT6DC_Source; const Data: Pointer);
    TKDT6DC_BuildMethod = procedure(const IndexFor: NativeInt; var Source: TKDT6DC_Source; const Data: Pointer) of object;
{$IFDEF FPC}
    TKDT6DC_BuildProc = procedure(const IndexFor: NativeInt; var Source: TKDT6DC_Source; const Data: Pointer) is nested;
{$ELSE FPC}
    TKDT6DC_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT6DC_Source; const Data: Pointer);
{$ENDIF FPC}
  private
    KDStoreBuff: TKDT6DC_DyanmicStoreBuffer;
    KDBuff: TKDT6DC_DyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes: array of PKDT6DC_Node;
    TestBuff: TKDT6DC_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT6DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT6DC_Node;
    function GetData(const Index: NativeInt): PKDT6DC_Source;
  public
    RootNode: PKDT6DC_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT6DC_DyanmicStoreBuffer;
    property SourceP[const Index: NativeInt]: PKDT6DC_Source read GetData; default;

    { bakcall build }
    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT6DC_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT6DC_BuildMethod);
    procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT6DC_BuildProc);
    { fill k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT6DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT6DC_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT6DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT6DC_BuildMethod); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT6DC_BuildProc); overload;
    { search }
    function Search(const buff: TKDT6DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT6DC_Node; overload;
    function Search(const buff: TKDT6DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT6DC_Node; overload;
    function Search(const buff: TKDT6DC_Vec; var SearchedDistanceMin: Double): PKDT6DC_Node; overload;
    function Search(const buff: TKDT6DC_Vec): PKDT6DC_Node; overload;
    function SearchToken(const buff: TKDT6DC_Vec): TPascalString;
    { parallel search }
    procedure Search(const inBuff: TKDT6DC_DynamicVecBuffer; var OutBuff: TKDT6DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;
    procedure Search(const inBuff: TKDT6DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);
    procedure SaveToFile(FileName: SystemString);
    procedure LoadFromFile(FileName: SystemString);
    procedure PrintNodeTree(const NodePtr: PKDT6DC_Node);
    procedure PrintBuffer;
    class function Vec(const s: SystemString): TKDT6DC_Vec; overload;
    class function Vec(const v: TKDT6DC_Vec): SystemString; overload;
    class function Distance(const v1, v2: TKDT6DC_Vec): Double;
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT6DC_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT7DC = class(TCoreClassObject)
  public type
    // code split
    TKDT7DC_Vec = array [0 .. KDT7DC_Axis - 1] of TKDT7DC_VecType;
    PKDT7DC_Vec = ^TKDT7DC_Vec;

    TKDT7DC_DynamicVecBuffer = array of TKDT7DC_Vec;
    PKDT7DC_DynamicVecBuffer = ^TKDT7DC_DynamicVecBuffer;

    TKDT7DC_Source = record
      buff: TKDT7DC_Vec;
      Index: Int64;
      Token: TPascalString;
    end;

    PKDT7DC_Source = ^TKDT7DC_Source;
    TKDT7DC_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT7DC_Source) - 1] of PKDT7DC_Source;
    PKDT7DC_SourceBuffer = ^TKDT7DC_SourceBuffer;

    TKDT7DC_DyanmicSourceBuffer = array of PKDT7DC_Source;
    PKDT7DC_DyanmicSourceBuffer = ^TKDT7DC_DyanmicSourceBuffer;

    TKDT7DC_DyanmicStoreBuffer = array of TKDT7DC_Source;
    PKDT7DC_DyanmicStoreBuffer = ^TKDT7DC_DyanmicStoreBuffer;

    PKDT7DC_Node = ^TKDT7DC_Node;

    TKDT7DC_Node = record
      Parent, Right, Left: PKDT7DC_Node;
      Vec: PKDT7DC_Source;
    end;

    TKDT7DC_BuildCall = procedure(const IndexFor: NativeInt; var Source: TKDT7DC_Source; const Data: Pointer);
    TKDT7DC_BuildMethod = procedure(const IndexFor: NativeInt; var Source: TKDT7DC_Source; const Data: Pointer) of object;
{$IFDEF FPC}
    TKDT7DC_BuildProc = procedure(const IndexFor: NativeInt; var Source: TKDT7DC_Source; const Data: Pointer) is nested;
{$ELSE FPC}
    TKDT7DC_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT7DC_Source; const Data: Pointer);
{$ENDIF FPC}
  private
    KDStoreBuff: TKDT7DC_DyanmicStoreBuffer;
    KDBuff: TKDT7DC_DyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes: array of PKDT7DC_Node;
    TestBuff: TKDT7DC_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT7DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT7DC_Node;
    function GetData(const Index: NativeInt): PKDT7DC_Source;
  public
    RootNode: PKDT7DC_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT7DC_DyanmicStoreBuffer;
    property SourceP[const Index: NativeInt]: PKDT7DC_Source read GetData; default;

    { bakcall build }
    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT7DC_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT7DC_BuildMethod);
    procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT7DC_BuildProc);
    { fill k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT7DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT7DC_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT7DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT7DC_BuildMethod); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT7DC_BuildProc); overload;
    { search }
    function Search(const buff: TKDT7DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT7DC_Node; overload;
    function Search(const buff: TKDT7DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT7DC_Node; overload;
    function Search(const buff: TKDT7DC_Vec; var SearchedDistanceMin: Double): PKDT7DC_Node; overload;
    function Search(const buff: TKDT7DC_Vec): PKDT7DC_Node; overload;
    function SearchToken(const buff: TKDT7DC_Vec): TPascalString;
    { parallel search }
    procedure Search(const inBuff: TKDT7DC_DynamicVecBuffer; var OutBuff: TKDT7DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;
    procedure Search(const inBuff: TKDT7DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);
    procedure SaveToFile(FileName: SystemString);
    procedure LoadFromFile(FileName: SystemString);
    procedure PrintNodeTree(const NodePtr: PKDT7DC_Node);
    procedure PrintBuffer;
    class function Vec(const s: SystemString): TKDT7DC_Vec; overload;
    class function Vec(const v: TKDT7DC_Vec): SystemString; overload;
    class function Distance(const v1, v2: TKDT7DC_Vec): Double;
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT7DC_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT8DC = class(TCoreClassObject)
  public type
    // code split
    TKDT8DC_Vec = array [0 .. KDT8DC_Axis - 1] of TKDT8DC_VecType;
    PKDT8DC_Vec = ^TKDT8DC_Vec;

    TKDT8DC_DynamicVecBuffer = array of TKDT8DC_Vec;
    PKDT8DC_DynamicVecBuffer = ^TKDT8DC_DynamicVecBuffer;

    TKDT8DC_Source = record
      buff: TKDT8DC_Vec;
      Index: Int64;
      Token: TPascalString;
    end;

    PKDT8DC_Source = ^TKDT8DC_Source;
    TKDT8DC_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT8DC_Source) - 1] of PKDT8DC_Source;
    PKDT8DC_SourceBuffer = ^TKDT8DC_SourceBuffer;

    TKDT8DC_DyanmicSourceBuffer = array of PKDT8DC_Source;
    PKDT8DC_DyanmicSourceBuffer = ^TKDT8DC_DyanmicSourceBuffer;

    TKDT8DC_DyanmicStoreBuffer = array of TKDT8DC_Source;
    PKDT8DC_DyanmicStoreBuffer = ^TKDT8DC_DyanmicStoreBuffer;

    PKDT8DC_Node = ^TKDT8DC_Node;

    TKDT8DC_Node = record
      Parent, Right, Left: PKDT8DC_Node;
      Vec: PKDT8DC_Source;
    end;

    TKDT8DC_BuildCall = procedure(const IndexFor: NativeInt; var Source: TKDT8DC_Source; const Data: Pointer);
    TKDT8DC_BuildMethod = procedure(const IndexFor: NativeInt; var Source: TKDT8DC_Source; const Data: Pointer) of object;
{$IFDEF FPC}
    TKDT8DC_BuildProc = procedure(const IndexFor: NativeInt; var Source: TKDT8DC_Source; const Data: Pointer) is nested;
{$ELSE FPC}
    TKDT8DC_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT8DC_Source; const Data: Pointer);
{$ENDIF FPC}
  private
    KDStoreBuff: TKDT8DC_DyanmicStoreBuffer;
    KDBuff: TKDT8DC_DyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes: array of PKDT8DC_Node;
    TestBuff: TKDT8DC_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT8DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT8DC_Node;
    function GetData(const Index: NativeInt): PKDT8DC_Source;
  public
    RootNode: PKDT8DC_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT8DC_DyanmicStoreBuffer;
    property SourceP[const Index: NativeInt]: PKDT8DC_Source read GetData; default;

    { bakcall build }
    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT8DC_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT8DC_BuildMethod);
    procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT8DC_BuildProc);
    { fill k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT8DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT8DC_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT8DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT8DC_BuildMethod); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT8DC_BuildProc); overload;
    { search }
    function Search(const buff: TKDT8DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT8DC_Node; overload;
    function Search(const buff: TKDT8DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT8DC_Node; overload;
    function Search(const buff: TKDT8DC_Vec; var SearchedDistanceMin: Double): PKDT8DC_Node; overload;
    function Search(const buff: TKDT8DC_Vec): PKDT8DC_Node; overload;
    function SearchToken(const buff: TKDT8DC_Vec): TPascalString;
    { parallel search }
    procedure Search(const inBuff: TKDT8DC_DynamicVecBuffer; var OutBuff: TKDT8DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;
    procedure Search(const inBuff: TKDT8DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);
    procedure SaveToFile(FileName: SystemString);
    procedure LoadFromFile(FileName: SystemString);
    procedure PrintNodeTree(const NodePtr: PKDT8DC_Node);
    procedure PrintBuffer;
    class function Vec(const s: SystemString): TKDT8DC_Vec; overload;
    class function Vec(const v: TKDT8DC_Vec): SystemString; overload;
    class function Distance(const v1, v2: TKDT8DC_Vec): Double;
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT8DC_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT9DC = class(TCoreClassObject)
  public type
    // code split
    TKDT9DC_Vec = array [0 .. KDT9DC_Axis - 1] of TKDT9DC_VecType;
    PKDT9DC_Vec = ^TKDT9DC_Vec;

    TKDT9DC_DynamicVecBuffer = array of TKDT9DC_Vec;
    PKDT9DC_DynamicVecBuffer = ^TKDT9DC_DynamicVecBuffer;

    TKDT9DC_Source = record
      buff: TKDT9DC_Vec;
      Index: Int64;
      Token: TPascalString;
    end;

    PKDT9DC_Source = ^TKDT9DC_Source;
    TKDT9DC_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT9DC_Source) - 1] of PKDT9DC_Source;
    PKDT9DC_SourceBuffer = ^TKDT9DC_SourceBuffer;

    TKDT9DC_DyanmicSourceBuffer = array of PKDT9DC_Source;
    PKDT9DC_DyanmicSourceBuffer = ^TKDT9DC_DyanmicSourceBuffer;

    TKDT9DC_DyanmicStoreBuffer = array of TKDT9DC_Source;
    PKDT9DC_DyanmicStoreBuffer = ^TKDT9DC_DyanmicStoreBuffer;

    PKDT9DC_Node = ^TKDT9DC_Node;

    TKDT9DC_Node = record
      Parent, Right, Left: PKDT9DC_Node;
      Vec: PKDT9DC_Source;
    end;

    TKDT9DC_BuildCall = procedure(const IndexFor: NativeInt; var Source: TKDT9DC_Source; const Data: Pointer);
    TKDT9DC_BuildMethod = procedure(const IndexFor: NativeInt; var Source: TKDT9DC_Source; const Data: Pointer) of object;
{$IFDEF FPC}
    TKDT9DC_BuildProc = procedure(const IndexFor: NativeInt; var Source: TKDT9DC_Source; const Data: Pointer) is nested;
{$ELSE FPC}
    TKDT9DC_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT9DC_Source; const Data: Pointer);
{$ENDIF FPC}
  private
    KDStoreBuff: TKDT9DC_DyanmicStoreBuffer;
    KDBuff: TKDT9DC_DyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes: array of PKDT9DC_Node;
    TestBuff: TKDT9DC_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT9DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT9DC_Node;
    function GetData(const Index: NativeInt): PKDT9DC_Source;
  public
    RootNode: PKDT9DC_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT9DC_DyanmicStoreBuffer;
    property SourceP[const Index: NativeInt]: PKDT9DC_Source read GetData; default;

    { bakcall build }
    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT9DC_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT9DC_BuildMethod);
    procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT9DC_BuildProc);
    { fill k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT9DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT9DC_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT9DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT9DC_BuildMethod); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT9DC_BuildProc); overload;
    { search }
    function Search(const buff: TKDT9DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT9DC_Node; overload;
    function Search(const buff: TKDT9DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT9DC_Node; overload;
    function Search(const buff: TKDT9DC_Vec; var SearchedDistanceMin: Double): PKDT9DC_Node; overload;
    function Search(const buff: TKDT9DC_Vec): PKDT9DC_Node; overload;
    function SearchToken(const buff: TKDT9DC_Vec): TPascalString;
    { parallel search }
    procedure Search(const inBuff: TKDT9DC_DynamicVecBuffer; var OutBuff: TKDT9DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;
    procedure Search(const inBuff: TKDT9DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);
    procedure SaveToFile(FileName: SystemString);
    procedure LoadFromFile(FileName: SystemString);
    procedure PrintNodeTree(const NodePtr: PKDT9DC_Node);
    procedure PrintBuffer;
    class function Vec(const s: SystemString): TKDT9DC_Vec; overload;
    class function Vec(const v: TKDT9DC_Vec): SystemString; overload;
    class function Distance(const v1, v2: TKDT9DC_Vec): Double;
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT9DC_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT10DC = class(TCoreClassObject)
  public type
    // code split
    TKDT10DC_Vec = array [0 .. KDT10DC_Axis - 1] of TKDT10DC_VecType;
    PKDT10DC_Vec = ^TKDT10DC_Vec;

    TKDT10DC_DynamicVecBuffer = array of TKDT10DC_Vec;
    PKDT10DC_DynamicVecBuffer = ^TKDT10DC_DynamicVecBuffer;

    TKDT10DC_Source = record
      buff: TKDT10DC_Vec;
      Index: Int64;
      Token: TPascalString;
    end;

    PKDT10DC_Source = ^TKDT10DC_Source;
    TKDT10DC_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT10DC_Source) - 1] of PKDT10DC_Source;
    PKDT10DC_SourceBuffer = ^TKDT10DC_SourceBuffer;

    TKDT10DC_DyanmicSourceBuffer = array of PKDT10DC_Source;
    PKDT10DC_DyanmicSourceBuffer = ^TKDT10DC_DyanmicSourceBuffer;

    TKDT10DC_DyanmicStoreBuffer = array of TKDT10DC_Source;
    PKDT10DC_DyanmicStoreBuffer = ^TKDT10DC_DyanmicStoreBuffer;

    PKDT10DC_Node = ^TKDT10DC_Node;

    TKDT10DC_Node = record
      Parent, Right, Left: PKDT10DC_Node;
      Vec: PKDT10DC_Source;
    end;

    TKDT10DC_BuildCall = procedure(const IndexFor: NativeInt; var Source: TKDT10DC_Source; const Data: Pointer);
    TKDT10DC_BuildMethod = procedure(const IndexFor: NativeInt; var Source: TKDT10DC_Source; const Data: Pointer) of object;
{$IFDEF FPC}
    TKDT10DC_BuildProc = procedure(const IndexFor: NativeInt; var Source: TKDT10DC_Source; const Data: Pointer) is nested;
{$ELSE FPC}
    TKDT10DC_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT10DC_Source; const Data: Pointer);
{$ENDIF FPC}
  private
    KDStoreBuff: TKDT10DC_DyanmicStoreBuffer;
    KDBuff: TKDT10DC_DyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes: array of PKDT10DC_Node;
    TestBuff: TKDT10DC_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT10DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT10DC_Node;
    function GetData(const Index: NativeInt): PKDT10DC_Source;
  public
    RootNode: PKDT10DC_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT10DC_DyanmicStoreBuffer;
    property SourceP[const Index: NativeInt]: PKDT10DC_Source read GetData; default;

    { bakcall build }
    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT10DC_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT10DC_BuildMethod);
    procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT10DC_BuildProc);
    { fill k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT10DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT10DC_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT10DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT10DC_BuildMethod); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT10DC_BuildProc); overload;
    { search }
    function Search(const buff: TKDT10DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT10DC_Node; overload;
    function Search(const buff: TKDT10DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT10DC_Node; overload;
    function Search(const buff: TKDT10DC_Vec; var SearchedDistanceMin: Double): PKDT10DC_Node; overload;
    function Search(const buff: TKDT10DC_Vec): PKDT10DC_Node; overload;
    function SearchToken(const buff: TKDT10DC_Vec): TPascalString;
    { parallel search }
    procedure Search(const inBuff: TKDT10DC_DynamicVecBuffer; var OutBuff: TKDT10DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;
    procedure Search(const inBuff: TKDT10DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);
    procedure SaveToFile(FileName: SystemString);
    procedure LoadFromFile(FileName: SystemString);
    procedure PrintNodeTree(const NodePtr: PKDT10DC_Node);
    procedure PrintBuffer;
    class function Vec(const s: SystemString): TKDT10DC_Vec; overload;
    class function Vec(const v: TKDT10DC_Vec): SystemString; overload;
    class function Distance(const v1, v2: TKDT10DC_Vec): Double;
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT10DC_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT11DC = class(TCoreClassObject)
  public type
    // code split
    TKDT11DC_Vec = array [0 .. KDT11DC_Axis - 1] of TKDT11DC_VecType;
    PKDT11DC_Vec = ^TKDT11DC_Vec;

    TKDT11DC_DynamicVecBuffer = array of TKDT11DC_Vec;
    PKDT11DC_DynamicVecBuffer = ^TKDT11DC_DynamicVecBuffer;

    TKDT11DC_Source = record
      buff: TKDT11DC_Vec;
      Index: Int64;
      Token: TPascalString;
    end;

    PKDT11DC_Source = ^TKDT11DC_Source;
    TKDT11DC_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT11DC_Source) - 1] of PKDT11DC_Source;
    PKDT11DC_SourceBuffer = ^TKDT11DC_SourceBuffer;

    TKDT11DC_DyanmicSourceBuffer = array of PKDT11DC_Source;
    PKDT11DC_DyanmicSourceBuffer = ^TKDT11DC_DyanmicSourceBuffer;

    TKDT11DC_DyanmicStoreBuffer = array of TKDT11DC_Source;
    PKDT11DC_DyanmicStoreBuffer = ^TKDT11DC_DyanmicStoreBuffer;

    PKDT11DC_Node = ^TKDT11DC_Node;

    TKDT11DC_Node = record
      Parent, Right, Left: PKDT11DC_Node;
      Vec: PKDT11DC_Source;
    end;

    TKDT11DC_BuildCall = procedure(const IndexFor: NativeInt; var Source: TKDT11DC_Source; const Data: Pointer);
    TKDT11DC_BuildMethod = procedure(const IndexFor: NativeInt; var Source: TKDT11DC_Source; const Data: Pointer) of object;
{$IFDEF FPC}
    TKDT11DC_BuildProc = procedure(const IndexFor: NativeInt; var Source: TKDT11DC_Source; const Data: Pointer) is nested;
{$ELSE FPC}
    TKDT11DC_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT11DC_Source; const Data: Pointer);
{$ENDIF FPC}
  private
    KDStoreBuff: TKDT11DC_DyanmicStoreBuffer;
    KDBuff: TKDT11DC_DyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes: array of PKDT11DC_Node;
    TestBuff: TKDT11DC_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT11DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT11DC_Node;
    function GetData(const Index: NativeInt): PKDT11DC_Source;
  public
    RootNode: PKDT11DC_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT11DC_DyanmicStoreBuffer;
    property SourceP[const Index: NativeInt]: PKDT11DC_Source read GetData; default;

    { bakcall build }
    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT11DC_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT11DC_BuildMethod);
    procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT11DC_BuildProc);
    { fill k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT11DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT11DC_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT11DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT11DC_BuildMethod); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT11DC_BuildProc); overload;
    { search }
    function Search(const buff: TKDT11DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT11DC_Node; overload;
    function Search(const buff: TKDT11DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT11DC_Node; overload;
    function Search(const buff: TKDT11DC_Vec; var SearchedDistanceMin: Double): PKDT11DC_Node; overload;
    function Search(const buff: TKDT11DC_Vec): PKDT11DC_Node; overload;
    function SearchToken(const buff: TKDT11DC_Vec): TPascalString;
    { parallel search }
    procedure Search(const inBuff: TKDT11DC_DynamicVecBuffer; var OutBuff: TKDT11DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;
    procedure Search(const inBuff: TKDT11DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);
    procedure SaveToFile(FileName: SystemString);
    procedure LoadFromFile(FileName: SystemString);
    procedure PrintNodeTree(const NodePtr: PKDT11DC_Node);
    procedure PrintBuffer;
    class function Vec(const s: SystemString): TKDT11DC_Vec; overload;
    class function Vec(const v: TKDT11DC_Vec): SystemString; overload;
    class function Distance(const v1, v2: TKDT11DC_Vec): Double;
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT11DC_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT12DC = class(TCoreClassObject)
  public type
    // code split
    TKDT12DC_Vec = array [0 .. KDT12DC_Axis - 1] of TKDT12DC_VecType;
    PKDT12DC_Vec = ^TKDT12DC_Vec;

    TKDT12DC_DynamicVecBuffer = array of TKDT12DC_Vec;
    PKDT12DC_DynamicVecBuffer = ^TKDT12DC_DynamicVecBuffer;

    TKDT12DC_Source = record
      buff: TKDT12DC_Vec;
      Index: Int64;
      Token: TPascalString;
    end;

    PKDT12DC_Source = ^TKDT12DC_Source;
    TKDT12DC_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT12DC_Source) - 1] of PKDT12DC_Source;
    PKDT12DC_SourceBuffer = ^TKDT12DC_SourceBuffer;

    TKDT12DC_DyanmicSourceBuffer = array of PKDT12DC_Source;
    PKDT12DC_DyanmicSourceBuffer = ^TKDT12DC_DyanmicSourceBuffer;

    TKDT12DC_DyanmicStoreBuffer = array of TKDT12DC_Source;
    PKDT12DC_DyanmicStoreBuffer = ^TKDT12DC_DyanmicStoreBuffer;

    PKDT12DC_Node = ^TKDT12DC_Node;

    TKDT12DC_Node = record
      Parent, Right, Left: PKDT12DC_Node;
      Vec: PKDT12DC_Source;
    end;

    TKDT12DC_BuildCall = procedure(const IndexFor: NativeInt; var Source: TKDT12DC_Source; const Data: Pointer);
    TKDT12DC_BuildMethod = procedure(const IndexFor: NativeInt; var Source: TKDT12DC_Source; const Data: Pointer) of object;
{$IFDEF FPC}
    TKDT12DC_BuildProc = procedure(const IndexFor: NativeInt; var Source: TKDT12DC_Source; const Data: Pointer) is nested;
{$ELSE FPC}
    TKDT12DC_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT12DC_Source; const Data: Pointer);
{$ENDIF FPC}
  private
    KDStoreBuff: TKDT12DC_DyanmicStoreBuffer;
    KDBuff: TKDT12DC_DyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes: array of PKDT12DC_Node;
    TestBuff: TKDT12DC_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT12DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT12DC_Node;
    function GetData(const Index: NativeInt): PKDT12DC_Source;
  public
    RootNode: PKDT12DC_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT12DC_DyanmicStoreBuffer;
    property SourceP[const Index: NativeInt]: PKDT12DC_Source read GetData; default;

    { bakcall build }
    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT12DC_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT12DC_BuildMethod);
    procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT12DC_BuildProc);
    { fill k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT12DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT12DC_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT12DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT12DC_BuildMethod); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT12DC_BuildProc); overload;
    { search }
    function Search(const buff: TKDT12DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT12DC_Node; overload;
    function Search(const buff: TKDT12DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT12DC_Node; overload;
    function Search(const buff: TKDT12DC_Vec; var SearchedDistanceMin: Double): PKDT12DC_Node; overload;
    function Search(const buff: TKDT12DC_Vec): PKDT12DC_Node; overload;
    function SearchToken(const buff: TKDT12DC_Vec): TPascalString;
    { parallel search }
    procedure Search(const inBuff: TKDT12DC_DynamicVecBuffer; var OutBuff: TKDT12DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;
    procedure Search(const inBuff: TKDT12DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);
    procedure SaveToFile(FileName: SystemString);
    procedure LoadFromFile(FileName: SystemString);
    procedure PrintNodeTree(const NodePtr: PKDT12DC_Node);
    procedure PrintBuffer;
    class function Vec(const s: SystemString): TKDT12DC_Vec; overload;
    class function Vec(const v: TKDT12DC_Vec): SystemString; overload;
    class function Distance(const v1, v2: TKDT12DC_Vec): Double;
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT12DC_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT13DC = class(TCoreClassObject)
  public type
    // code split
    TKDT13DC_Vec = array [0 .. KDT13DC_Axis - 1] of TKDT13DC_VecType;
    PKDT13DC_Vec = ^TKDT13DC_Vec;

    TKDT13DC_DynamicVecBuffer = array of TKDT13DC_Vec;
    PKDT13DC_DynamicVecBuffer = ^TKDT13DC_DynamicVecBuffer;

    TKDT13DC_Source = record
      buff: TKDT13DC_Vec;
      Index: Int64;
      Token: TPascalString;
    end;

    PKDT13DC_Source = ^TKDT13DC_Source;
    TKDT13DC_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT13DC_Source) - 1] of PKDT13DC_Source;
    PKDT13DC_SourceBuffer = ^TKDT13DC_SourceBuffer;

    TKDT13DC_DyanmicSourceBuffer = array of PKDT13DC_Source;
    PKDT13DC_DyanmicSourceBuffer = ^TKDT13DC_DyanmicSourceBuffer;

    TKDT13DC_DyanmicStoreBuffer = array of TKDT13DC_Source;
    PKDT13DC_DyanmicStoreBuffer = ^TKDT13DC_DyanmicStoreBuffer;

    PKDT13DC_Node = ^TKDT13DC_Node;

    TKDT13DC_Node = record
      Parent, Right, Left: PKDT13DC_Node;
      Vec: PKDT13DC_Source;
    end;

    TKDT13DC_BuildCall = procedure(const IndexFor: NativeInt; var Source: TKDT13DC_Source; const Data: Pointer);
    TKDT13DC_BuildMethod = procedure(const IndexFor: NativeInt; var Source: TKDT13DC_Source; const Data: Pointer) of object;
{$IFDEF FPC}
    TKDT13DC_BuildProc = procedure(const IndexFor: NativeInt; var Source: TKDT13DC_Source; const Data: Pointer) is nested;
{$ELSE FPC}
    TKDT13DC_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT13DC_Source; const Data: Pointer);
{$ENDIF FPC}
  private
    KDStoreBuff: TKDT13DC_DyanmicStoreBuffer;
    KDBuff: TKDT13DC_DyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes: array of PKDT13DC_Node;
    TestBuff: TKDT13DC_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT13DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT13DC_Node;
    function GetData(const Index: NativeInt): PKDT13DC_Source;
  public
    RootNode: PKDT13DC_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT13DC_DyanmicStoreBuffer;
    property SourceP[const Index: NativeInt]: PKDT13DC_Source read GetData; default;

    { bakcall build }
    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT13DC_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT13DC_BuildMethod);
    procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT13DC_BuildProc);
    { fill k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT13DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT13DC_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT13DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT13DC_BuildMethod); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT13DC_BuildProc); overload;
    { search }
    function Search(const buff: TKDT13DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT13DC_Node; overload;
    function Search(const buff: TKDT13DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT13DC_Node; overload;
    function Search(const buff: TKDT13DC_Vec; var SearchedDistanceMin: Double): PKDT13DC_Node; overload;
    function Search(const buff: TKDT13DC_Vec): PKDT13DC_Node; overload;
    function SearchToken(const buff: TKDT13DC_Vec): TPascalString;
    { parallel search }
    procedure Search(const inBuff: TKDT13DC_DynamicVecBuffer; var OutBuff: TKDT13DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;
    procedure Search(const inBuff: TKDT13DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);
    procedure SaveToFile(FileName: SystemString);
    procedure LoadFromFile(FileName: SystemString);
    procedure PrintNodeTree(const NodePtr: PKDT13DC_Node);
    procedure PrintBuffer;
    class function Vec(const s: SystemString): TKDT13DC_Vec; overload;
    class function Vec(const v: TKDT13DC_Vec): SystemString; overload;
    class function Distance(const v1, v2: TKDT13DC_Vec): Double;
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT13DC_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT14DC = class(TCoreClassObject)
  public type
    // code split
    TKDT14DC_Vec = array [0 .. KDT14DC_Axis - 1] of TKDT14DC_VecType;
    PKDT14DC_Vec = ^TKDT14DC_Vec;

    TKDT14DC_DynamicVecBuffer = array of TKDT14DC_Vec;
    PKDT14DC_DynamicVecBuffer = ^TKDT14DC_DynamicVecBuffer;

    TKDT14DC_Source = record
      buff: TKDT14DC_Vec;
      Index: Int64;
      Token: TPascalString;
    end;

    PKDT14DC_Source = ^TKDT14DC_Source;
    TKDT14DC_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT14DC_Source) - 1] of PKDT14DC_Source;
    PKDT14DC_SourceBuffer = ^TKDT14DC_SourceBuffer;

    TKDT14DC_DyanmicSourceBuffer = array of PKDT14DC_Source;
    PKDT14DC_DyanmicSourceBuffer = ^TKDT14DC_DyanmicSourceBuffer;

    TKDT14DC_DyanmicStoreBuffer = array of TKDT14DC_Source;
    PKDT14DC_DyanmicStoreBuffer = ^TKDT14DC_DyanmicStoreBuffer;

    PKDT14DC_Node = ^TKDT14DC_Node;

    TKDT14DC_Node = record
      Parent, Right, Left: PKDT14DC_Node;
      Vec: PKDT14DC_Source;
    end;

    TKDT14DC_BuildCall = procedure(const IndexFor: NativeInt; var Source: TKDT14DC_Source; const Data: Pointer);
    TKDT14DC_BuildMethod = procedure(const IndexFor: NativeInt; var Source: TKDT14DC_Source; const Data: Pointer) of object;
{$IFDEF FPC}
    TKDT14DC_BuildProc = procedure(const IndexFor: NativeInt; var Source: TKDT14DC_Source; const Data: Pointer) is nested;
{$ELSE FPC}
    TKDT14DC_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT14DC_Source; const Data: Pointer);
{$ENDIF FPC}
  private
    KDStoreBuff: TKDT14DC_DyanmicStoreBuffer;
    KDBuff: TKDT14DC_DyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes: array of PKDT14DC_Node;
    TestBuff: TKDT14DC_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT14DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT14DC_Node;
    function GetData(const Index: NativeInt): PKDT14DC_Source;
  public
    RootNode: PKDT14DC_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT14DC_DyanmicStoreBuffer;
    property SourceP[const Index: NativeInt]: PKDT14DC_Source read GetData; default;

    { bakcall build }
    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT14DC_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT14DC_BuildMethod);
    procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT14DC_BuildProc);
    { fill k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT14DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT14DC_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT14DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT14DC_BuildMethod); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT14DC_BuildProc); overload;
    { search }
    function Search(const buff: TKDT14DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT14DC_Node; overload;
    function Search(const buff: TKDT14DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT14DC_Node; overload;
    function Search(const buff: TKDT14DC_Vec; var SearchedDistanceMin: Double): PKDT14DC_Node; overload;
    function Search(const buff: TKDT14DC_Vec): PKDT14DC_Node; overload;
    function SearchToken(const buff: TKDT14DC_Vec): TPascalString;
    { parallel search }
    procedure Search(const inBuff: TKDT14DC_DynamicVecBuffer; var OutBuff: TKDT14DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;
    procedure Search(const inBuff: TKDT14DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);
    procedure SaveToFile(FileName: SystemString);
    procedure LoadFromFile(FileName: SystemString);
    procedure PrintNodeTree(const NodePtr: PKDT14DC_Node);
    procedure PrintBuffer;
    class function Vec(const s: SystemString): TKDT14DC_Vec; overload;
    class function Vec(const v: TKDT14DC_Vec): SystemString; overload;
    class function Distance(const v1, v2: TKDT14DC_Vec): Double;
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT14DC_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT15DC = class(TCoreClassObject)
  public type
    // code split
    TKDT15DC_Vec = array [0 .. KDT15DC_Axis - 1] of TKDT15DC_VecType;
    PKDT15DC_Vec = ^TKDT15DC_Vec;

    TKDT15DC_DynamicVecBuffer = array of TKDT15DC_Vec;
    PKDT15DC_DynamicVecBuffer = ^TKDT15DC_DynamicVecBuffer;

    TKDT15DC_Source = record
      buff: TKDT15DC_Vec;
      Index: Int64;
      Token: TPascalString;
    end;

    PKDT15DC_Source = ^TKDT15DC_Source;
    TKDT15DC_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT15DC_Source) - 1] of PKDT15DC_Source;
    PKDT15DC_SourceBuffer = ^TKDT15DC_SourceBuffer;

    TKDT15DC_DyanmicSourceBuffer = array of PKDT15DC_Source;
    PKDT15DC_DyanmicSourceBuffer = ^TKDT15DC_DyanmicSourceBuffer;

    TKDT15DC_DyanmicStoreBuffer = array of TKDT15DC_Source;
    PKDT15DC_DyanmicStoreBuffer = ^TKDT15DC_DyanmicStoreBuffer;

    PKDT15DC_Node = ^TKDT15DC_Node;

    TKDT15DC_Node = record
      Parent, Right, Left: PKDT15DC_Node;
      Vec: PKDT15DC_Source;
    end;

    TKDT15DC_BuildCall = procedure(const IndexFor: NativeInt; var Source: TKDT15DC_Source; const Data: Pointer);
    TKDT15DC_BuildMethod = procedure(const IndexFor: NativeInt; var Source: TKDT15DC_Source; const Data: Pointer) of object;
{$IFDEF FPC}
    TKDT15DC_BuildProc = procedure(const IndexFor: NativeInt; var Source: TKDT15DC_Source; const Data: Pointer) is nested;
{$ELSE FPC}
    TKDT15DC_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT15DC_Source; const Data: Pointer);
{$ENDIF FPC}
  private
    KDStoreBuff: TKDT15DC_DyanmicStoreBuffer;
    KDBuff: TKDT15DC_DyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes: array of PKDT15DC_Node;
    TestBuff: TKDT15DC_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT15DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT15DC_Node;
    function GetData(const Index: NativeInt): PKDT15DC_Source;
  public
    RootNode: PKDT15DC_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT15DC_DyanmicStoreBuffer;
    property SourceP[const Index: NativeInt]: PKDT15DC_Source read GetData; default;

    { bakcall build }
    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT15DC_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT15DC_BuildMethod);
    procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT15DC_BuildProc);
    { fill k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT15DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT15DC_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT15DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT15DC_BuildMethod); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT15DC_BuildProc); overload;
    { search }
    function Search(const buff: TKDT15DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT15DC_Node; overload;
    function Search(const buff: TKDT15DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT15DC_Node; overload;
    function Search(const buff: TKDT15DC_Vec; var SearchedDistanceMin: Double): PKDT15DC_Node; overload;
    function Search(const buff: TKDT15DC_Vec): PKDT15DC_Node; overload;
    function SearchToken(const buff: TKDT15DC_Vec): TPascalString;
    { parallel search }
    procedure Search(const inBuff: TKDT15DC_DynamicVecBuffer; var OutBuff: TKDT15DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;
    procedure Search(const inBuff: TKDT15DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);
    procedure SaveToFile(FileName: SystemString);
    procedure LoadFromFile(FileName: SystemString);
    procedure PrintNodeTree(const NodePtr: PKDT15DC_Node);
    procedure PrintBuffer;
    class function Vec(const s: SystemString): TKDT15DC_Vec; overload;
    class function Vec(const v: TKDT15DC_Vec): SystemString; overload;
    class function Distance(const v1, v2: TKDT15DC_Vec): Double;
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT15DC_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT16DC = class(TCoreClassObject)
  public type
    // code split
    TKDT16DC_Vec = array [0 .. KDT16DC_Axis - 1] of TKDT16DC_VecType;
    PKDT16DC_Vec = ^TKDT16DC_Vec;

    TKDT16DC_DynamicVecBuffer = array of TKDT16DC_Vec;
    PKDT16DC_DynamicVecBuffer = ^TKDT16DC_DynamicVecBuffer;

    TKDT16DC_Source = record
      buff: TKDT16DC_Vec;
      Index: Int64;
      Token: TPascalString;
    end;

    PKDT16DC_Source = ^TKDT16DC_Source;
    TKDT16DC_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT16DC_Source) - 1] of PKDT16DC_Source;
    PKDT16DC_SourceBuffer = ^TKDT16DC_SourceBuffer;

    TKDT16DC_DyanmicSourceBuffer = array of PKDT16DC_Source;
    PKDT16DC_DyanmicSourceBuffer = ^TKDT16DC_DyanmicSourceBuffer;

    TKDT16DC_DyanmicStoreBuffer = array of TKDT16DC_Source;
    PKDT16DC_DyanmicStoreBuffer = ^TKDT16DC_DyanmicStoreBuffer;

    PKDT16DC_Node = ^TKDT16DC_Node;

    TKDT16DC_Node = record
      Parent, Right, Left: PKDT16DC_Node;
      Vec: PKDT16DC_Source;
    end;

    TKDT16DC_BuildCall = procedure(const IndexFor: NativeInt; var Source: TKDT16DC_Source; const Data: Pointer);
    TKDT16DC_BuildMethod = procedure(const IndexFor: NativeInt; var Source: TKDT16DC_Source; const Data: Pointer) of object;
{$IFDEF FPC}
    TKDT16DC_BuildProc = procedure(const IndexFor: NativeInt; var Source: TKDT16DC_Source; const Data: Pointer) is nested;
{$ELSE FPC}
    TKDT16DC_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT16DC_Source; const Data: Pointer);
{$ENDIF FPC}
  private
    KDStoreBuff: TKDT16DC_DyanmicStoreBuffer;
    KDBuff: TKDT16DC_DyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes: array of PKDT16DC_Node;
    TestBuff: TKDT16DC_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT16DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT16DC_Node;
    function GetData(const Index: NativeInt): PKDT16DC_Source;
  public
    RootNode: PKDT16DC_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT16DC_DyanmicStoreBuffer;
    property SourceP[const Index: NativeInt]: PKDT16DC_Source read GetData; default;

    { bakcall build }
    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT16DC_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT16DC_BuildMethod);
    procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT16DC_BuildProc);
    { fill k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT16DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT16DC_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT16DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT16DC_BuildMethod); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT16DC_BuildProc); overload;
    { search }
    function Search(const buff: TKDT16DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT16DC_Node; overload;
    function Search(const buff: TKDT16DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT16DC_Node; overload;
    function Search(const buff: TKDT16DC_Vec; var SearchedDistanceMin: Double): PKDT16DC_Node; overload;
    function Search(const buff: TKDT16DC_Vec): PKDT16DC_Node; overload;
    function SearchToken(const buff: TKDT16DC_Vec): TPascalString;
    { parallel search }
    procedure Search(const inBuff: TKDT16DC_DynamicVecBuffer; var OutBuff: TKDT16DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;
    procedure Search(const inBuff: TKDT16DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);
    procedure SaveToFile(FileName: SystemString);
    procedure LoadFromFile(FileName: SystemString);
    procedure PrintNodeTree(const NodePtr: PKDT16DC_Node);
    procedure PrintBuffer;
    class function Vec(const s: SystemString): TKDT16DC_Vec; overload;
    class function Vec(const v: TKDT16DC_Vec): SystemString; overload;
    class function Distance(const v1, v2: TKDT16DC_Vec): Double;
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT16DC_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT17DC = class(TCoreClassObject)
  public type
    // code split
    TKDT17DC_Vec = array [0 .. KDT17DC_Axis - 1] of TKDT17DC_VecType;
    PKDT17DC_Vec = ^TKDT17DC_Vec;

    TKDT17DC_DynamicVecBuffer = array of TKDT17DC_Vec;
    PKDT17DC_DynamicVecBuffer = ^TKDT17DC_DynamicVecBuffer;

    TKDT17DC_Source = record
      buff: TKDT17DC_Vec;
      Index: Int64;
      Token: TPascalString;
    end;

    PKDT17DC_Source = ^TKDT17DC_Source;
    TKDT17DC_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT17DC_Source) - 1] of PKDT17DC_Source;
    PKDT17DC_SourceBuffer = ^TKDT17DC_SourceBuffer;

    TKDT17DC_DyanmicSourceBuffer = array of PKDT17DC_Source;
    PKDT17DC_DyanmicSourceBuffer = ^TKDT17DC_DyanmicSourceBuffer;

    TKDT17DC_DyanmicStoreBuffer = array of TKDT17DC_Source;
    PKDT17DC_DyanmicStoreBuffer = ^TKDT17DC_DyanmicStoreBuffer;

    PKDT17DC_Node = ^TKDT17DC_Node;

    TKDT17DC_Node = record
      Parent, Right, Left: PKDT17DC_Node;
      Vec: PKDT17DC_Source;
    end;

    TKDT17DC_BuildCall = procedure(const IndexFor: NativeInt; var Source: TKDT17DC_Source; const Data: Pointer);
    TKDT17DC_BuildMethod = procedure(const IndexFor: NativeInt; var Source: TKDT17DC_Source; const Data: Pointer) of object;
{$IFDEF FPC}
    TKDT17DC_BuildProc = procedure(const IndexFor: NativeInt; var Source: TKDT17DC_Source; const Data: Pointer) is nested;
{$ELSE FPC}
    TKDT17DC_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT17DC_Source; const Data: Pointer);
{$ENDIF FPC}
  private
    KDStoreBuff: TKDT17DC_DyanmicStoreBuffer;
    KDBuff: TKDT17DC_DyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes: array of PKDT17DC_Node;
    TestBuff: TKDT17DC_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT17DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT17DC_Node;
    function GetData(const Index: NativeInt): PKDT17DC_Source;
  public
    RootNode: PKDT17DC_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT17DC_DyanmicStoreBuffer;
    property SourceP[const Index: NativeInt]: PKDT17DC_Source read GetData; default;

    { bakcall build }
    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT17DC_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT17DC_BuildMethod);
    procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT17DC_BuildProc);
    { fill k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT17DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT17DC_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT17DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT17DC_BuildMethod); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT17DC_BuildProc); overload;
    { search }
    function Search(const buff: TKDT17DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT17DC_Node; overload;
    function Search(const buff: TKDT17DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT17DC_Node; overload;
    function Search(const buff: TKDT17DC_Vec; var SearchedDistanceMin: Double): PKDT17DC_Node; overload;
    function Search(const buff: TKDT17DC_Vec): PKDT17DC_Node; overload;
    function SearchToken(const buff: TKDT17DC_Vec): TPascalString;
    { parallel search }
    procedure Search(const inBuff: TKDT17DC_DynamicVecBuffer; var OutBuff: TKDT17DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;
    procedure Search(const inBuff: TKDT17DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);
    procedure SaveToFile(FileName: SystemString);
    procedure LoadFromFile(FileName: SystemString);
    procedure PrintNodeTree(const NodePtr: PKDT17DC_Node);
    procedure PrintBuffer;
    class function Vec(const s: SystemString): TKDT17DC_Vec; overload;
    class function Vec(const v: TKDT17DC_Vec): SystemString; overload;
    class function Distance(const v1, v2: TKDT17DC_Vec): Double;
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT17DC_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT18DC = class(TCoreClassObject)
  public type
    // code split
    TKDT18DC_Vec = array [0 .. KDT18DC_Axis - 1] of TKDT18DC_VecType;
    PKDT18DC_Vec = ^TKDT18DC_Vec;

    TKDT18DC_DynamicVecBuffer = array of TKDT18DC_Vec;
    PKDT18DC_DynamicVecBuffer = ^TKDT18DC_DynamicVecBuffer;

    TKDT18DC_Source = record
      buff: TKDT18DC_Vec;
      Index: Int64;
      Token: TPascalString;
    end;

    PKDT18DC_Source = ^TKDT18DC_Source;
    TKDT18DC_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT18DC_Source) - 1] of PKDT18DC_Source;
    PKDT18DC_SourceBuffer = ^TKDT18DC_SourceBuffer;

    TKDT18DC_DyanmicSourceBuffer = array of PKDT18DC_Source;
    PKDT18DC_DyanmicSourceBuffer = ^TKDT18DC_DyanmicSourceBuffer;

    TKDT18DC_DyanmicStoreBuffer = array of TKDT18DC_Source;
    PKDT18DC_DyanmicStoreBuffer = ^TKDT18DC_DyanmicStoreBuffer;

    PKDT18DC_Node = ^TKDT18DC_Node;

    TKDT18DC_Node = record
      Parent, Right, Left: PKDT18DC_Node;
      Vec: PKDT18DC_Source;
    end;

    TKDT18DC_BuildCall = procedure(const IndexFor: NativeInt; var Source: TKDT18DC_Source; const Data: Pointer);
    TKDT18DC_BuildMethod = procedure(const IndexFor: NativeInt; var Source: TKDT18DC_Source; const Data: Pointer) of object;
{$IFDEF FPC}
    TKDT18DC_BuildProc = procedure(const IndexFor: NativeInt; var Source: TKDT18DC_Source; const Data: Pointer) is nested;
{$ELSE FPC}
    TKDT18DC_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT18DC_Source; const Data: Pointer);
{$ENDIF FPC}
  private
    KDStoreBuff: TKDT18DC_DyanmicStoreBuffer;
    KDBuff: TKDT18DC_DyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes: array of PKDT18DC_Node;
    TestBuff: TKDT18DC_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT18DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT18DC_Node;
    function GetData(const Index: NativeInt): PKDT18DC_Source;
  public
    RootNode: PKDT18DC_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT18DC_DyanmicStoreBuffer;
    property SourceP[const Index: NativeInt]: PKDT18DC_Source read GetData; default;

    { bakcall build }
    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT18DC_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT18DC_BuildMethod);
    procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT18DC_BuildProc);
    { fill k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT18DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT18DC_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT18DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT18DC_BuildMethod); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT18DC_BuildProc); overload;
    { search }
    function Search(const buff: TKDT18DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT18DC_Node; overload;
    function Search(const buff: TKDT18DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT18DC_Node; overload;
    function Search(const buff: TKDT18DC_Vec; var SearchedDistanceMin: Double): PKDT18DC_Node; overload;
    function Search(const buff: TKDT18DC_Vec): PKDT18DC_Node; overload;
    function SearchToken(const buff: TKDT18DC_Vec): TPascalString;
    { parallel search }
    procedure Search(const inBuff: TKDT18DC_DynamicVecBuffer; var OutBuff: TKDT18DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;
    procedure Search(const inBuff: TKDT18DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);
    procedure SaveToFile(FileName: SystemString);
    procedure LoadFromFile(FileName: SystemString);
    procedure PrintNodeTree(const NodePtr: PKDT18DC_Node);
    procedure PrintBuffer;
    class function Vec(const s: SystemString): TKDT18DC_Vec; overload;
    class function Vec(const v: TKDT18DC_Vec): SystemString; overload;
    class function Distance(const v1, v2: TKDT18DC_Vec): Double;
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT18DC_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT19DC = class(TCoreClassObject)
  public type
    // code split
    TKDT19DC_Vec = array [0 .. KDT19DC_Axis - 1] of TKDT19DC_VecType;
    PKDT19DC_Vec = ^TKDT19DC_Vec;

    TKDT19DC_DynamicVecBuffer = array of TKDT19DC_Vec;
    PKDT19DC_DynamicVecBuffer = ^TKDT19DC_DynamicVecBuffer;

    TKDT19DC_Source = record
      buff: TKDT19DC_Vec;
      Index: Int64;
      Token: TPascalString;
    end;

    PKDT19DC_Source = ^TKDT19DC_Source;
    TKDT19DC_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT19DC_Source) - 1] of PKDT19DC_Source;
    PKDT19DC_SourceBuffer = ^TKDT19DC_SourceBuffer;

    TKDT19DC_DyanmicSourceBuffer = array of PKDT19DC_Source;
    PKDT19DC_DyanmicSourceBuffer = ^TKDT19DC_DyanmicSourceBuffer;

    TKDT19DC_DyanmicStoreBuffer = array of TKDT19DC_Source;
    PKDT19DC_DyanmicStoreBuffer = ^TKDT19DC_DyanmicStoreBuffer;

    PKDT19DC_Node = ^TKDT19DC_Node;

    TKDT19DC_Node = record
      Parent, Right, Left: PKDT19DC_Node;
      Vec: PKDT19DC_Source;
    end;

    TKDT19DC_BuildCall = procedure(const IndexFor: NativeInt; var Source: TKDT19DC_Source; const Data: Pointer);
    TKDT19DC_BuildMethod = procedure(const IndexFor: NativeInt; var Source: TKDT19DC_Source; const Data: Pointer) of object;
{$IFDEF FPC}
    TKDT19DC_BuildProc = procedure(const IndexFor: NativeInt; var Source: TKDT19DC_Source; const Data: Pointer) is nested;
{$ELSE FPC}
    TKDT19DC_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT19DC_Source; const Data: Pointer);
{$ENDIF FPC}
  private
    KDStoreBuff: TKDT19DC_DyanmicStoreBuffer;
    KDBuff: TKDT19DC_DyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes: array of PKDT19DC_Node;
    TestBuff: TKDT19DC_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT19DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT19DC_Node;
    function GetData(const Index: NativeInt): PKDT19DC_Source;
  public
    RootNode: PKDT19DC_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT19DC_DyanmicStoreBuffer;
    property SourceP[const Index: NativeInt]: PKDT19DC_Source read GetData; default;

    { bakcall build }
    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT19DC_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT19DC_BuildMethod);
    procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT19DC_BuildProc);
    { fill k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT19DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT19DC_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT19DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT19DC_BuildMethod); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT19DC_BuildProc); overload;
    { search }
    function Search(const buff: TKDT19DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT19DC_Node; overload;
    function Search(const buff: TKDT19DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT19DC_Node; overload;
    function Search(const buff: TKDT19DC_Vec; var SearchedDistanceMin: Double): PKDT19DC_Node; overload;
    function Search(const buff: TKDT19DC_Vec): PKDT19DC_Node; overload;
    function SearchToken(const buff: TKDT19DC_Vec): TPascalString;
    { parallel search }
    procedure Search(const inBuff: TKDT19DC_DynamicVecBuffer; var OutBuff: TKDT19DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;
    procedure Search(const inBuff: TKDT19DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);
    procedure SaveToFile(FileName: SystemString);
    procedure LoadFromFile(FileName: SystemString);
    procedure PrintNodeTree(const NodePtr: PKDT19DC_Node);
    procedure PrintBuffer;
    class function Vec(const s: SystemString): TKDT19DC_Vec; overload;
    class function Vec(const v: TKDT19DC_Vec): SystemString; overload;
    class function Distance(const v1, v2: TKDT19DC_Vec): Double;
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT19DC_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT20DC = class(TCoreClassObject)
  public type
    // code split
    TKDT20DC_Vec = array [0 .. KDT20DC_Axis - 1] of TKDT20DC_VecType;
    PKDT20DC_Vec = ^TKDT20DC_Vec;

    TKDT20DC_DynamicVecBuffer = array of TKDT20DC_Vec;
    PKDT20DC_DynamicVecBuffer = ^TKDT20DC_DynamicVecBuffer;

    TKDT20DC_Source = record
      buff: TKDT20DC_Vec;
      Index: Int64;
      Token: TPascalString;
    end;

    PKDT20DC_Source = ^TKDT20DC_Source;
    TKDT20DC_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT20DC_Source) - 1] of PKDT20DC_Source;
    PKDT20DC_SourceBuffer = ^TKDT20DC_SourceBuffer;

    TKDT20DC_DyanmicSourceBuffer = array of PKDT20DC_Source;
    PKDT20DC_DyanmicSourceBuffer = ^TKDT20DC_DyanmicSourceBuffer;

    TKDT20DC_DyanmicStoreBuffer = array of TKDT20DC_Source;
    PKDT20DC_DyanmicStoreBuffer = ^TKDT20DC_DyanmicStoreBuffer;

    PKDT20DC_Node = ^TKDT20DC_Node;

    TKDT20DC_Node = record
      Parent, Right, Left: PKDT20DC_Node;
      Vec: PKDT20DC_Source;
    end;

    TKDT20DC_BuildCall = procedure(const IndexFor: NativeInt; var Source: TKDT20DC_Source; const Data: Pointer);
    TKDT20DC_BuildMethod = procedure(const IndexFor: NativeInt; var Source: TKDT20DC_Source; const Data: Pointer) of object;
{$IFDEF FPC}
    TKDT20DC_BuildProc = procedure(const IndexFor: NativeInt; var Source: TKDT20DC_Source; const Data: Pointer) is nested;
{$ELSE FPC}
    TKDT20DC_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT20DC_Source; const Data: Pointer);
{$ENDIF FPC}
  private
    KDStoreBuff: TKDT20DC_DyanmicStoreBuffer;
    KDBuff: TKDT20DC_DyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes: array of PKDT20DC_Node;
    TestBuff: TKDT20DC_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT20DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT20DC_Node;
    function GetData(const Index: NativeInt): PKDT20DC_Source;
  public
    RootNode: PKDT20DC_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT20DC_DyanmicStoreBuffer;
    property SourceP[const Index: NativeInt]: PKDT20DC_Source read GetData; default;

    { bakcall build }
    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT20DC_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT20DC_BuildMethod);
    procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT20DC_BuildProc);
    { fill k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT20DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT20DC_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT20DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT20DC_BuildMethod); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT20DC_BuildProc); overload;
    { search }
    function Search(const buff: TKDT20DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT20DC_Node; overload;
    function Search(const buff: TKDT20DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT20DC_Node; overload;
    function Search(const buff: TKDT20DC_Vec; var SearchedDistanceMin: Double): PKDT20DC_Node; overload;
    function Search(const buff: TKDT20DC_Vec): PKDT20DC_Node; overload;
    function SearchToken(const buff: TKDT20DC_Vec): TPascalString;
    { parallel search }
    procedure Search(const inBuff: TKDT20DC_DynamicVecBuffer; var OutBuff: TKDT20DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;
    procedure Search(const inBuff: TKDT20DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);
    procedure SaveToFile(FileName: SystemString);
    procedure LoadFromFile(FileName: SystemString);
    procedure PrintNodeTree(const NodePtr: PKDT20DC_Node);
    procedure PrintBuffer;
    class function Vec(const s: SystemString): TKDT20DC_Vec; overload;
    class function Vec(const v: TKDT20DC_Vec): SystemString; overload;
    class function Distance(const v1, v2: TKDT20DC_Vec): Double;
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT20DC_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT21DC = class(TCoreClassObject)
  public type
    // code split
    TKDT21DC_Vec = array [0 .. KDT21DC_Axis - 1] of TKDT21DC_VecType;
    PKDT21DC_Vec = ^TKDT21DC_Vec;

    TKDT21DC_DynamicVecBuffer = array of TKDT21DC_Vec;
    PKDT21DC_DynamicVecBuffer = ^TKDT21DC_DynamicVecBuffer;

    TKDT21DC_Source = record
      buff: TKDT21DC_Vec;
      Index: Int64;
      Token: TPascalString;
    end;

    PKDT21DC_Source = ^TKDT21DC_Source;
    TKDT21DC_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT21DC_Source) - 1] of PKDT21DC_Source;
    PKDT21DC_SourceBuffer = ^TKDT21DC_SourceBuffer;

    TKDT21DC_DyanmicSourceBuffer = array of PKDT21DC_Source;
    PKDT21DC_DyanmicSourceBuffer = ^TKDT21DC_DyanmicSourceBuffer;

    TKDT21DC_DyanmicStoreBuffer = array of TKDT21DC_Source;
    PKDT21DC_DyanmicStoreBuffer = ^TKDT21DC_DyanmicStoreBuffer;

    PKDT21DC_Node = ^TKDT21DC_Node;

    TKDT21DC_Node = record
      Parent, Right, Left: PKDT21DC_Node;
      Vec: PKDT21DC_Source;
    end;

    TKDT21DC_BuildCall = procedure(const IndexFor: NativeInt; var Source: TKDT21DC_Source; const Data: Pointer);
    TKDT21DC_BuildMethod = procedure(const IndexFor: NativeInt; var Source: TKDT21DC_Source; const Data: Pointer) of object;
{$IFDEF FPC}
    TKDT21DC_BuildProc = procedure(const IndexFor: NativeInt; var Source: TKDT21DC_Source; const Data: Pointer) is nested;
{$ELSE FPC}
    TKDT21DC_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT21DC_Source; const Data: Pointer);
{$ENDIF FPC}
  private
    KDStoreBuff: TKDT21DC_DyanmicStoreBuffer;
    KDBuff: TKDT21DC_DyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes: array of PKDT21DC_Node;
    TestBuff: TKDT21DC_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT21DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT21DC_Node;
    function GetData(const Index: NativeInt): PKDT21DC_Source;
  public
    RootNode: PKDT21DC_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT21DC_DyanmicStoreBuffer;
    property SourceP[const Index: NativeInt]: PKDT21DC_Source read GetData; default;

    { bakcall build }
    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT21DC_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT21DC_BuildMethod);
    procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT21DC_BuildProc);
    { fill k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT21DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT21DC_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT21DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT21DC_BuildMethod); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT21DC_BuildProc); overload;
    { search }
    function Search(const buff: TKDT21DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT21DC_Node; overload;
    function Search(const buff: TKDT21DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT21DC_Node; overload;
    function Search(const buff: TKDT21DC_Vec; var SearchedDistanceMin: Double): PKDT21DC_Node; overload;
    function Search(const buff: TKDT21DC_Vec): PKDT21DC_Node; overload;
    function SearchToken(const buff: TKDT21DC_Vec): TPascalString;
    { parallel search }
    procedure Search(const inBuff: TKDT21DC_DynamicVecBuffer; var OutBuff: TKDT21DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;
    procedure Search(const inBuff: TKDT21DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);
    procedure SaveToFile(FileName: SystemString);
    procedure LoadFromFile(FileName: SystemString);
    procedure PrintNodeTree(const NodePtr: PKDT21DC_Node);
    procedure PrintBuffer;
    class function Vec(const s: SystemString): TKDT21DC_Vec; overload;
    class function Vec(const v: TKDT21DC_Vec): SystemString; overload;
    class function Distance(const v1, v2: TKDT21DC_Vec): Double;
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT21DC_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT22DC = class(TCoreClassObject)
  public type
    // code split
    TKDT22DC_Vec = array [0 .. KDT22DC_Axis - 1] of TKDT22DC_VecType;
    PKDT22DC_Vec = ^TKDT22DC_Vec;

    TKDT22DC_DynamicVecBuffer = array of TKDT22DC_Vec;
    PKDT22DC_DynamicVecBuffer = ^TKDT22DC_DynamicVecBuffer;

    TKDT22DC_Source = record
      buff: TKDT22DC_Vec;
      Index: Int64;
      Token: TPascalString;
    end;

    PKDT22DC_Source = ^TKDT22DC_Source;
    TKDT22DC_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT22DC_Source) - 1] of PKDT22DC_Source;
    PKDT22DC_SourceBuffer = ^TKDT22DC_SourceBuffer;

    TKDT22DC_DyanmicSourceBuffer = array of PKDT22DC_Source;
    PKDT22DC_DyanmicSourceBuffer = ^TKDT22DC_DyanmicSourceBuffer;

    TKDT22DC_DyanmicStoreBuffer = array of TKDT22DC_Source;
    PKDT22DC_DyanmicStoreBuffer = ^TKDT22DC_DyanmicStoreBuffer;

    PKDT22DC_Node = ^TKDT22DC_Node;

    TKDT22DC_Node = record
      Parent, Right, Left: PKDT22DC_Node;
      Vec: PKDT22DC_Source;
    end;

    TKDT22DC_BuildCall = procedure(const IndexFor: NativeInt; var Source: TKDT22DC_Source; const Data: Pointer);
    TKDT22DC_BuildMethod = procedure(const IndexFor: NativeInt; var Source: TKDT22DC_Source; const Data: Pointer) of object;
{$IFDEF FPC}
    TKDT22DC_BuildProc = procedure(const IndexFor: NativeInt; var Source: TKDT22DC_Source; const Data: Pointer) is nested;
{$ELSE FPC}
    TKDT22DC_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT22DC_Source; const Data: Pointer);
{$ENDIF FPC}
  private
    KDStoreBuff: TKDT22DC_DyanmicStoreBuffer;
    KDBuff: TKDT22DC_DyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes: array of PKDT22DC_Node;
    TestBuff: TKDT22DC_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT22DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT22DC_Node;
    function GetData(const Index: NativeInt): PKDT22DC_Source;
  public
    RootNode: PKDT22DC_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT22DC_DyanmicStoreBuffer;
    property SourceP[const Index: NativeInt]: PKDT22DC_Source read GetData; default;

    { bakcall build }
    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT22DC_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT22DC_BuildMethod);
    procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT22DC_BuildProc);
    { fill k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT22DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT22DC_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT22DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT22DC_BuildMethod); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT22DC_BuildProc); overload;
    { search }
    function Search(const buff: TKDT22DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT22DC_Node; overload;
    function Search(const buff: TKDT22DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT22DC_Node; overload;
    function Search(const buff: TKDT22DC_Vec; var SearchedDistanceMin: Double): PKDT22DC_Node; overload;
    function Search(const buff: TKDT22DC_Vec): PKDT22DC_Node; overload;
    function SearchToken(const buff: TKDT22DC_Vec): TPascalString;
    { parallel search }
    procedure Search(const inBuff: TKDT22DC_DynamicVecBuffer; var OutBuff: TKDT22DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;
    procedure Search(const inBuff: TKDT22DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);
    procedure SaveToFile(FileName: SystemString);
    procedure LoadFromFile(FileName: SystemString);
    procedure PrintNodeTree(const NodePtr: PKDT22DC_Node);
    procedure PrintBuffer;
    class function Vec(const s: SystemString): TKDT22DC_Vec; overload;
    class function Vec(const v: TKDT22DC_Vec): SystemString; overload;
    class function Distance(const v1, v2: TKDT22DC_Vec): Double;
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT22DC_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT23DC = class(TCoreClassObject)
  public type
    // code split
    TKDT23DC_Vec = array [0 .. KDT23DC_Axis - 1] of TKDT23DC_VecType;
    PKDT23DC_Vec = ^TKDT23DC_Vec;

    TKDT23DC_DynamicVecBuffer = array of TKDT23DC_Vec;
    PKDT23DC_DynamicVecBuffer = ^TKDT23DC_DynamicVecBuffer;

    TKDT23DC_Source = record
      buff: TKDT23DC_Vec;
      Index: Int64;
      Token: TPascalString;
    end;

    PKDT23DC_Source = ^TKDT23DC_Source;
    TKDT23DC_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT23DC_Source) - 1] of PKDT23DC_Source;
    PKDT23DC_SourceBuffer = ^TKDT23DC_SourceBuffer;

    TKDT23DC_DyanmicSourceBuffer = array of PKDT23DC_Source;
    PKDT23DC_DyanmicSourceBuffer = ^TKDT23DC_DyanmicSourceBuffer;

    TKDT23DC_DyanmicStoreBuffer = array of TKDT23DC_Source;
    PKDT23DC_DyanmicStoreBuffer = ^TKDT23DC_DyanmicStoreBuffer;

    PKDT23DC_Node = ^TKDT23DC_Node;

    TKDT23DC_Node = record
      Parent, Right, Left: PKDT23DC_Node;
      Vec: PKDT23DC_Source;
    end;

    TKDT23DC_BuildCall = procedure(const IndexFor: NativeInt; var Source: TKDT23DC_Source; const Data: Pointer);
    TKDT23DC_BuildMethod = procedure(const IndexFor: NativeInt; var Source: TKDT23DC_Source; const Data: Pointer) of object;
{$IFDEF FPC}
    TKDT23DC_BuildProc = procedure(const IndexFor: NativeInt; var Source: TKDT23DC_Source; const Data: Pointer) is nested;
{$ELSE FPC}
    TKDT23DC_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT23DC_Source; const Data: Pointer);
{$ENDIF FPC}
  private
    KDStoreBuff: TKDT23DC_DyanmicStoreBuffer;
    KDBuff: TKDT23DC_DyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes: array of PKDT23DC_Node;
    TestBuff: TKDT23DC_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT23DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT23DC_Node;
    function GetData(const Index: NativeInt): PKDT23DC_Source;
  public
    RootNode: PKDT23DC_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT23DC_DyanmicStoreBuffer;
    property SourceP[const Index: NativeInt]: PKDT23DC_Source read GetData; default;

    { bakcall build }
    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT23DC_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT23DC_BuildMethod);
    procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT23DC_BuildProc);
    { fill k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT23DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT23DC_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT23DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT23DC_BuildMethod); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT23DC_BuildProc); overload;
    { search }
    function Search(const buff: TKDT23DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT23DC_Node; overload;
    function Search(const buff: TKDT23DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT23DC_Node; overload;
    function Search(const buff: TKDT23DC_Vec; var SearchedDistanceMin: Double): PKDT23DC_Node; overload;
    function Search(const buff: TKDT23DC_Vec): PKDT23DC_Node; overload;
    function SearchToken(const buff: TKDT23DC_Vec): TPascalString;
    { parallel search }
    procedure Search(const inBuff: TKDT23DC_DynamicVecBuffer; var OutBuff: TKDT23DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;
    procedure Search(const inBuff: TKDT23DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);
    procedure SaveToFile(FileName: SystemString);
    procedure LoadFromFile(FileName: SystemString);
    procedure PrintNodeTree(const NodePtr: PKDT23DC_Node);
    procedure PrintBuffer;
    class function Vec(const s: SystemString): TKDT23DC_Vec; overload;
    class function Vec(const v: TKDT23DC_Vec): SystemString; overload;
    class function Distance(const v1, v2: TKDT23DC_Vec): Double;
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT23DC_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT24DC = class(TCoreClassObject)
  public type
    // code split
    TKDT24DC_Vec = array [0 .. KDT24DC_Axis - 1] of TKDT24DC_VecType;
    PKDT24DC_Vec = ^TKDT24DC_Vec;

    TKDT24DC_DynamicVecBuffer = array of TKDT24DC_Vec;
    PKDT24DC_DynamicVecBuffer = ^TKDT24DC_DynamicVecBuffer;

    TKDT24DC_Source = record
      buff: TKDT24DC_Vec;
      Index: Int64;
      Token: TPascalString;
    end;

    PKDT24DC_Source = ^TKDT24DC_Source;
    TKDT24DC_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT24DC_Source) - 1] of PKDT24DC_Source;
    PKDT24DC_SourceBuffer = ^TKDT24DC_SourceBuffer;

    TKDT24DC_DyanmicSourceBuffer = array of PKDT24DC_Source;
    PKDT24DC_DyanmicSourceBuffer = ^TKDT24DC_DyanmicSourceBuffer;

    TKDT24DC_DyanmicStoreBuffer = array of TKDT24DC_Source;
    PKDT24DC_DyanmicStoreBuffer = ^TKDT24DC_DyanmicStoreBuffer;

    PKDT24DC_Node = ^TKDT24DC_Node;

    TKDT24DC_Node = record
      Parent, Right, Left: PKDT24DC_Node;
      Vec: PKDT24DC_Source;
    end;

    TKDT24DC_BuildCall = procedure(const IndexFor: NativeInt; var Source: TKDT24DC_Source; const Data: Pointer);
    TKDT24DC_BuildMethod = procedure(const IndexFor: NativeInt; var Source: TKDT24DC_Source; const Data: Pointer) of object;
{$IFDEF FPC}
    TKDT24DC_BuildProc = procedure(const IndexFor: NativeInt; var Source: TKDT24DC_Source; const Data: Pointer) is nested;
{$ELSE FPC}
    TKDT24DC_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT24DC_Source; const Data: Pointer);
{$ENDIF FPC}
  private
    KDStoreBuff: TKDT24DC_DyanmicStoreBuffer;
    KDBuff: TKDT24DC_DyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes: array of PKDT24DC_Node;
    TestBuff: TKDT24DC_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT24DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT24DC_Node;
    function GetData(const Index: NativeInt): PKDT24DC_Source;
  public
    RootNode: PKDT24DC_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT24DC_DyanmicStoreBuffer;
    property SourceP[const Index: NativeInt]: PKDT24DC_Source read GetData; default;

    { bakcall build }
    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT24DC_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT24DC_BuildMethod);
    procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT24DC_BuildProc);
    { fill k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT24DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT24DC_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT24DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT24DC_BuildMethod); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT24DC_BuildProc); overload;
    { search }
    function Search(const buff: TKDT24DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT24DC_Node; overload;
    function Search(const buff: TKDT24DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT24DC_Node; overload;
    function Search(const buff: TKDT24DC_Vec; var SearchedDistanceMin: Double): PKDT24DC_Node; overload;
    function Search(const buff: TKDT24DC_Vec): PKDT24DC_Node; overload;
    function SearchToken(const buff: TKDT24DC_Vec): TPascalString;
    { parallel search }
    procedure Search(const inBuff: TKDT24DC_DynamicVecBuffer; var OutBuff: TKDT24DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;
    procedure Search(const inBuff: TKDT24DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);
    procedure SaveToFile(FileName: SystemString);
    procedure LoadFromFile(FileName: SystemString);
    procedure PrintNodeTree(const NodePtr: PKDT24DC_Node);
    procedure PrintBuffer;
    class function Vec(const s: SystemString): TKDT24DC_Vec; overload;
    class function Vec(const v: TKDT24DC_Vec): SystemString; overload;
    class function Distance(const v1, v2: TKDT24DC_Vec): Double;
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT24DC_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT48DC = class(TCoreClassObject)
  public type
    // code split
    TKDT48DC_Vec = array [0 .. KDT48DC_Axis - 1] of TKDT48DC_VecType;
    PKDT48DC_Vec = ^TKDT48DC_Vec;

    TKDT48DC_DynamicVecBuffer = array of TKDT48DC_Vec;
    PKDT48DC_DynamicVecBuffer = ^TKDT48DC_DynamicVecBuffer;

    TKDT48DC_Source = record
      buff: TKDT48DC_Vec;
      Index: Int64;
      Token: TPascalString;
    end;

    PKDT48DC_Source = ^TKDT48DC_Source;
    TKDT48DC_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT48DC_Source) - 1] of PKDT48DC_Source;
    PKDT48DC_SourceBuffer = ^TKDT48DC_SourceBuffer;

    TKDT48DC_DyanmicSourceBuffer = array of PKDT48DC_Source;
    PKDT48DC_DyanmicSourceBuffer = ^TKDT48DC_DyanmicSourceBuffer;

    TKDT48DC_DyanmicStoreBuffer = array of TKDT48DC_Source;
    PKDT48DC_DyanmicStoreBuffer = ^TKDT48DC_DyanmicStoreBuffer;

    PKDT48DC_Node = ^TKDT48DC_Node;

    TKDT48DC_Node = record
      Parent, Right, Left: PKDT48DC_Node;
      Vec: PKDT48DC_Source;
    end;

    TKDT48DC_BuildCall = procedure(const IndexFor: NativeInt; var Source: TKDT48DC_Source; const Data: Pointer);
    TKDT48DC_BuildMethod = procedure(const IndexFor: NativeInt; var Source: TKDT48DC_Source; const Data: Pointer) of object;
{$IFDEF FPC}
    TKDT48DC_BuildProc = procedure(const IndexFor: NativeInt; var Source: TKDT48DC_Source; const Data: Pointer) is nested;
{$ELSE FPC}
    TKDT48DC_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT48DC_Source; const Data: Pointer);
{$ENDIF FPC}
  private
    KDStoreBuff: TKDT48DC_DyanmicStoreBuffer;
    KDBuff: TKDT48DC_DyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes: array of PKDT48DC_Node;
    TestBuff: TKDT48DC_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT48DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT48DC_Node;
    function GetData(const Index: NativeInt): PKDT48DC_Source;
  public
    RootNode: PKDT48DC_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT48DC_DyanmicStoreBuffer;
    property SourceP[const Index: NativeInt]: PKDT48DC_Source read GetData; default;

    { bakcall build }
    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT48DC_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT48DC_BuildMethod);
    procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT48DC_BuildProc);
    { fill k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT48DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT48DC_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT48DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT48DC_BuildMethod); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT48DC_BuildProc); overload;
    { search }
    function Search(const buff: TKDT48DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT48DC_Node; overload;
    function Search(const buff: TKDT48DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT48DC_Node; overload;
    function Search(const buff: TKDT48DC_Vec; var SearchedDistanceMin: Double): PKDT48DC_Node; overload;
    function Search(const buff: TKDT48DC_Vec): PKDT48DC_Node; overload;
    function SearchToken(const buff: TKDT48DC_Vec): TPascalString;
    { parallel search }
    procedure Search(const inBuff: TKDT48DC_DynamicVecBuffer; var OutBuff: TKDT48DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;
    procedure Search(const inBuff: TKDT48DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);
    procedure SaveToFile(FileName: SystemString);
    procedure LoadFromFile(FileName: SystemString);
    procedure PrintNodeTree(const NodePtr: PKDT48DC_Node);
    procedure PrintBuffer;
    class function Vec(const s: SystemString): TKDT48DC_Vec; overload;
    class function Vec(const v: TKDT48DC_Vec): SystemString; overload;
    class function Distance(const v1, v2: TKDT48DC_Vec): Double;
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT48DC_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT52DC = class(TCoreClassObject)
  public type
    // code split
    TKDT52DC_Vec = array [0 .. KDT52DC_Axis - 1] of TKDT52DC_VecType;
    PKDT52DC_Vec = ^TKDT52DC_Vec;

    TKDT52DC_DynamicVecBuffer = array of TKDT52DC_Vec;
    PKDT52DC_DynamicVecBuffer = ^TKDT52DC_DynamicVecBuffer;

    TKDT52DC_Source = record
      buff: TKDT52DC_Vec;
      Index: Int64;
      Token: TPascalString;
    end;

    PKDT52DC_Source = ^TKDT52DC_Source;
    TKDT52DC_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT52DC_Source) - 1] of PKDT52DC_Source;
    PKDT52DC_SourceBuffer = ^TKDT52DC_SourceBuffer;

    TKDT52DC_DyanmicSourceBuffer = array of PKDT52DC_Source;
    PKDT52DC_DyanmicSourceBuffer = ^TKDT52DC_DyanmicSourceBuffer;

    TKDT52DC_DyanmicStoreBuffer = array of TKDT52DC_Source;
    PKDT52DC_DyanmicStoreBuffer = ^TKDT52DC_DyanmicStoreBuffer;

    PKDT52DC_Node = ^TKDT52DC_Node;

    TKDT52DC_Node = record
      Parent, Right, Left: PKDT52DC_Node;
      Vec: PKDT52DC_Source;
    end;

    TKDT52DC_BuildCall = procedure(const IndexFor: NativeInt; var Source: TKDT52DC_Source; const Data: Pointer);
    TKDT52DC_BuildMethod = procedure(const IndexFor: NativeInt; var Source: TKDT52DC_Source; const Data: Pointer) of object;
{$IFDEF FPC}
    TKDT52DC_BuildProc = procedure(const IndexFor: NativeInt; var Source: TKDT52DC_Source; const Data: Pointer) is nested;
{$ELSE FPC}
    TKDT52DC_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT52DC_Source; const Data: Pointer);
{$ENDIF FPC}
  private
    KDStoreBuff: TKDT52DC_DyanmicStoreBuffer;
    KDBuff: TKDT52DC_DyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes: array of PKDT52DC_Node;
    TestBuff: TKDT52DC_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT52DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT52DC_Node;
    function GetData(const Index: NativeInt): PKDT52DC_Source;
  public
    RootNode: PKDT52DC_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT52DC_DyanmicStoreBuffer;
    property SourceP[const Index: NativeInt]: PKDT52DC_Source read GetData; default;

    { bakcall build }
    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT52DC_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT52DC_BuildMethod);
    procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT52DC_BuildProc);
    { fill k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT52DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT52DC_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT52DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT52DC_BuildMethod); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT52DC_BuildProc); overload;
    { search }
    function Search(const buff: TKDT52DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT52DC_Node; overload;
    function Search(const buff: TKDT52DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT52DC_Node; overload;
    function Search(const buff: TKDT52DC_Vec; var SearchedDistanceMin: Double): PKDT52DC_Node; overload;
    function Search(const buff: TKDT52DC_Vec): PKDT52DC_Node; overload;
    function SearchToken(const buff: TKDT52DC_Vec): TPascalString;
    { parallel search }
    procedure Search(const inBuff: TKDT52DC_DynamicVecBuffer; var OutBuff: TKDT52DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;
    procedure Search(const inBuff: TKDT52DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);
    procedure SaveToFile(FileName: SystemString);
    procedure LoadFromFile(FileName: SystemString);
    procedure PrintNodeTree(const NodePtr: PKDT52DC_Node);
    procedure PrintBuffer;
    class function Vec(const s: SystemString): TKDT52DC_Vec; overload;
    class function Vec(const v: TKDT52DC_Vec): SystemString; overload;
    class function Distance(const v1, v2: TKDT52DC_Vec): Double;
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT52DC_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT64DC = class(TCoreClassObject)
  public type
    // code split
    TKDT64DC_Vec = array [0 .. KDT64DC_Axis - 1] of TKDT64DC_VecType;
    PKDT64DC_Vec = ^TKDT64DC_Vec;

    TKDT64DC_DynamicVecBuffer = array of TKDT64DC_Vec;
    PKDT64DC_DynamicVecBuffer = ^TKDT64DC_DynamicVecBuffer;

    TKDT64DC_Source = record
      buff: TKDT64DC_Vec;
      Index: Int64;
      Token: TPascalString;
    end;

    PKDT64DC_Source = ^TKDT64DC_Source;
    TKDT64DC_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT64DC_Source) - 1] of PKDT64DC_Source;
    PKDT64DC_SourceBuffer = ^TKDT64DC_SourceBuffer;

    TKDT64DC_DyanmicSourceBuffer = array of PKDT64DC_Source;
    PKDT64DC_DyanmicSourceBuffer = ^TKDT64DC_DyanmicSourceBuffer;

    TKDT64DC_DyanmicStoreBuffer = array of TKDT64DC_Source;
    PKDT64DC_DyanmicStoreBuffer = ^TKDT64DC_DyanmicStoreBuffer;

    PKDT64DC_Node = ^TKDT64DC_Node;

    TKDT64DC_Node = record
      Parent, Right, Left: PKDT64DC_Node;
      Vec: PKDT64DC_Source;
    end;

    TKDT64DC_BuildCall = procedure(const IndexFor: NativeInt; var Source: TKDT64DC_Source; const Data: Pointer);
    TKDT64DC_BuildMethod = procedure(const IndexFor: NativeInt; var Source: TKDT64DC_Source; const Data: Pointer) of object;
{$IFDEF FPC}
    TKDT64DC_BuildProc = procedure(const IndexFor: NativeInt; var Source: TKDT64DC_Source; const Data: Pointer) is nested;
{$ELSE FPC}
    TKDT64DC_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT64DC_Source; const Data: Pointer);
{$ENDIF FPC}
  private
    KDStoreBuff: TKDT64DC_DyanmicStoreBuffer;
    KDBuff: TKDT64DC_DyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes: array of PKDT64DC_Node;
    TestBuff: TKDT64DC_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT64DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT64DC_Node;
    function GetData(const Index: NativeInt): PKDT64DC_Source;
  public
    RootNode: PKDT64DC_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT64DC_DyanmicStoreBuffer;
    property SourceP[const Index: NativeInt]: PKDT64DC_Source read GetData; default;

    { bakcall build }
    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT64DC_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT64DC_BuildMethod);
    procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT64DC_BuildProc);
    { fill k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT64DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT64DC_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT64DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT64DC_BuildMethod); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT64DC_BuildProc); overload;
    { search }
    function Search(const buff: TKDT64DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT64DC_Node; overload;
    function Search(const buff: TKDT64DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT64DC_Node; overload;
    function Search(const buff: TKDT64DC_Vec; var SearchedDistanceMin: Double): PKDT64DC_Node; overload;
    function Search(const buff: TKDT64DC_Vec): PKDT64DC_Node; overload;
    function SearchToken(const buff: TKDT64DC_Vec): TPascalString;
    { parallel search }
    procedure Search(const inBuff: TKDT64DC_DynamicVecBuffer; var OutBuff: TKDT64DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;
    procedure Search(const inBuff: TKDT64DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);
    procedure SaveToFile(FileName: SystemString);
    procedure LoadFromFile(FileName: SystemString);
    procedure PrintNodeTree(const NodePtr: PKDT64DC_Node);
    procedure PrintBuffer;
    class function Vec(const s: SystemString): TKDT64DC_Vec; overload;
    class function Vec(const v: TKDT64DC_Vec): SystemString; overload;
    class function Distance(const v1, v2: TKDT64DC_Vec): Double;
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT64DC_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT96DC = class(TCoreClassObject)
  public type
    // code split
    TKDT96DC_Vec = array [0 .. KDT96DC_Axis - 1] of TKDT96DC_VecType;
    PKDT96DC_Vec = ^TKDT96DC_Vec;

    TKDT96DC_DynamicVecBuffer = array of TKDT96DC_Vec;
    PKDT96DC_DynamicVecBuffer = ^TKDT96DC_DynamicVecBuffer;

    TKDT96DC_Source = record
      buff: TKDT96DC_Vec;
      Index: Int64;
      Token: TPascalString;
    end;

    PKDT96DC_Source = ^TKDT96DC_Source;
    TKDT96DC_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT96DC_Source) - 1] of PKDT96DC_Source;
    PKDT96DC_SourceBuffer = ^TKDT96DC_SourceBuffer;

    TKDT96DC_DyanmicSourceBuffer = array of PKDT96DC_Source;
    PKDT96DC_DyanmicSourceBuffer = ^TKDT96DC_DyanmicSourceBuffer;

    TKDT96DC_DyanmicStoreBuffer = array of TKDT96DC_Source;
    PKDT96DC_DyanmicStoreBuffer = ^TKDT96DC_DyanmicStoreBuffer;

    PKDT96DC_Node = ^TKDT96DC_Node;

    TKDT96DC_Node = record
      Parent, Right, Left: PKDT96DC_Node;
      Vec: PKDT96DC_Source;
    end;

    TKDT96DC_BuildCall = procedure(const IndexFor: NativeInt; var Source: TKDT96DC_Source; const Data: Pointer);
    TKDT96DC_BuildMethod = procedure(const IndexFor: NativeInt; var Source: TKDT96DC_Source; const Data: Pointer) of object;
{$IFDEF FPC}
    TKDT96DC_BuildProc = procedure(const IndexFor: NativeInt; var Source: TKDT96DC_Source; const Data: Pointer) is nested;
{$ELSE FPC}
    TKDT96DC_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT96DC_Source; const Data: Pointer);
{$ENDIF FPC}
  private
    KDStoreBuff: TKDT96DC_DyanmicStoreBuffer;
    KDBuff: TKDT96DC_DyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes: array of PKDT96DC_Node;
    TestBuff: TKDT96DC_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT96DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT96DC_Node;
    function GetData(const Index: NativeInt): PKDT96DC_Source;
  public
    RootNode: PKDT96DC_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT96DC_DyanmicStoreBuffer;
    property SourceP[const Index: NativeInt]: PKDT96DC_Source read GetData; default;

    { bakcall build }
    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT96DC_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT96DC_BuildMethod);
    procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT96DC_BuildProc);
    { fill k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT96DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT96DC_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT96DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT96DC_BuildMethod); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT96DC_BuildProc); overload;
    { search }
    function Search(const buff: TKDT96DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT96DC_Node; overload;
    function Search(const buff: TKDT96DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT96DC_Node; overload;
    function Search(const buff: TKDT96DC_Vec; var SearchedDistanceMin: Double): PKDT96DC_Node; overload;
    function Search(const buff: TKDT96DC_Vec): PKDT96DC_Node; overload;
    function SearchToken(const buff: TKDT96DC_Vec): TPascalString;
    { parallel search }
    procedure Search(const inBuff: TKDT96DC_DynamicVecBuffer; var OutBuff: TKDT96DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;
    procedure Search(const inBuff: TKDT96DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);
    procedure SaveToFile(FileName: SystemString);
    procedure LoadFromFile(FileName: SystemString);
    procedure PrintNodeTree(const NodePtr: PKDT96DC_Node);
    procedure PrintBuffer;
    class function Vec(const s: SystemString): TKDT96DC_Vec; overload;
    class function Vec(const v: TKDT96DC_Vec): SystemString; overload;
    class function Distance(const v1, v2: TKDT96DC_Vec): Double;
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT96DC_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT128DC = class(TCoreClassObject)
  public type
    // code split
    TKDT128DC_Vec = array [0 .. KDT128DC_Axis - 1] of TKDT128DC_VecType;
    PKDT128DC_Vec = ^TKDT128DC_Vec;

    TKDT128DC_DynamicVecBuffer = array of TKDT128DC_Vec;
    PKDT128DC_DynamicVecBuffer = ^TKDT128DC_DynamicVecBuffer;

    TKDT128DC_Source = record
      buff: TKDT128DC_Vec;
      Index: Int64;
      Token: TPascalString;
    end;

    PKDT128DC_Source = ^TKDT128DC_Source;
    TKDT128DC_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT128DC_Source) - 1] of PKDT128DC_Source;
    PKDT128DC_SourceBuffer = ^TKDT128DC_SourceBuffer;

    TKDT128DC_DyanmicSourceBuffer = array of PKDT128DC_Source;
    PKDT128DC_DyanmicSourceBuffer = ^TKDT128DC_DyanmicSourceBuffer;

    TKDT128DC_DyanmicStoreBuffer = array of TKDT128DC_Source;
    PKDT128DC_DyanmicStoreBuffer = ^TKDT128DC_DyanmicStoreBuffer;

    PKDT128DC_Node = ^TKDT128DC_Node;

    TKDT128DC_Node = record
      Parent, Right, Left: PKDT128DC_Node;
      Vec: PKDT128DC_Source;
    end;

    TKDT128DC_BuildCall = procedure(const IndexFor: NativeInt; var Source: TKDT128DC_Source; const Data: Pointer);
    TKDT128DC_BuildMethod = procedure(const IndexFor: NativeInt; var Source: TKDT128DC_Source; const Data: Pointer) of object;
{$IFDEF FPC}
    TKDT128DC_BuildProc = procedure(const IndexFor: NativeInt; var Source: TKDT128DC_Source; const Data: Pointer) is nested;
{$ELSE FPC}
    TKDT128DC_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT128DC_Source; const Data: Pointer);
{$ENDIF FPC}
  private
    KDStoreBuff: TKDT128DC_DyanmicStoreBuffer;
    KDBuff: TKDT128DC_DyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes: array of PKDT128DC_Node;
    TestBuff: TKDT128DC_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT128DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT128DC_Node;
    function GetData(const Index: NativeInt): PKDT128DC_Source;
  public
    RootNode: PKDT128DC_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT128DC_DyanmicStoreBuffer;
    property SourceP[const Index: NativeInt]: PKDT128DC_Source read GetData; default;

    { bakcall build }
    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT128DC_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT128DC_BuildMethod);
    procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT128DC_BuildProc);
    { fill k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT128DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT128DC_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT128DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT128DC_BuildMethod); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT128DC_BuildProc); overload;
    { search }
    function Search(const buff: TKDT128DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT128DC_Node; overload;
    function Search(const buff: TKDT128DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT128DC_Node; overload;
    function Search(const buff: TKDT128DC_Vec; var SearchedDistanceMin: Double): PKDT128DC_Node; overload;
    function Search(const buff: TKDT128DC_Vec): PKDT128DC_Node; overload;
    function SearchToken(const buff: TKDT128DC_Vec): TPascalString;
    { parallel search }
    procedure Search(const inBuff: TKDT128DC_DynamicVecBuffer; var OutBuff: TKDT128DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;
    procedure Search(const inBuff: TKDT128DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);
    procedure SaveToFile(FileName: SystemString);
    procedure LoadFromFile(FileName: SystemString);
    procedure PrintNodeTree(const NodePtr: PKDT128DC_Node);
    procedure PrintBuffer;
    class function Vec(const s: SystemString): TKDT128DC_Vec; overload;
    class function Vec(const v: TKDT128DC_Vec): SystemString; overload;
    class function Distance(const v1, v2: TKDT128DC_Vec): Double;
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT128DC_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT156DC = class(TCoreClassObject)
  public type
    // code split
    TKDT156DC_Vec = array [0 .. KDT156DC_Axis - 1] of TKDT156DC_VecType;
    PKDT156DC_Vec = ^TKDT156DC_Vec;

    TKDT156DC_DynamicVecBuffer = array of TKDT156DC_Vec;
    PKDT156DC_DynamicVecBuffer = ^TKDT156DC_DynamicVecBuffer;

    TKDT156DC_Source = record
      buff: TKDT156DC_Vec;
      Index: Int64;
      Token: TPascalString;
    end;

    PKDT156DC_Source = ^TKDT156DC_Source;
    TKDT156DC_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT156DC_Source) - 1] of PKDT156DC_Source;
    PKDT156DC_SourceBuffer = ^TKDT156DC_SourceBuffer;

    TKDT156DC_DyanmicSourceBuffer = array of PKDT156DC_Source;
    PKDT156DC_DyanmicSourceBuffer = ^TKDT156DC_DyanmicSourceBuffer;

    TKDT156DC_DyanmicStoreBuffer = array of TKDT156DC_Source;
    PKDT156DC_DyanmicStoreBuffer = ^TKDT156DC_DyanmicStoreBuffer;

    PKDT156DC_Node = ^TKDT156DC_Node;

    TKDT156DC_Node = record
      Parent, Right, Left: PKDT156DC_Node;
      Vec: PKDT156DC_Source;
    end;

    TKDT156DC_BuildCall = procedure(const IndexFor: NativeInt; var Source: TKDT156DC_Source; const Data: Pointer);
    TKDT156DC_BuildMethod = procedure(const IndexFor: NativeInt; var Source: TKDT156DC_Source; const Data: Pointer) of object;
{$IFDEF FPC}
    TKDT156DC_BuildProc = procedure(const IndexFor: NativeInt; var Source: TKDT156DC_Source; const Data: Pointer) is nested;
{$ELSE FPC}
    TKDT156DC_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT156DC_Source; const Data: Pointer);
{$ENDIF FPC}
  private
    KDStoreBuff: TKDT156DC_DyanmicStoreBuffer;
    KDBuff: TKDT156DC_DyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes: array of PKDT156DC_Node;
    TestBuff: TKDT156DC_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT156DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT156DC_Node;
    function GetData(const Index: NativeInt): PKDT156DC_Source;
  public
    RootNode: PKDT156DC_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT156DC_DyanmicStoreBuffer;
    property SourceP[const Index: NativeInt]: PKDT156DC_Source read GetData; default;

    { bakcall build }
    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT156DC_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT156DC_BuildMethod);
    procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT156DC_BuildProc);
    { fill k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT156DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT156DC_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT156DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT156DC_BuildMethod); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT156DC_BuildProc); overload;
    { search }
    function Search(const buff: TKDT156DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT156DC_Node; overload;
    function Search(const buff: TKDT156DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT156DC_Node; overload;
    function Search(const buff: TKDT156DC_Vec; var SearchedDistanceMin: Double): PKDT156DC_Node; overload;
    function Search(const buff: TKDT156DC_Vec): PKDT156DC_Node; overload;
    function SearchToken(const buff: TKDT156DC_Vec): TPascalString;
    { parallel search }
    procedure Search(const inBuff: TKDT156DC_DynamicVecBuffer; var OutBuff: TKDT156DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;
    procedure Search(const inBuff: TKDT156DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);
    procedure SaveToFile(FileName: SystemString);
    procedure LoadFromFile(FileName: SystemString);
    procedure PrintNodeTree(const NodePtr: PKDT156DC_Node);
    procedure PrintBuffer;
    class function Vec(const s: SystemString): TKDT156DC_Vec; overload;
    class function Vec(const v: TKDT156DC_Vec): SystemString; overload;
    class function Distance(const v1, v2: TKDT156DC_Vec): Double;
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT156DC_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT192DC = class(TCoreClassObject)
  public type
    // code split
    TKDT192DC_Vec = array [0 .. KDT192DC_Axis - 1] of TKDT192DC_VecType;
    PKDT192DC_Vec = ^TKDT192DC_Vec;

    TKDT192DC_DynamicVecBuffer = array of TKDT192DC_Vec;
    PKDT192DC_DynamicVecBuffer = ^TKDT192DC_DynamicVecBuffer;

    TKDT192DC_Source = record
      buff: TKDT192DC_Vec;
      Index: Int64;
      Token: TPascalString;
    end;

    PKDT192DC_Source = ^TKDT192DC_Source;
    TKDT192DC_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT192DC_Source) - 1] of PKDT192DC_Source;
    PKDT192DC_SourceBuffer = ^TKDT192DC_SourceBuffer;

    TKDT192DC_DyanmicSourceBuffer = array of PKDT192DC_Source;
    PKDT192DC_DyanmicSourceBuffer = ^TKDT192DC_DyanmicSourceBuffer;

    TKDT192DC_DyanmicStoreBuffer = array of TKDT192DC_Source;
    PKDT192DC_DyanmicStoreBuffer = ^TKDT192DC_DyanmicStoreBuffer;

    PKDT192DC_Node = ^TKDT192DC_Node;

    TKDT192DC_Node = record
      Parent, Right, Left: PKDT192DC_Node;
      Vec: PKDT192DC_Source;
    end;

    TKDT192DC_BuildCall = procedure(const IndexFor: NativeInt; var Source: TKDT192DC_Source; const Data: Pointer);
    TKDT192DC_BuildMethod = procedure(const IndexFor: NativeInt; var Source: TKDT192DC_Source; const Data: Pointer) of object;
{$IFDEF FPC}
    TKDT192DC_BuildProc = procedure(const IndexFor: NativeInt; var Source: TKDT192DC_Source; const Data: Pointer) is nested;
{$ELSE FPC}
    TKDT192DC_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT192DC_Source; const Data: Pointer);
{$ENDIF FPC}
  private
    KDStoreBuff: TKDT192DC_DyanmicStoreBuffer;
    KDBuff: TKDT192DC_DyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes: array of PKDT192DC_Node;
    TestBuff: TKDT192DC_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT192DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT192DC_Node;
    function GetData(const Index: NativeInt): PKDT192DC_Source;
  public
    RootNode: PKDT192DC_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT192DC_DyanmicStoreBuffer;
    property SourceP[const Index: NativeInt]: PKDT192DC_Source read GetData; default;

    { bakcall build }
    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT192DC_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT192DC_BuildMethod);
    procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT192DC_BuildProc);
    { fill k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT192DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT192DC_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT192DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT192DC_BuildMethod); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT192DC_BuildProc); overload;
    { search }
    function Search(const buff: TKDT192DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT192DC_Node; overload;
    function Search(const buff: TKDT192DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT192DC_Node; overload;
    function Search(const buff: TKDT192DC_Vec; var SearchedDistanceMin: Double): PKDT192DC_Node; overload;
    function Search(const buff: TKDT192DC_Vec): PKDT192DC_Node; overload;
    function SearchToken(const buff: TKDT192DC_Vec): TPascalString;
    { parallel search }
    procedure Search(const inBuff: TKDT192DC_DynamicVecBuffer; var OutBuff: TKDT192DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;
    procedure Search(const inBuff: TKDT192DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);
    procedure SaveToFile(FileName: SystemString);
    procedure LoadFromFile(FileName: SystemString);
    procedure PrintNodeTree(const NodePtr: PKDT192DC_Node);
    procedure PrintBuffer;
    class function Vec(const s: SystemString): TKDT192DC_Vec; overload;
    class function Vec(const v: TKDT192DC_Vec): SystemString; overload;
    class function Distance(const v1, v2: TKDT192DC_Vec): Double;
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT192DC_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT256DC = class(TCoreClassObject)
  public type
    // code split
    TKDT256DC_Vec = array [0 .. KDT256DC_Axis - 1] of TKDT256DC_VecType;
    PKDT256DC_Vec = ^TKDT256DC_Vec;

    TKDT256DC_DynamicVecBuffer = array of TKDT256DC_Vec;
    PKDT256DC_DynamicVecBuffer = ^TKDT256DC_DynamicVecBuffer;

    TKDT256DC_Source = record
      buff: TKDT256DC_Vec;
      Index: Int64;
      Token: TPascalString;
    end;

    PKDT256DC_Source = ^TKDT256DC_Source;
    TKDT256DC_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT256DC_Source) - 1] of PKDT256DC_Source;
    PKDT256DC_SourceBuffer = ^TKDT256DC_SourceBuffer;

    TKDT256DC_DyanmicSourceBuffer = array of PKDT256DC_Source;
    PKDT256DC_DyanmicSourceBuffer = ^TKDT256DC_DyanmicSourceBuffer;

    TKDT256DC_DyanmicStoreBuffer = array of TKDT256DC_Source;
    PKDT256DC_DyanmicStoreBuffer = ^TKDT256DC_DyanmicStoreBuffer;

    PKDT256DC_Node = ^TKDT256DC_Node;

    TKDT256DC_Node = record
      Parent, Right, Left: PKDT256DC_Node;
      Vec: PKDT256DC_Source;
    end;

    TKDT256DC_BuildCall = procedure(const IndexFor: NativeInt; var Source: TKDT256DC_Source; const Data: Pointer);
    TKDT256DC_BuildMethod = procedure(const IndexFor: NativeInt; var Source: TKDT256DC_Source; const Data: Pointer) of object;
{$IFDEF FPC}
    TKDT256DC_BuildProc = procedure(const IndexFor: NativeInt; var Source: TKDT256DC_Source; const Data: Pointer) is nested;
{$ELSE FPC}
    TKDT256DC_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT256DC_Source; const Data: Pointer);
{$ENDIF FPC}
  private
    KDStoreBuff: TKDT256DC_DyanmicStoreBuffer;
    KDBuff: TKDT256DC_DyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes: array of PKDT256DC_Node;
    TestBuff: TKDT256DC_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT256DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT256DC_Node;
    function GetData(const Index: NativeInt): PKDT256DC_Source;
  public
    RootNode: PKDT256DC_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT256DC_DyanmicStoreBuffer;
    property SourceP[const Index: NativeInt]: PKDT256DC_Source read GetData; default;

    { bakcall build }
    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT256DC_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT256DC_BuildMethod);
    procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT256DC_BuildProc);
    { fill k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT256DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT256DC_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT256DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT256DC_BuildMethod); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT256DC_BuildProc); overload;
    { search }
    function Search(const buff: TKDT256DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT256DC_Node; overload;
    function Search(const buff: TKDT256DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT256DC_Node; overload;
    function Search(const buff: TKDT256DC_Vec; var SearchedDistanceMin: Double): PKDT256DC_Node; overload;
    function Search(const buff: TKDT256DC_Vec): PKDT256DC_Node; overload;
    function SearchToken(const buff: TKDT256DC_Vec): TPascalString;
    { parallel search }
    procedure Search(const inBuff: TKDT256DC_DynamicVecBuffer; var OutBuff: TKDT256DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;
    procedure Search(const inBuff: TKDT256DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);
    procedure SaveToFile(FileName: SystemString);
    procedure LoadFromFile(FileName: SystemString);
    procedure PrintNodeTree(const NodePtr: PKDT256DC_Node);
    procedure PrintBuffer;
    class function Vec(const s: SystemString): TKDT256DC_Vec; overload;
    class function Vec(const v: TKDT256DC_Vec): SystemString; overload;
    class function Distance(const v1, v2: TKDT256DC_Vec): Double;
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT256DC_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT384DC = class(TCoreClassObject)
  public type
    // code split
    TKDT384DC_Vec = array [0 .. KDT384DC_Axis - 1] of TKDT384DC_VecType;
    PKDT384DC_Vec = ^TKDT384DC_Vec;

    TKDT384DC_DynamicVecBuffer = array of TKDT384DC_Vec;
    PKDT384DC_DynamicVecBuffer = ^TKDT384DC_DynamicVecBuffer;

    TKDT384DC_Source = record
      buff: TKDT384DC_Vec;
      Index: Int64;
      Token: TPascalString;
    end;

    PKDT384DC_Source = ^TKDT384DC_Source;
    TKDT384DC_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT384DC_Source) - 1] of PKDT384DC_Source;
    PKDT384DC_SourceBuffer = ^TKDT384DC_SourceBuffer;

    TKDT384DC_DyanmicSourceBuffer = array of PKDT384DC_Source;
    PKDT384DC_DyanmicSourceBuffer = ^TKDT384DC_DyanmicSourceBuffer;

    TKDT384DC_DyanmicStoreBuffer = array of TKDT384DC_Source;
    PKDT384DC_DyanmicStoreBuffer = ^TKDT384DC_DyanmicStoreBuffer;

    PKDT384DC_Node = ^TKDT384DC_Node;

    TKDT384DC_Node = record
      Parent, Right, Left: PKDT384DC_Node;
      Vec: PKDT384DC_Source;
    end;

    TKDT384DC_BuildCall = procedure(const IndexFor: NativeInt; var Source: TKDT384DC_Source; const Data: Pointer);
    TKDT384DC_BuildMethod = procedure(const IndexFor: NativeInt; var Source: TKDT384DC_Source; const Data: Pointer) of object;
{$IFDEF FPC}
    TKDT384DC_BuildProc = procedure(const IndexFor: NativeInt; var Source: TKDT384DC_Source; const Data: Pointer) is nested;
{$ELSE FPC}
    TKDT384DC_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT384DC_Source; const Data: Pointer);
{$ENDIF FPC}
  private
    KDStoreBuff: TKDT384DC_DyanmicStoreBuffer;
    KDBuff: TKDT384DC_DyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes: array of PKDT384DC_Node;
    TestBuff: TKDT384DC_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT384DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT384DC_Node;
    function GetData(const Index: NativeInt): PKDT384DC_Source;
  public
    RootNode: PKDT384DC_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT384DC_DyanmicStoreBuffer;
    property SourceP[const Index: NativeInt]: PKDT384DC_Source read GetData; default;

    { bakcall build }
    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT384DC_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT384DC_BuildMethod);
    procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT384DC_BuildProc);
    { fill k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT384DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT384DC_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT384DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT384DC_BuildMethod); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT384DC_BuildProc); overload;
    { search }
    function Search(const buff: TKDT384DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT384DC_Node; overload;
    function Search(const buff: TKDT384DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT384DC_Node; overload;
    function Search(const buff: TKDT384DC_Vec; var SearchedDistanceMin: Double): PKDT384DC_Node; overload;
    function Search(const buff: TKDT384DC_Vec): PKDT384DC_Node; overload;
    function SearchToken(const buff: TKDT384DC_Vec): TPascalString;
    { parallel search }
    procedure Search(const inBuff: TKDT384DC_DynamicVecBuffer; var OutBuff: TKDT384DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;
    procedure Search(const inBuff: TKDT384DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);
    procedure SaveToFile(FileName: SystemString);
    procedure LoadFromFile(FileName: SystemString);
    procedure PrintNodeTree(const NodePtr: PKDT384DC_Node);
    procedure PrintBuffer;
    class function Vec(const s: SystemString): TKDT384DC_Vec; overload;
    class function Vec(const v: TKDT384DC_Vec): SystemString; overload;
    class function Distance(const v1, v2: TKDT384DC_Vec): Double;
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT384DC_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT512DC = class(TCoreClassObject)
  public type
    // code split
    TKDT512DC_Vec = array [0 .. KDT512DC_Axis - 1] of TKDT512DC_VecType;
    PKDT512DC_Vec = ^TKDT512DC_Vec;

    TKDT512DC_DynamicVecBuffer = array of TKDT512DC_Vec;
    PKDT512DC_DynamicVecBuffer = ^TKDT512DC_DynamicVecBuffer;

    TKDT512DC_Source = record
      buff: TKDT512DC_Vec;
      Index: Int64;
      Token: TPascalString;
    end;

    PKDT512DC_Source = ^TKDT512DC_Source;
    TKDT512DC_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT512DC_Source) - 1] of PKDT512DC_Source;
    PKDT512DC_SourceBuffer = ^TKDT512DC_SourceBuffer;

    TKDT512DC_DyanmicSourceBuffer = array of PKDT512DC_Source;
    PKDT512DC_DyanmicSourceBuffer = ^TKDT512DC_DyanmicSourceBuffer;

    TKDT512DC_DyanmicStoreBuffer = array of TKDT512DC_Source;
    PKDT512DC_DyanmicStoreBuffer = ^TKDT512DC_DyanmicStoreBuffer;

    PKDT512DC_Node = ^TKDT512DC_Node;

    TKDT512DC_Node = record
      Parent, Right, Left: PKDT512DC_Node;
      Vec: PKDT512DC_Source;
    end;

    TKDT512DC_BuildCall = procedure(const IndexFor: NativeInt; var Source: TKDT512DC_Source; const Data: Pointer);
    TKDT512DC_BuildMethod = procedure(const IndexFor: NativeInt; var Source: TKDT512DC_Source; const Data: Pointer) of object;
{$IFDEF FPC}
    TKDT512DC_BuildProc = procedure(const IndexFor: NativeInt; var Source: TKDT512DC_Source; const Data: Pointer) is nested;
{$ELSE FPC}
    TKDT512DC_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT512DC_Source; const Data: Pointer);
{$ENDIF FPC}
  private
    KDStoreBuff: TKDT512DC_DyanmicStoreBuffer;
    KDBuff: TKDT512DC_DyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes: array of PKDT512DC_Node;
    TestBuff: TKDT512DC_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT512DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT512DC_Node;
    function GetData(const Index: NativeInt): PKDT512DC_Source;
  public
    RootNode: PKDT512DC_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT512DC_DyanmicStoreBuffer;
    property SourceP[const Index: NativeInt]: PKDT512DC_Source read GetData; default;

    { bakcall build }
    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT512DC_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT512DC_BuildMethod);
    procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT512DC_BuildProc);
    { fill k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT512DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT512DC_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT512DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT512DC_BuildMethod); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT512DC_BuildProc); overload;
    { search }
    function Search(const buff: TKDT512DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT512DC_Node; overload;
    function Search(const buff: TKDT512DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT512DC_Node; overload;
    function Search(const buff: TKDT512DC_Vec; var SearchedDistanceMin: Double): PKDT512DC_Node; overload;
    function Search(const buff: TKDT512DC_Vec): PKDT512DC_Node; overload;
    function SearchToken(const buff: TKDT512DC_Vec): TPascalString;
    { parallel search }
    procedure Search(const inBuff: TKDT512DC_DynamicVecBuffer; var OutBuff: TKDT512DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;
    procedure Search(const inBuff: TKDT512DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);
    procedure SaveToFile(FileName: SystemString);
    procedure LoadFromFile(FileName: SystemString);
    procedure PrintNodeTree(const NodePtr: PKDT512DC_Node);
    procedure PrintBuffer;
    class function Vec(const s: SystemString): TKDT512DC_Vec; overload;
    class function Vec(const v: TKDT512DC_Vec): SystemString; overload;
    class function Distance(const v1, v2: TKDT512DC_Vec): Double;
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT512DC_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT800DC = class(TCoreClassObject)
  public type
    // code split
    TKDT800DC_Vec = array [0 .. KDT800DC_Axis - 1] of TKDT800DC_VecType;
    PKDT800DC_Vec = ^TKDT800DC_Vec;

    TKDT800DC_DynamicVecBuffer = array of TKDT800DC_Vec;
    PKDT800DC_DynamicVecBuffer = ^TKDT800DC_DynamicVecBuffer;

    TKDT800DC_Source = record
      buff: TKDT800DC_Vec;
      Index: Int64;
      Token: TPascalString;
    end;

    PKDT800DC_Source = ^TKDT800DC_Source;
    TKDT800DC_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT800DC_Source) - 1] of PKDT800DC_Source;
    PKDT800DC_SourceBuffer = ^TKDT800DC_SourceBuffer;

    TKDT800DC_DyanmicSourceBuffer = array of PKDT800DC_Source;
    PKDT800DC_DyanmicSourceBuffer = ^TKDT800DC_DyanmicSourceBuffer;

    TKDT800DC_DyanmicStoreBuffer = array of TKDT800DC_Source;
    PKDT800DC_DyanmicStoreBuffer = ^TKDT800DC_DyanmicStoreBuffer;

    PKDT800DC_Node = ^TKDT800DC_Node;

    TKDT800DC_Node = record
      Parent, Right, Left: PKDT800DC_Node;
      Vec: PKDT800DC_Source;
    end;

    TKDT800DC_BuildCall = procedure(const IndexFor: NativeInt; var Source: TKDT800DC_Source; const Data: Pointer);
    TKDT800DC_BuildMethod = procedure(const IndexFor: NativeInt; var Source: TKDT800DC_Source; const Data: Pointer) of object;
{$IFDEF FPC}
    TKDT800DC_BuildProc = procedure(const IndexFor: NativeInt; var Source: TKDT800DC_Source; const Data: Pointer) is nested;
{$ELSE FPC}
    TKDT800DC_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT800DC_Source; const Data: Pointer);
{$ENDIF FPC}
  private
    KDStoreBuff: TKDT800DC_DyanmicStoreBuffer;
    KDBuff: TKDT800DC_DyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes: array of PKDT800DC_Node;
    TestBuff: TKDT800DC_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT800DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT800DC_Node;
    function GetData(const Index: NativeInt): PKDT800DC_Source;
  public
    RootNode: PKDT800DC_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT800DC_DyanmicStoreBuffer;
    property SourceP[const Index: NativeInt]: PKDT800DC_Source read GetData; default;

    { bakcall build }
    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT800DC_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT800DC_BuildMethod);
    procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT800DC_BuildProc);
    { fill k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT800DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT800DC_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT800DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT800DC_BuildMethod); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT800DC_BuildProc); overload;
    { search }
    function Search(const buff: TKDT800DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT800DC_Node; overload;
    function Search(const buff: TKDT800DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT800DC_Node; overload;
    function Search(const buff: TKDT800DC_Vec; var SearchedDistanceMin: Double): PKDT800DC_Node; overload;
    function Search(const buff: TKDT800DC_Vec): PKDT800DC_Node; overload;
    function SearchToken(const buff: TKDT800DC_Vec): TPascalString;
    { parallel search }
    procedure Search(const inBuff: TKDT800DC_DynamicVecBuffer; var OutBuff: TKDT800DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;
    procedure Search(const inBuff: TKDT800DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);
    procedure SaveToFile(FileName: SystemString);
    procedure LoadFromFile(FileName: SystemString);
    procedure PrintNodeTree(const NodePtr: PKDT800DC_Node);
    procedure PrintBuffer;
    class function Vec(const s: SystemString): TKDT800DC_Vec; overload;
    class function Vec(const v: TKDT800DC_Vec): SystemString; overload;
    class function Distance(const v1, v2: TKDT800DC_Vec): Double;
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT800DC_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT1024DC = class(TCoreClassObject)
  public type
    // code split
    TKDT1024DC_Vec = array [0 .. KDT1024DC_Axis - 1] of TKDT1024DC_VecType;
    PKDT1024DC_Vec = ^TKDT1024DC_Vec;

    TKDT1024DC_DynamicVecBuffer = array of TKDT1024DC_Vec;
    PKDT1024DC_DynamicVecBuffer = ^TKDT1024DC_DynamicVecBuffer;

    TKDT1024DC_Source = record
      buff: TKDT1024DC_Vec;
      Index: Int64;
      Token: TPascalString;
    end;

    PKDT1024DC_Source = ^TKDT1024DC_Source;
    TKDT1024DC_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT1024DC_Source) - 1] of PKDT1024DC_Source;
    PKDT1024DC_SourceBuffer = ^TKDT1024DC_SourceBuffer;

    TKDT1024DC_DyanmicSourceBuffer = array of PKDT1024DC_Source;
    PKDT1024DC_DyanmicSourceBuffer = ^TKDT1024DC_DyanmicSourceBuffer;

    TKDT1024DC_DyanmicStoreBuffer = array of TKDT1024DC_Source;
    PKDT1024DC_DyanmicStoreBuffer = ^TKDT1024DC_DyanmicStoreBuffer;

    PKDT1024DC_Node = ^TKDT1024DC_Node;

    TKDT1024DC_Node = record
      Parent, Right, Left: PKDT1024DC_Node;
      Vec: PKDT1024DC_Source;
    end;

    TKDT1024DC_BuildCall = procedure(const IndexFor: NativeInt; var Source: TKDT1024DC_Source; const Data: Pointer);
    TKDT1024DC_BuildMethod = procedure(const IndexFor: NativeInt; var Source: TKDT1024DC_Source; const Data: Pointer) of object;
{$IFDEF FPC}
    TKDT1024DC_BuildProc = procedure(const IndexFor: NativeInt; var Source: TKDT1024DC_Source; const Data: Pointer) is nested;
{$ELSE FPC}
    TKDT1024DC_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT1024DC_Source; const Data: Pointer);
{$ENDIF FPC}
  private
    KDStoreBuff: TKDT1024DC_DyanmicStoreBuffer;
    KDBuff: TKDT1024DC_DyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes: array of PKDT1024DC_Node;
    TestBuff: TKDT1024DC_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT1024DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1024DC_Node;
    function GetData(const Index: NativeInt): PKDT1024DC_Source;
  public
    RootNode: PKDT1024DC_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT1024DC_DyanmicStoreBuffer;
    property SourceP[const Index: NativeInt]: PKDT1024DC_Source read GetData; default;

    { bakcall build }
    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1024DC_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1024DC_BuildMethod);
    procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1024DC_BuildProc);
    { fill k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1024DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1024DC_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT1024DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT1024DC_BuildMethod); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT1024DC_BuildProc); overload;
    { search }
    function Search(const buff: TKDT1024DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1024DC_Node; overload;
    function Search(const buff: TKDT1024DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1024DC_Node; overload;
    function Search(const buff: TKDT1024DC_Vec; var SearchedDistanceMin: Double): PKDT1024DC_Node; overload;
    function Search(const buff: TKDT1024DC_Vec): PKDT1024DC_Node; overload;
    function SearchToken(const buff: TKDT1024DC_Vec): TPascalString;
    { parallel search }
    procedure Search(const inBuff: TKDT1024DC_DynamicVecBuffer; var OutBuff: TKDT1024DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;
    procedure Search(const inBuff: TKDT1024DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);
    procedure SaveToFile(FileName: SystemString);
    procedure LoadFromFile(FileName: SystemString);
    procedure PrintNodeTree(const NodePtr: PKDT1024DC_Node);
    procedure PrintBuffer;
    class function Vec(const s: SystemString): TKDT1024DC_Vec; overload;
    class function Vec(const v: TKDT1024DC_Vec): SystemString; overload;
    class function Distance(const v1, v2: TKDT1024DC_Vec): Double;
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT1024DC_Source; const Data: Pointer);
    class procedure Test;
  end;






procedure Test_All;



implementation

uses
  TextParsing, MemoryStream64, DoStatusIO;





const
  SaveToken = $44;


function TKDT1DC.InternalBuildKdTree(const KDSourceBufferPtr: PKDT1DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1DC_Node;
  function SortCompare(const p1, p2: PKDT1DC_Source; const axis: NativeInt): ShortInt;
  begin
    if p1^.buff[axis] = p2^.buff[axis] then
      begin
        if p1^.Index = p2^.Index then
            Result := 0
        else if p1^.Index < p2^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.buff[axis] < p2^.buff[axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT1DC_SourceBuffer; L, R: NativeInt; const axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT1DC_Source;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer^[(L + R) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, axis) < 0 do
            Inc(i);
        while SortCompare(SortBuffer^[j], p, axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, axis);
      L := i;
    until i >= R;
  end;

var
  M: NativeInt;
  axis: NativeInt;
  kdBuffPtr: PKDT1DC_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      new(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.Vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);
    end
  else
    begin
      axis := Depth mod KDT1DC_Axis;
      M := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr^[0], 0, PlanCount - 1, axis);

      new(Result);
      Result^.Parent := nil;
      Result^.Vec := kdBuffPtr^[M];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], M, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[M + 1], PlanCount - (M + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT1DC.GetData(const Index: NativeInt): PKDT1DC_Source;
begin
  Result := @KDStoreBuff[Index];
end;

constructor TKDT1DC.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT1DC.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT1DC.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT1DC_Node(KDNodes[i]));
      Inc(i);
    end;

  for i := 0 to length(KDStoreBuff) - 1 do
      KDStoreBuff[i].Token := '';

  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT1DC.StoreBuffPtr: PKDT1DC_DyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT1DC.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1DC_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT1DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT1DC.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1DC_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT1DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT1DC.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1DC_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT1DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{ k-means++ clusterization }
procedure TKDT1DC.BuildKDTreeWithCluster(const inBuff: TKDT1DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  SetLength(Source, length(inBuff), KDT1DC_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT1DC_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT1DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT1DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT1DC.BuildKDTreeWithCluster(const inBuff: TKDT1DC_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TKMIntegerArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT1DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT1DC_BuildCall);
var
  TempStoreBuff: TKDT1DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT1DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT1DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT1DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT1DC_BuildMethod);
var
  TempStoreBuff: TKDT1DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT1DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT1DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT1DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT1DC_BuildProc);
var
  TempStoreBuff: TKDT1DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT1DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT1DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT1DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

function TKDT1DC.Search(const buff: TKDT1DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1DC_Node;

var
  NearestNeighbour: PKDT1DC_Node;

  function FindParentNode(const buffPtr: PKDT1DC_Vec; NodePtr: PKDT1DC_Node): PKDT1DC_Node;
  var
    Next: PKDT1DC_Node;
    Depth, axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        axis := Depth mod KDT1DC_Axis;
        if buffPtr^[axis] > Next^.Vec^.buff[axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT1DC_Node; const buffPtr: PKDT1DC_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    Inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := Distance(buffPtr^, NodePtr^.Vec^.buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.Vec^.Index < NearestNeighbour^.Vec^.Index) then
        NearestNeighbour := NodePtr;

    axis := Depth mod KDT1DC_Axis;
    Dist := NodePtr^.Vec^.buff[axis] - buffPtr^[axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.Vec^.buff[axis] > buffPtr^[axis] then
            ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const buffPtr: PKDT1DC_Vec; const p1, p2: PKDT1DC_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := Distance(buffPtr^, p1^.Vec^.buff);
    d2 := Distance(buffPtr^, p2^.Vec^.buff);
    if d1 = d2 then
      begin
        if p1^.Vec^.Index = p2^.Vec^.Index then
            Result := 0
        else if p1^.Vec^.Index < p2^.Vec^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; L, R: NativeInt; const buffPtr: PKDT1DC_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT1DC_Node;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer[(L + R) shr 1];
      repeat
        while SortCompare(buffPtr, SortBuffer[i], p) < 0 do
            Inc(i);
        while SortCompare(buffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, buffPtr);
      L := i;
    until i >= R;
  end;

var
  Parent: PKDT1DC_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := Distance(buff, Parent^.Vec^.buff);

  ScanSubtree(RootNode, @buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT1DC_Node(NearestNodes[0]);
    end;
end;

function TKDT1DC.Search(const buff: TKDT1DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1DC_Node;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT1DC.Search(const buff: TKDT1DC_Vec; var SearchedDistanceMin: Double): PKDT1DC_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT1DC.Search(const buff: TKDT1DC_Vec): PKDT1DC_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT1DC.SearchToken(const buff: TKDT1DC_Vec): TPascalString;
var
  p: PKDT1DC_Node;
begin
  p := Search(buff);
  if p <> nil then
      Result := p^.Vec^.Token
  else
      Result := '';
end;

procedure TKDT1DC.Search(const inBuff: TKDT1DC_DynamicVecBuffer; var OutBuff: TKDT1DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT1DC_DynamicVecBuffer;
  outBuffPtr: PKDT1DC_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT1DC_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outBuffPtr^[pass] := p^.Vec^.buff;
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT1DC_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outBuffPtr^[pass] := p^.Vec^.buff;
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1DC_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.Vec^.buff;
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1DC.Search(const inBuff: TKDT1DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT1DC_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT1DC_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT1DC_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1DC_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1DC.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  ID := KDT1DC_Axis;

  stream.write(st, 4);
  stream.write(ID, 4);

  stream.write(cnt, 8);

  i := 0;
  while i < cnt do
    begin
      stream.write(KDStoreBuff[i].buff[0], SizeOf(TKDT1DC_Vec));
      stream.write(KDStoreBuff[i].Index, 8);
      token_B := KDStoreBuff[i].Token.Bytes;
      token_L := length(token_B);
      stream.write(token_L, 4);
      if token_L > 0 then
        begin
          stream.write(token_B[0], token_L);
          SetLength(token_B, 0);
        end;
      Inc(i);
    end;
end;

procedure TKDT1DC.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  Clear;

  stream.read(st, 4);
  stream.read(ID, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if ID <> KDT1DC_Axis then
      RaiseInfo('kdtree axis error!');

  stream.read(cnt, 8);

  SetLength(KDStoreBuff, cnt);

  i := 0;
  try
    while i < cnt do
      begin
        if stream.read(KDStoreBuff[i].buff[0], SizeOf(TKDT1DC_Vec)) <> SizeOf(TKDT1DC_Vec) then
          begin
            Clear;
            Exit;
          end;
        if stream.read(KDStoreBuff[i].Index, 8) <> 8 then
          begin
            Clear;
            Exit;
          end;
        if stream.read(token_L, 4) <> 4 then
          begin
            Clear;
            Exit;
          end;
        if token_L > 0 then
          begin
            SetLength(token_B, token_L);
            if stream.read(token_B[0], token_L) <> token_L then
              begin
                Clear;
                Exit;
              end;
            KDStoreBuff[i].Token.Bytes := token_B;
            SetLength(token_B, 0);
          end
        else
            KDStoreBuff[i].Token := '';
        Inc(i);
      end;
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      Inc(i);
    end;

  if cnt > 0 then
      RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT1DC.SaveToFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(FileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1DC.LoadFromFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1DC.PrintNodeTree(const NodePtr: PKDT1DC_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT1DC_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.Vec^.Index, Vec(p^.Vec^.buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT1DC.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d - %d : %s ', [i, KDStoreBuff[i].Index, Vec(KDStoreBuff[i].buff)]);
end;

class function TKDT1DC.Vec(const s: SystemString): TKDT1DC_Vec;
var
  t: TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j: NativeInt;
begin
  for i := 0 to KDT1DC_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            Inc(j);
            if j >= KDT1DC_Axis then
                Break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT1DC.Vec(const v: TKDT1DC_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT1DC_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT1DC.Distance(const v1, v2: TKDT1DC_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT1DC_Axis - 1 do
      Result := Result + (v2[i] - v1[i]) * (v2[i] - v1[i]);
end;

procedure TKDT1DC.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT1DC_Source; const Data: Pointer);
begin
  Source.buff := TestBuff[IndexFor];
  Source.Token := umlIntToStr(IndexFor);
end;

class procedure TKDT1DC.Test;
var
  TKDT1DC_Test: TKDT1DC;
  t: TTimeTick;
  i, j: NativeInt;
  TestResultBuff: TKDT1DC_DynamicVecBuffer;
  TestResultIndex: TKMIntegerArray;
  KMeanOutIndex: TKMIntegerArray;
  errored: Boolean;
  m64: TMemoryStream64;
  p: PKDT1DC_Node;
  n: TPascalString;
begin
  errored := False;
  n := PFormat('test %s...', [ClassName]);
  t := GetTimeTick;

  n.Append('...build');
  TKDT1DC_Test := TKDT1DC.Create;

  n.Append('...');
  SetLength(TKDT1DC_Test.TestBuff, 1000);
  for i := 0 to length(TKDT1DC_Test.TestBuff) - 1 do
    for j := 0 to KDT1DC_Axis - 1 do
        TKDT1DC_Test.TestBuff[i][j] := i * KDT1DC_Axis + j;

{$IFDEF FPC}
  TKDT1DC_Test.BuildKDTreeM(length(TKDT1DC_Test.TestBuff), nil, @TKDT1DC_Test.Test_BuildM);
{$ELSE FPC}
  TKDT1DC_Test.BuildKDTreeM(length(TKDT1DC_Test.TestBuff), nil, TKDT1DC_Test.Test_BuildM);
{$ENDIF FPC}
  { save/load test }
  n.Append('...save/load');
  m64 := TMemoryStream64.CustomCreate(1024 * 1024);
  TKDT1DC_Test.SaveToStream(m64);
  m64.Position := 0;
  TKDT1DC_Test.LoadFromStream(m64);
  for i := 0 to length(TKDT1DC_Test.TestBuff) - 1 do
    begin
      p := TKDT1DC_Test.Search(TKDT1DC_Test.TestBuff[i]);
      if p^.Vec^.Index <> i then
          errored := True;
      if not p^.Vec^.Token.Same(umlIntToStr(i)) then
          errored := True;
      if errored then
          Break;
    end;
  DisposeObject(m64);

  if not errored then
    begin
      { parallel search test }
      n.Append('...parallel');
      SetLength(TestResultBuff, length(TKDT1DC_Test.TestBuff));
      SetLength(TestResultIndex, length(TKDT1DC_Test.TestBuff));
      TKDT1DC_Test.Search(TKDT1DC_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if Distance(TKDT1DC_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
            errored := True;
    end;

  if not errored then
    begin
      n.Append('...kMean');
      TKDT1DC_Test.Clear;
      { kMean test }
      TKDT1DC_Test.BuildKDTreeWithCluster(TKDT1DC_Test.TestBuff, 10, 1, KMeanOutIndex);
      { parallel search test }
      TKDT1DC_Test.Search(TKDT1DC_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if TestResultIndex[i] <> KMeanOutIndex[i] then
            errored := True;
    end;

  SetLength(TKDT1DC_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT1DC_Test.Clear;

  n.Append('...');
  if errored then
      n.Append('error!')
  else
      n.Append('passed ok %dms', [GetTimeTick - t]);
  DisposeObject(TKDT1DC_Test);
  DoStatus(n);
  n := '';
end;

function TKDT2DC.InternalBuildKdTree(const KDSourceBufferPtr: PKDT2DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT2DC_Node;
  function SortCompare(const p1, p2: PKDT2DC_Source; const axis: NativeInt): ShortInt;
  begin
    if p1^.buff[axis] = p2^.buff[axis] then
      begin
        if p1^.Index = p2^.Index then
            Result := 0
        else if p1^.Index < p2^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.buff[axis] < p2^.buff[axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT2DC_SourceBuffer; L, R: NativeInt; const axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT2DC_Source;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer^[(L + R) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, axis) < 0 do
            Inc(i);
        while SortCompare(SortBuffer^[j], p, axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, axis);
      L := i;
    until i >= R;
  end;

var
  M: NativeInt;
  axis: NativeInt;
  kdBuffPtr: PKDT2DC_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      new(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.Vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);
    end
  else
    begin
      axis := Depth mod KDT2DC_Axis;
      M := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr^[0], 0, PlanCount - 1, axis);

      new(Result);
      Result^.Parent := nil;
      Result^.Vec := kdBuffPtr^[M];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], M, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[M + 1], PlanCount - (M + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT2DC.GetData(const Index: NativeInt): PKDT2DC_Source;
begin
  Result := @KDStoreBuff[Index];
end;

constructor TKDT2DC.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT2DC.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT2DC.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT2DC_Node(KDNodes[i]));
      Inc(i);
    end;

  for i := 0 to length(KDStoreBuff) - 1 do
      KDStoreBuff[i].Token := '';

  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT2DC.StoreBuffPtr: PKDT2DC_DyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT2DC.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT2DC_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT2DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT2DC.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT2DC_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT2DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT2DC.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT2DC_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT2DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{ k-means++ clusterization }
procedure TKDT2DC.BuildKDTreeWithCluster(const inBuff: TKDT2DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  SetLength(Source, length(inBuff), KDT2DC_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT2DC_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT2DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT2DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT2DC.BuildKDTreeWithCluster(const inBuff: TKDT2DC_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TKMIntegerArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT2DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT2DC_BuildCall);
var
  TempStoreBuff: TKDT2DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT2DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT2DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT2DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT2DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT2DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT2DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT2DC_BuildMethod);
var
  TempStoreBuff: TKDT2DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT2DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT2DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT2DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT2DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT2DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT2DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT2DC_BuildProc);
var
  TempStoreBuff: TKDT2DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT2DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT2DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT2DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT2DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT2DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

function TKDT2DC.Search(const buff: TKDT2DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT2DC_Node;

var
  NearestNeighbour: PKDT2DC_Node;

  function FindParentNode(const buffPtr: PKDT2DC_Vec; NodePtr: PKDT2DC_Node): PKDT2DC_Node;
  var
    Next: PKDT2DC_Node;
    Depth, axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        axis := Depth mod KDT2DC_Axis;
        if buffPtr^[axis] > Next^.Vec^.buff[axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT2DC_Node; const buffPtr: PKDT2DC_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    Inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := Distance(buffPtr^, NodePtr^.Vec^.buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.Vec^.Index < NearestNeighbour^.Vec^.Index) then
        NearestNeighbour := NodePtr;

    axis := Depth mod KDT2DC_Axis;
    Dist := NodePtr^.Vec^.buff[axis] - buffPtr^[axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.Vec^.buff[axis] > buffPtr^[axis] then
            ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const buffPtr: PKDT2DC_Vec; const p1, p2: PKDT2DC_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := Distance(buffPtr^, p1^.Vec^.buff);
    d2 := Distance(buffPtr^, p2^.Vec^.buff);
    if d1 = d2 then
      begin
        if p1^.Vec^.Index = p2^.Vec^.Index then
            Result := 0
        else if p1^.Vec^.Index < p2^.Vec^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; L, R: NativeInt; const buffPtr: PKDT2DC_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT2DC_Node;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer[(L + R) shr 1];
      repeat
        while SortCompare(buffPtr, SortBuffer[i], p) < 0 do
            Inc(i);
        while SortCompare(buffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, buffPtr);
      L := i;
    until i >= R;
  end;

var
  Parent: PKDT2DC_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := Distance(buff, Parent^.Vec^.buff);

  ScanSubtree(RootNode, @buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT2DC_Node(NearestNodes[0]);
    end;
end;

function TKDT2DC.Search(const buff: TKDT2DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT2DC_Node;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT2DC.Search(const buff: TKDT2DC_Vec; var SearchedDistanceMin: Double): PKDT2DC_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT2DC.Search(const buff: TKDT2DC_Vec): PKDT2DC_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT2DC.SearchToken(const buff: TKDT2DC_Vec): TPascalString;
var
  p: PKDT2DC_Node;
begin
  p := Search(buff);
  if p <> nil then
      Result := p^.Vec^.Token
  else
      Result := '';
end;

procedure TKDT2DC.Search(const inBuff: TKDT2DC_DynamicVecBuffer; var OutBuff: TKDT2DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT2DC_DynamicVecBuffer;
  outBuffPtr: PKDT2DC_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT2DC_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outBuffPtr^[pass] := p^.Vec^.buff;
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT2DC_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outBuffPtr^[pass] := p^.Vec^.buff;
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT2DC_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.Vec^.buff;
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT2DC.Search(const inBuff: TKDT2DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT2DC_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT2DC_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT2DC_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT2DC_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT2DC.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  ID := KDT2DC_Axis;

  stream.write(st, 4);
  stream.write(ID, 4);

  stream.write(cnt, 8);

  i := 0;
  while i < cnt do
    begin
      stream.write(KDStoreBuff[i].buff[0], SizeOf(TKDT2DC_Vec));
      stream.write(KDStoreBuff[i].Index, 8);
      token_B := KDStoreBuff[i].Token.Bytes;
      token_L := length(token_B);
      stream.write(token_L, 4);
      if token_L > 0 then
        begin
          stream.write(token_B[0], token_L);
          SetLength(token_B, 0);
        end;
      Inc(i);
    end;
end;

procedure TKDT2DC.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  Clear;

  stream.read(st, 4);
  stream.read(ID, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if ID <> KDT2DC_Axis then
      RaiseInfo('kdtree axis error!');

  stream.read(cnt, 8);

  SetLength(KDStoreBuff, cnt);

  i := 0;
  try
    while i < cnt do
      begin
        if stream.read(KDStoreBuff[i].buff[0], SizeOf(TKDT2DC_Vec)) <> SizeOf(TKDT2DC_Vec) then
          begin
            Clear;
            Exit;
          end;
        if stream.read(KDStoreBuff[i].Index, 8) <> 8 then
          begin
            Clear;
            Exit;
          end;
        if stream.read(token_L, 4) <> 4 then
          begin
            Clear;
            Exit;
          end;
        if token_L > 0 then
          begin
            SetLength(token_B, token_L);
            if stream.read(token_B[0], token_L) <> token_L then
              begin
                Clear;
                Exit;
              end;
            KDStoreBuff[i].Token.Bytes := token_B;
            SetLength(token_B, 0);
          end
        else
            KDStoreBuff[i].Token := '';
        Inc(i);
      end;
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      Inc(i);
    end;

  if cnt > 0 then
      RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT2DC.SaveToFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(FileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT2DC.LoadFromFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT2DC.PrintNodeTree(const NodePtr: PKDT2DC_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT2DC_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.Vec^.Index, Vec(p^.Vec^.buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT2DC.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d - %d : %s ', [i, KDStoreBuff[i].Index, Vec(KDStoreBuff[i].buff)]);
end;

class function TKDT2DC.Vec(const s: SystemString): TKDT2DC_Vec;
var
  t: TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j: NativeInt;
begin
  for i := 0 to KDT2DC_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            Inc(j);
            if j >= KDT2DC_Axis then
                Break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT2DC.Vec(const v: TKDT2DC_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT2DC_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT2DC.Distance(const v1, v2: TKDT2DC_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT2DC_Axis - 1 do
      Result := Result + (v2[i] - v1[i]) * (v2[i] - v1[i]);
end;

procedure TKDT2DC.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT2DC_Source; const Data: Pointer);
begin
  Source.buff := TestBuff[IndexFor];
  Source.Token := umlIntToStr(IndexFor);
end;

class procedure TKDT2DC.Test;
var
  TKDT2DC_Test: TKDT2DC;
  t: TTimeTick;
  i, j: NativeInt;
  TestResultBuff: TKDT2DC_DynamicVecBuffer;
  TestResultIndex: TKMIntegerArray;
  KMeanOutIndex: TKMIntegerArray;
  errored: Boolean;
  m64: TMemoryStream64;
  p: PKDT2DC_Node;
  n: TPascalString;
begin
  errored := False;
  n := PFormat('test %s...', [ClassName]);
  t := GetTimeTick;

  n.Append('...build');
  TKDT2DC_Test := TKDT2DC.Create;

  n.Append('...');
  SetLength(TKDT2DC_Test.TestBuff, 1000);
  for i := 0 to length(TKDT2DC_Test.TestBuff) - 1 do
    for j := 0 to KDT2DC_Axis - 1 do
        TKDT2DC_Test.TestBuff[i][j] := i * KDT2DC_Axis + j;

{$IFDEF FPC}
  TKDT2DC_Test.BuildKDTreeM(length(TKDT2DC_Test.TestBuff), nil, @TKDT2DC_Test.Test_BuildM);
{$ELSE FPC}
  TKDT2DC_Test.BuildKDTreeM(length(TKDT2DC_Test.TestBuff), nil, TKDT2DC_Test.Test_BuildM);
{$ENDIF FPC}
  { save/load test }
  n.Append('...save/load');
  m64 := TMemoryStream64.CustomCreate(1024 * 1024);
  TKDT2DC_Test.SaveToStream(m64);
  m64.Position := 0;
  TKDT2DC_Test.LoadFromStream(m64);
  for i := 0 to length(TKDT2DC_Test.TestBuff) - 1 do
    begin
      p := TKDT2DC_Test.Search(TKDT2DC_Test.TestBuff[i]);
      if p^.Vec^.Index <> i then
          errored := True;
      if not p^.Vec^.Token.Same(umlIntToStr(i)) then
          errored := True;
      if errored then
          Break;
    end;
  DisposeObject(m64);

  if not errored then
    begin
      { parallel search test }
      n.Append('...parallel');
      SetLength(TestResultBuff, length(TKDT2DC_Test.TestBuff));
      SetLength(TestResultIndex, length(TKDT2DC_Test.TestBuff));
      TKDT2DC_Test.Search(TKDT2DC_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if Distance(TKDT2DC_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
            errored := True;
    end;

  if not errored then
    begin
      n.Append('...kMean');
      TKDT2DC_Test.Clear;
      { kMean test }
      TKDT2DC_Test.BuildKDTreeWithCluster(TKDT2DC_Test.TestBuff, 10, 1, KMeanOutIndex);
      { parallel search test }
      TKDT2DC_Test.Search(TKDT2DC_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if TestResultIndex[i] <> KMeanOutIndex[i] then
            errored := True;
    end;

  SetLength(TKDT2DC_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT2DC_Test.Clear;

  n.Append('...');
  if errored then
      n.Append('error!')
  else
      n.Append('passed ok %dms', [GetTimeTick - t]);
  DisposeObject(TKDT2DC_Test);
  DoStatus(n);
  n := '';
end;

function TKDT3DC.InternalBuildKdTree(const KDSourceBufferPtr: PKDT3DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT3DC_Node;
  function SortCompare(const p1, p2: PKDT3DC_Source; const axis: NativeInt): ShortInt;
  begin
    if p1^.buff[axis] = p2^.buff[axis] then
      begin
        if p1^.Index = p2^.Index then
            Result := 0
        else if p1^.Index < p2^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.buff[axis] < p2^.buff[axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT3DC_SourceBuffer; L, R: NativeInt; const axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT3DC_Source;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer^[(L + R) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, axis) < 0 do
            Inc(i);
        while SortCompare(SortBuffer^[j], p, axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, axis);
      L := i;
    until i >= R;
  end;

var
  M: NativeInt;
  axis: NativeInt;
  kdBuffPtr: PKDT3DC_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      new(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.Vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);
    end
  else
    begin
      axis := Depth mod KDT3DC_Axis;
      M := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr^[0], 0, PlanCount - 1, axis);

      new(Result);
      Result^.Parent := nil;
      Result^.Vec := kdBuffPtr^[M];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], M, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[M + 1], PlanCount - (M + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT3DC.GetData(const Index: NativeInt): PKDT3DC_Source;
begin
  Result := @KDStoreBuff[Index];
end;

constructor TKDT3DC.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT3DC.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT3DC.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT3DC_Node(KDNodes[i]));
      Inc(i);
    end;

  for i := 0 to length(KDStoreBuff) - 1 do
      KDStoreBuff[i].Token := '';

  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT3DC.StoreBuffPtr: PKDT3DC_DyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT3DC.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3DC_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT3DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT3DC.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3DC_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT3DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT3DC.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3DC_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT3DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{ k-means++ clusterization }
procedure TKDT3DC.BuildKDTreeWithCluster(const inBuff: TKDT3DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  SetLength(Source, length(inBuff), KDT3DC_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT3DC_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT3DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT3DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT3DC.BuildKDTreeWithCluster(const inBuff: TKDT3DC_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TKMIntegerArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT3DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT3DC_BuildCall);
var
  TempStoreBuff: TKDT3DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT3DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT3DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT3DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT3DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT3DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT3DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT3DC_BuildMethod);
var
  TempStoreBuff: TKDT3DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT3DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT3DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT3DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT3DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT3DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT3DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT3DC_BuildProc);
var
  TempStoreBuff: TKDT3DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT3DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT3DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT3DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT3DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT3DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

function TKDT3DC.Search(const buff: TKDT3DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT3DC_Node;

var
  NearestNeighbour: PKDT3DC_Node;

  function FindParentNode(const buffPtr: PKDT3DC_Vec; NodePtr: PKDT3DC_Node): PKDT3DC_Node;
  var
    Next: PKDT3DC_Node;
    Depth, axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        axis := Depth mod KDT3DC_Axis;
        if buffPtr^[axis] > Next^.Vec^.buff[axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT3DC_Node; const buffPtr: PKDT3DC_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    Inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := Distance(buffPtr^, NodePtr^.Vec^.buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.Vec^.Index < NearestNeighbour^.Vec^.Index) then
        NearestNeighbour := NodePtr;

    axis := Depth mod KDT3DC_Axis;
    Dist := NodePtr^.Vec^.buff[axis] - buffPtr^[axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.Vec^.buff[axis] > buffPtr^[axis] then
            ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const buffPtr: PKDT3DC_Vec; const p1, p2: PKDT3DC_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := Distance(buffPtr^, p1^.Vec^.buff);
    d2 := Distance(buffPtr^, p2^.Vec^.buff);
    if d1 = d2 then
      begin
        if p1^.Vec^.Index = p2^.Vec^.Index then
            Result := 0
        else if p1^.Vec^.Index < p2^.Vec^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; L, R: NativeInt; const buffPtr: PKDT3DC_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT3DC_Node;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer[(L + R) shr 1];
      repeat
        while SortCompare(buffPtr, SortBuffer[i], p) < 0 do
            Inc(i);
        while SortCompare(buffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, buffPtr);
      L := i;
    until i >= R;
  end;

var
  Parent: PKDT3DC_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := Distance(buff, Parent^.Vec^.buff);

  ScanSubtree(RootNode, @buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT3DC_Node(NearestNodes[0]);
    end;
end;

function TKDT3DC.Search(const buff: TKDT3DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT3DC_Node;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT3DC.Search(const buff: TKDT3DC_Vec; var SearchedDistanceMin: Double): PKDT3DC_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT3DC.Search(const buff: TKDT3DC_Vec): PKDT3DC_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT3DC.SearchToken(const buff: TKDT3DC_Vec): TPascalString;
var
  p: PKDT3DC_Node;
begin
  p := Search(buff);
  if p <> nil then
      Result := p^.Vec^.Token
  else
      Result := '';
end;

procedure TKDT3DC.Search(const inBuff: TKDT3DC_DynamicVecBuffer; var OutBuff: TKDT3DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT3DC_DynamicVecBuffer;
  outBuffPtr: PKDT3DC_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT3DC_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outBuffPtr^[pass] := p^.Vec^.buff;
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT3DC_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outBuffPtr^[pass] := p^.Vec^.buff;
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT3DC_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.Vec^.buff;
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT3DC.Search(const inBuff: TKDT3DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT3DC_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT3DC_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT3DC_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT3DC_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT3DC.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  ID := KDT3DC_Axis;

  stream.write(st, 4);
  stream.write(ID, 4);

  stream.write(cnt, 8);

  i := 0;
  while i < cnt do
    begin
      stream.write(KDStoreBuff[i].buff[0], SizeOf(TKDT3DC_Vec));
      stream.write(KDStoreBuff[i].Index, 8);
      token_B := KDStoreBuff[i].Token.Bytes;
      token_L := length(token_B);
      stream.write(token_L, 4);
      if token_L > 0 then
        begin
          stream.write(token_B[0], token_L);
          SetLength(token_B, 0);
        end;
      Inc(i);
    end;
end;

procedure TKDT3DC.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  Clear;

  stream.read(st, 4);
  stream.read(ID, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if ID <> KDT3DC_Axis then
      RaiseInfo('kdtree axis error!');

  stream.read(cnt, 8);

  SetLength(KDStoreBuff, cnt);

  i := 0;
  try
    while i < cnt do
      begin
        if stream.read(KDStoreBuff[i].buff[0], SizeOf(TKDT3DC_Vec)) <> SizeOf(TKDT3DC_Vec) then
          begin
            Clear;
            Exit;
          end;
        if stream.read(KDStoreBuff[i].Index, 8) <> 8 then
          begin
            Clear;
            Exit;
          end;
        if stream.read(token_L, 4) <> 4 then
          begin
            Clear;
            Exit;
          end;
        if token_L > 0 then
          begin
            SetLength(token_B, token_L);
            if stream.read(token_B[0], token_L) <> token_L then
              begin
                Clear;
                Exit;
              end;
            KDStoreBuff[i].Token.Bytes := token_B;
            SetLength(token_B, 0);
          end
        else
            KDStoreBuff[i].Token := '';
        Inc(i);
      end;
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      Inc(i);
    end;

  if cnt > 0 then
      RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT3DC.SaveToFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(FileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT3DC.LoadFromFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT3DC.PrintNodeTree(const NodePtr: PKDT3DC_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT3DC_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.Vec^.Index, Vec(p^.Vec^.buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT3DC.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d - %d : %s ', [i, KDStoreBuff[i].Index, Vec(KDStoreBuff[i].buff)]);
end;

class function TKDT3DC.Vec(const s: SystemString): TKDT3DC_Vec;
var
  t: TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j: NativeInt;
begin
  for i := 0 to KDT3DC_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            Inc(j);
            if j >= KDT3DC_Axis then
                Break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT3DC.Vec(const v: TKDT3DC_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT3DC_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT3DC.Distance(const v1, v2: TKDT3DC_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT3DC_Axis - 1 do
      Result := Result + (v2[i] - v1[i]) * (v2[i] - v1[i]);
end;

procedure TKDT3DC.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT3DC_Source; const Data: Pointer);
begin
  Source.buff := TestBuff[IndexFor];
  Source.Token := umlIntToStr(IndexFor);
end;

class procedure TKDT3DC.Test;
var
  TKDT3DC_Test: TKDT3DC;
  t: TTimeTick;
  i, j: NativeInt;
  TestResultBuff: TKDT3DC_DynamicVecBuffer;
  TestResultIndex: TKMIntegerArray;
  KMeanOutIndex: TKMIntegerArray;
  errored: Boolean;
  m64: TMemoryStream64;
  p: PKDT3DC_Node;
  n: TPascalString;
begin
  errored := False;
  n := PFormat('test %s...', [ClassName]);
  t := GetTimeTick;

  n.Append('...build');
  TKDT3DC_Test := TKDT3DC.Create;

  n.Append('...');
  SetLength(TKDT3DC_Test.TestBuff, 1000);
  for i := 0 to length(TKDT3DC_Test.TestBuff) - 1 do
    for j := 0 to KDT3DC_Axis - 1 do
        TKDT3DC_Test.TestBuff[i][j] := i * KDT3DC_Axis + j;

{$IFDEF FPC}
  TKDT3DC_Test.BuildKDTreeM(length(TKDT3DC_Test.TestBuff), nil, @TKDT3DC_Test.Test_BuildM);
{$ELSE FPC}
  TKDT3DC_Test.BuildKDTreeM(length(TKDT3DC_Test.TestBuff), nil, TKDT3DC_Test.Test_BuildM);
{$ENDIF FPC}
  { save/load test }
  n.Append('...save/load');
  m64 := TMemoryStream64.CustomCreate(1024 * 1024);
  TKDT3DC_Test.SaveToStream(m64);
  m64.Position := 0;
  TKDT3DC_Test.LoadFromStream(m64);
  for i := 0 to length(TKDT3DC_Test.TestBuff) - 1 do
    begin
      p := TKDT3DC_Test.Search(TKDT3DC_Test.TestBuff[i]);
      if p^.Vec^.Index <> i then
          errored := True;
      if not p^.Vec^.Token.Same(umlIntToStr(i)) then
          errored := True;
      if errored then
          Break;
    end;
  DisposeObject(m64);

  if not errored then
    begin
      { parallel search test }
      n.Append('...parallel');
      SetLength(TestResultBuff, length(TKDT3DC_Test.TestBuff));
      SetLength(TestResultIndex, length(TKDT3DC_Test.TestBuff));
      TKDT3DC_Test.Search(TKDT3DC_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if Distance(TKDT3DC_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
            errored := True;
    end;

  if not errored then
    begin
      n.Append('...kMean');
      TKDT3DC_Test.Clear;
      { kMean test }
      TKDT3DC_Test.BuildKDTreeWithCluster(TKDT3DC_Test.TestBuff, 10, 1, KMeanOutIndex);
      { parallel search test }
      TKDT3DC_Test.Search(TKDT3DC_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if TestResultIndex[i] <> KMeanOutIndex[i] then
            errored := True;
    end;

  SetLength(TKDT3DC_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT3DC_Test.Clear;

  n.Append('...');
  if errored then
      n.Append('error!')
  else
      n.Append('passed ok %dms', [GetTimeTick - t]);
  DisposeObject(TKDT3DC_Test);
  DoStatus(n);
  n := '';
end;

function TKDT4DC.InternalBuildKdTree(const KDSourceBufferPtr: PKDT4DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT4DC_Node;
  function SortCompare(const p1, p2: PKDT4DC_Source; const axis: NativeInt): ShortInt;
  begin
    if p1^.buff[axis] = p2^.buff[axis] then
      begin
        if p1^.Index = p2^.Index then
            Result := 0
        else if p1^.Index < p2^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.buff[axis] < p2^.buff[axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT4DC_SourceBuffer; L, R: NativeInt; const axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT4DC_Source;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer^[(L + R) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, axis) < 0 do
            Inc(i);
        while SortCompare(SortBuffer^[j], p, axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, axis);
      L := i;
    until i >= R;
  end;

var
  M: NativeInt;
  axis: NativeInt;
  kdBuffPtr: PKDT4DC_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      new(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.Vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);
    end
  else
    begin
      axis := Depth mod KDT4DC_Axis;
      M := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr^[0], 0, PlanCount - 1, axis);

      new(Result);
      Result^.Parent := nil;
      Result^.Vec := kdBuffPtr^[M];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], M, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[M + 1], PlanCount - (M + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT4DC.GetData(const Index: NativeInt): PKDT4DC_Source;
begin
  Result := @KDStoreBuff[Index];
end;

constructor TKDT4DC.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT4DC.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT4DC.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT4DC_Node(KDNodes[i]));
      Inc(i);
    end;

  for i := 0 to length(KDStoreBuff) - 1 do
      KDStoreBuff[i].Token := '';

  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT4DC.StoreBuffPtr: PKDT4DC_DyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT4DC.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT4DC_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT4DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT4DC.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT4DC_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT4DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT4DC.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT4DC_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT4DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{ k-means++ clusterization }
procedure TKDT4DC.BuildKDTreeWithCluster(const inBuff: TKDT4DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  SetLength(Source, length(inBuff), KDT4DC_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT4DC_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT4DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT4DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT4DC.BuildKDTreeWithCluster(const inBuff: TKDT4DC_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TKMIntegerArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT4DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT4DC_BuildCall);
var
  TempStoreBuff: TKDT4DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT4DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT4DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT4DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT4DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT4DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT4DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT4DC_BuildMethod);
var
  TempStoreBuff: TKDT4DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT4DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT4DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT4DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT4DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT4DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT4DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT4DC_BuildProc);
var
  TempStoreBuff: TKDT4DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT4DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT4DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT4DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT4DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT4DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

function TKDT4DC.Search(const buff: TKDT4DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT4DC_Node;

var
  NearestNeighbour: PKDT4DC_Node;

  function FindParentNode(const buffPtr: PKDT4DC_Vec; NodePtr: PKDT4DC_Node): PKDT4DC_Node;
  var
    Next: PKDT4DC_Node;
    Depth, axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        axis := Depth mod KDT4DC_Axis;
        if buffPtr^[axis] > Next^.Vec^.buff[axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT4DC_Node; const buffPtr: PKDT4DC_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    Inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := Distance(buffPtr^, NodePtr^.Vec^.buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.Vec^.Index < NearestNeighbour^.Vec^.Index) then
        NearestNeighbour := NodePtr;

    axis := Depth mod KDT4DC_Axis;
    Dist := NodePtr^.Vec^.buff[axis] - buffPtr^[axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.Vec^.buff[axis] > buffPtr^[axis] then
            ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const buffPtr: PKDT4DC_Vec; const p1, p2: PKDT4DC_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := Distance(buffPtr^, p1^.Vec^.buff);
    d2 := Distance(buffPtr^, p2^.Vec^.buff);
    if d1 = d2 then
      begin
        if p1^.Vec^.Index = p2^.Vec^.Index then
            Result := 0
        else if p1^.Vec^.Index < p2^.Vec^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; L, R: NativeInt; const buffPtr: PKDT4DC_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT4DC_Node;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer[(L + R) shr 1];
      repeat
        while SortCompare(buffPtr, SortBuffer[i], p) < 0 do
            Inc(i);
        while SortCompare(buffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, buffPtr);
      L := i;
    until i >= R;
  end;

var
  Parent: PKDT4DC_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := Distance(buff, Parent^.Vec^.buff);

  ScanSubtree(RootNode, @buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT4DC_Node(NearestNodes[0]);
    end;
end;

function TKDT4DC.Search(const buff: TKDT4DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT4DC_Node;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT4DC.Search(const buff: TKDT4DC_Vec; var SearchedDistanceMin: Double): PKDT4DC_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT4DC.Search(const buff: TKDT4DC_Vec): PKDT4DC_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT4DC.SearchToken(const buff: TKDT4DC_Vec): TPascalString;
var
  p: PKDT4DC_Node;
begin
  p := Search(buff);
  if p <> nil then
      Result := p^.Vec^.Token
  else
      Result := '';
end;

procedure TKDT4DC.Search(const inBuff: TKDT4DC_DynamicVecBuffer; var OutBuff: TKDT4DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT4DC_DynamicVecBuffer;
  outBuffPtr: PKDT4DC_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT4DC_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outBuffPtr^[pass] := p^.Vec^.buff;
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT4DC_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outBuffPtr^[pass] := p^.Vec^.buff;
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT4DC_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.Vec^.buff;
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT4DC.Search(const inBuff: TKDT4DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT4DC_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT4DC_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT4DC_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT4DC_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT4DC.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  ID := KDT4DC_Axis;

  stream.write(st, 4);
  stream.write(ID, 4);

  stream.write(cnt, 8);

  i := 0;
  while i < cnt do
    begin
      stream.write(KDStoreBuff[i].buff[0], SizeOf(TKDT4DC_Vec));
      stream.write(KDStoreBuff[i].Index, 8);
      token_B := KDStoreBuff[i].Token.Bytes;
      token_L := length(token_B);
      stream.write(token_L, 4);
      if token_L > 0 then
        begin
          stream.write(token_B[0], token_L);
          SetLength(token_B, 0);
        end;
      Inc(i);
    end;
end;

procedure TKDT4DC.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  Clear;

  stream.read(st, 4);
  stream.read(ID, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if ID <> KDT4DC_Axis then
      RaiseInfo('kdtree axis error!');

  stream.read(cnt, 8);

  SetLength(KDStoreBuff, cnt);

  i := 0;
  try
    while i < cnt do
      begin
        if stream.read(KDStoreBuff[i].buff[0], SizeOf(TKDT4DC_Vec)) <> SizeOf(TKDT4DC_Vec) then
          begin
            Clear;
            Exit;
          end;
        if stream.read(KDStoreBuff[i].Index, 8) <> 8 then
          begin
            Clear;
            Exit;
          end;
        if stream.read(token_L, 4) <> 4 then
          begin
            Clear;
            Exit;
          end;
        if token_L > 0 then
          begin
            SetLength(token_B, token_L);
            if stream.read(token_B[0], token_L) <> token_L then
              begin
                Clear;
                Exit;
              end;
            KDStoreBuff[i].Token.Bytes := token_B;
            SetLength(token_B, 0);
          end
        else
            KDStoreBuff[i].Token := '';
        Inc(i);
      end;
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      Inc(i);
    end;

  if cnt > 0 then
      RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT4DC.SaveToFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(FileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT4DC.LoadFromFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT4DC.PrintNodeTree(const NodePtr: PKDT4DC_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT4DC_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.Vec^.Index, Vec(p^.Vec^.buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT4DC.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d - %d : %s ', [i, KDStoreBuff[i].Index, Vec(KDStoreBuff[i].buff)]);
end;

class function TKDT4DC.Vec(const s: SystemString): TKDT4DC_Vec;
var
  t: TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j: NativeInt;
begin
  for i := 0 to KDT4DC_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            Inc(j);
            if j >= KDT4DC_Axis then
                Break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT4DC.Vec(const v: TKDT4DC_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT4DC_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT4DC.Distance(const v1, v2: TKDT4DC_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT4DC_Axis - 1 do
      Result := Result + (v2[i] - v1[i]) * (v2[i] - v1[i]);
end;

procedure TKDT4DC.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT4DC_Source; const Data: Pointer);
begin
  Source.buff := TestBuff[IndexFor];
  Source.Token := umlIntToStr(IndexFor);
end;

class procedure TKDT4DC.Test;
var
  TKDT4DC_Test: TKDT4DC;
  t: TTimeTick;
  i, j: NativeInt;
  TestResultBuff: TKDT4DC_DynamicVecBuffer;
  TestResultIndex: TKMIntegerArray;
  KMeanOutIndex: TKMIntegerArray;
  errored: Boolean;
  m64: TMemoryStream64;
  p: PKDT4DC_Node;
  n: TPascalString;
begin
  errored := False;
  n := PFormat('test %s...', [ClassName]);
  t := GetTimeTick;

  n.Append('...build');
  TKDT4DC_Test := TKDT4DC.Create;

  n.Append('...');
  SetLength(TKDT4DC_Test.TestBuff, 1000);
  for i := 0 to length(TKDT4DC_Test.TestBuff) - 1 do
    for j := 0 to KDT4DC_Axis - 1 do
        TKDT4DC_Test.TestBuff[i][j] := i * KDT4DC_Axis + j;

{$IFDEF FPC}
  TKDT4DC_Test.BuildKDTreeM(length(TKDT4DC_Test.TestBuff), nil, @TKDT4DC_Test.Test_BuildM);
{$ELSE FPC}
  TKDT4DC_Test.BuildKDTreeM(length(TKDT4DC_Test.TestBuff), nil, TKDT4DC_Test.Test_BuildM);
{$ENDIF FPC}
  { save/load test }
  n.Append('...save/load');
  m64 := TMemoryStream64.CustomCreate(1024 * 1024);
  TKDT4DC_Test.SaveToStream(m64);
  m64.Position := 0;
  TKDT4DC_Test.LoadFromStream(m64);
  for i := 0 to length(TKDT4DC_Test.TestBuff) - 1 do
    begin
      p := TKDT4DC_Test.Search(TKDT4DC_Test.TestBuff[i]);
      if p^.Vec^.Index <> i then
          errored := True;
      if not p^.Vec^.Token.Same(umlIntToStr(i)) then
          errored := True;
      if errored then
          Break;
    end;
  DisposeObject(m64);

  if not errored then
    begin
      { parallel search test }
      n.Append('...parallel');
      SetLength(TestResultBuff, length(TKDT4DC_Test.TestBuff));
      SetLength(TestResultIndex, length(TKDT4DC_Test.TestBuff));
      TKDT4DC_Test.Search(TKDT4DC_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if Distance(TKDT4DC_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
            errored := True;
    end;

  if not errored then
    begin
      n.Append('...kMean');
      TKDT4DC_Test.Clear;
      { kMean test }
      TKDT4DC_Test.BuildKDTreeWithCluster(TKDT4DC_Test.TestBuff, 10, 1, KMeanOutIndex);
      { parallel search test }
      TKDT4DC_Test.Search(TKDT4DC_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if TestResultIndex[i] <> KMeanOutIndex[i] then
            errored := True;
    end;

  SetLength(TKDT4DC_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT4DC_Test.Clear;

  n.Append('...');
  if errored then
      n.Append('error!')
  else
      n.Append('passed ok %dms', [GetTimeTick - t]);
  DisposeObject(TKDT4DC_Test);
  DoStatus(n);
  n := '';
end;

function TKDT5DC.InternalBuildKdTree(const KDSourceBufferPtr: PKDT5DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT5DC_Node;
  function SortCompare(const p1, p2: PKDT5DC_Source; const axis: NativeInt): ShortInt;
  begin
    if p1^.buff[axis] = p2^.buff[axis] then
      begin
        if p1^.Index = p2^.Index then
            Result := 0
        else if p1^.Index < p2^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.buff[axis] < p2^.buff[axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT5DC_SourceBuffer; L, R: NativeInt; const axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT5DC_Source;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer^[(L + R) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, axis) < 0 do
            Inc(i);
        while SortCompare(SortBuffer^[j], p, axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, axis);
      L := i;
    until i >= R;
  end;

var
  M: NativeInt;
  axis: NativeInt;
  kdBuffPtr: PKDT5DC_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      new(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.Vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);
    end
  else
    begin
      axis := Depth mod KDT5DC_Axis;
      M := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr^[0], 0, PlanCount - 1, axis);

      new(Result);
      Result^.Parent := nil;
      Result^.Vec := kdBuffPtr^[M];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], M, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[M + 1], PlanCount - (M + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT5DC.GetData(const Index: NativeInt): PKDT5DC_Source;
begin
  Result := @KDStoreBuff[Index];
end;

constructor TKDT5DC.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT5DC.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT5DC.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT5DC_Node(KDNodes[i]));
      Inc(i);
    end;

  for i := 0 to length(KDStoreBuff) - 1 do
      KDStoreBuff[i].Token := '';

  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT5DC.StoreBuffPtr: PKDT5DC_DyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT5DC.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT5DC_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT5DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT5DC.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT5DC_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT5DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT5DC.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT5DC_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT5DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{ k-means++ clusterization }
procedure TKDT5DC.BuildKDTreeWithCluster(const inBuff: TKDT5DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  SetLength(Source, length(inBuff), KDT5DC_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT5DC_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT5DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT5DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT5DC.BuildKDTreeWithCluster(const inBuff: TKDT5DC_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TKMIntegerArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT5DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT5DC_BuildCall);
var
  TempStoreBuff: TKDT5DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT5DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT5DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT5DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT5DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT5DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT5DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT5DC_BuildMethod);
var
  TempStoreBuff: TKDT5DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT5DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT5DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT5DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT5DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT5DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT5DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT5DC_BuildProc);
var
  TempStoreBuff: TKDT5DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT5DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT5DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT5DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT5DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT5DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

function TKDT5DC.Search(const buff: TKDT5DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT5DC_Node;

var
  NearestNeighbour: PKDT5DC_Node;

  function FindParentNode(const buffPtr: PKDT5DC_Vec; NodePtr: PKDT5DC_Node): PKDT5DC_Node;
  var
    Next: PKDT5DC_Node;
    Depth, axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        axis := Depth mod KDT5DC_Axis;
        if buffPtr^[axis] > Next^.Vec^.buff[axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT5DC_Node; const buffPtr: PKDT5DC_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    Inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := Distance(buffPtr^, NodePtr^.Vec^.buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.Vec^.Index < NearestNeighbour^.Vec^.Index) then
        NearestNeighbour := NodePtr;

    axis := Depth mod KDT5DC_Axis;
    Dist := NodePtr^.Vec^.buff[axis] - buffPtr^[axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.Vec^.buff[axis] > buffPtr^[axis] then
            ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const buffPtr: PKDT5DC_Vec; const p1, p2: PKDT5DC_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := Distance(buffPtr^, p1^.Vec^.buff);
    d2 := Distance(buffPtr^, p2^.Vec^.buff);
    if d1 = d2 then
      begin
        if p1^.Vec^.Index = p2^.Vec^.Index then
            Result := 0
        else if p1^.Vec^.Index < p2^.Vec^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; L, R: NativeInt; const buffPtr: PKDT5DC_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT5DC_Node;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer[(L + R) shr 1];
      repeat
        while SortCompare(buffPtr, SortBuffer[i], p) < 0 do
            Inc(i);
        while SortCompare(buffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, buffPtr);
      L := i;
    until i >= R;
  end;

var
  Parent: PKDT5DC_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := Distance(buff, Parent^.Vec^.buff);

  ScanSubtree(RootNode, @buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT5DC_Node(NearestNodes[0]);
    end;
end;

function TKDT5DC.Search(const buff: TKDT5DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT5DC_Node;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT5DC.Search(const buff: TKDT5DC_Vec; var SearchedDistanceMin: Double): PKDT5DC_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT5DC.Search(const buff: TKDT5DC_Vec): PKDT5DC_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT5DC.SearchToken(const buff: TKDT5DC_Vec): TPascalString;
var
  p: PKDT5DC_Node;
begin
  p := Search(buff);
  if p <> nil then
      Result := p^.Vec^.Token
  else
      Result := '';
end;

procedure TKDT5DC.Search(const inBuff: TKDT5DC_DynamicVecBuffer; var OutBuff: TKDT5DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT5DC_DynamicVecBuffer;
  outBuffPtr: PKDT5DC_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT5DC_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outBuffPtr^[pass] := p^.Vec^.buff;
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT5DC_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outBuffPtr^[pass] := p^.Vec^.buff;
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT5DC_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.Vec^.buff;
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT5DC.Search(const inBuff: TKDT5DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT5DC_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT5DC_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT5DC_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT5DC_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT5DC.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  ID := KDT5DC_Axis;

  stream.write(st, 4);
  stream.write(ID, 4);

  stream.write(cnt, 8);

  i := 0;
  while i < cnt do
    begin
      stream.write(KDStoreBuff[i].buff[0], SizeOf(TKDT5DC_Vec));
      stream.write(KDStoreBuff[i].Index, 8);
      token_B := KDStoreBuff[i].Token.Bytes;
      token_L := length(token_B);
      stream.write(token_L, 4);
      if token_L > 0 then
        begin
          stream.write(token_B[0], token_L);
          SetLength(token_B, 0);
        end;
      Inc(i);
    end;
end;

procedure TKDT5DC.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  Clear;

  stream.read(st, 4);
  stream.read(ID, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if ID <> KDT5DC_Axis then
      RaiseInfo('kdtree axis error!');

  stream.read(cnt, 8);

  SetLength(KDStoreBuff, cnt);

  i := 0;
  try
    while i < cnt do
      begin
        if stream.read(KDStoreBuff[i].buff[0], SizeOf(TKDT5DC_Vec)) <> SizeOf(TKDT5DC_Vec) then
          begin
            Clear;
            Exit;
          end;
        if stream.read(KDStoreBuff[i].Index, 8) <> 8 then
          begin
            Clear;
            Exit;
          end;
        if stream.read(token_L, 4) <> 4 then
          begin
            Clear;
            Exit;
          end;
        if token_L > 0 then
          begin
            SetLength(token_B, token_L);
            if stream.read(token_B[0], token_L) <> token_L then
              begin
                Clear;
                Exit;
              end;
            KDStoreBuff[i].Token.Bytes := token_B;
            SetLength(token_B, 0);
          end
        else
            KDStoreBuff[i].Token := '';
        Inc(i);
      end;
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      Inc(i);
    end;

  if cnt > 0 then
      RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT5DC.SaveToFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(FileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT5DC.LoadFromFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT5DC.PrintNodeTree(const NodePtr: PKDT5DC_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT5DC_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.Vec^.Index, Vec(p^.Vec^.buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT5DC.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d - %d : %s ', [i, KDStoreBuff[i].Index, Vec(KDStoreBuff[i].buff)]);
end;

class function TKDT5DC.Vec(const s: SystemString): TKDT5DC_Vec;
var
  t: TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j: NativeInt;
begin
  for i := 0 to KDT5DC_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            Inc(j);
            if j >= KDT5DC_Axis then
                Break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT5DC.Vec(const v: TKDT5DC_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT5DC_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT5DC.Distance(const v1, v2: TKDT5DC_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT5DC_Axis - 1 do
      Result := Result + (v2[i] - v1[i]) * (v2[i] - v1[i]);
end;

procedure TKDT5DC.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT5DC_Source; const Data: Pointer);
begin
  Source.buff := TestBuff[IndexFor];
  Source.Token := umlIntToStr(IndexFor);
end;

class procedure TKDT5DC.Test;
var
  TKDT5DC_Test: TKDT5DC;
  t: TTimeTick;
  i, j: NativeInt;
  TestResultBuff: TKDT5DC_DynamicVecBuffer;
  TestResultIndex: TKMIntegerArray;
  KMeanOutIndex: TKMIntegerArray;
  errored: Boolean;
  m64: TMemoryStream64;
  p: PKDT5DC_Node;
  n: TPascalString;
begin
  errored := False;
  n := PFormat('test %s...', [ClassName]);
  t := GetTimeTick;

  n.Append('...build');
  TKDT5DC_Test := TKDT5DC.Create;

  n.Append('...');
  SetLength(TKDT5DC_Test.TestBuff, 1000);
  for i := 0 to length(TKDT5DC_Test.TestBuff) - 1 do
    for j := 0 to KDT5DC_Axis - 1 do
        TKDT5DC_Test.TestBuff[i][j] := i * KDT5DC_Axis + j;

{$IFDEF FPC}
  TKDT5DC_Test.BuildKDTreeM(length(TKDT5DC_Test.TestBuff), nil, @TKDT5DC_Test.Test_BuildM);
{$ELSE FPC}
  TKDT5DC_Test.BuildKDTreeM(length(TKDT5DC_Test.TestBuff), nil, TKDT5DC_Test.Test_BuildM);
{$ENDIF FPC}
  { save/load test }
  n.Append('...save/load');
  m64 := TMemoryStream64.CustomCreate(1024 * 1024);
  TKDT5DC_Test.SaveToStream(m64);
  m64.Position := 0;
  TKDT5DC_Test.LoadFromStream(m64);
  for i := 0 to length(TKDT5DC_Test.TestBuff) - 1 do
    begin
      p := TKDT5DC_Test.Search(TKDT5DC_Test.TestBuff[i]);
      if p^.Vec^.Index <> i then
          errored := True;
      if not p^.Vec^.Token.Same(umlIntToStr(i)) then
          errored := True;
      if errored then
          Break;
    end;
  DisposeObject(m64);

  if not errored then
    begin
      { parallel search test }
      n.Append('...parallel');
      SetLength(TestResultBuff, length(TKDT5DC_Test.TestBuff));
      SetLength(TestResultIndex, length(TKDT5DC_Test.TestBuff));
      TKDT5DC_Test.Search(TKDT5DC_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if Distance(TKDT5DC_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
            errored := True;
    end;

  if not errored then
    begin
      n.Append('...kMean');
      TKDT5DC_Test.Clear;
      { kMean test }
      TKDT5DC_Test.BuildKDTreeWithCluster(TKDT5DC_Test.TestBuff, 10, 1, KMeanOutIndex);
      { parallel search test }
      TKDT5DC_Test.Search(TKDT5DC_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if TestResultIndex[i] <> KMeanOutIndex[i] then
            errored := True;
    end;

  SetLength(TKDT5DC_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT5DC_Test.Clear;

  n.Append('...');
  if errored then
      n.Append('error!')
  else
      n.Append('passed ok %dms', [GetTimeTick - t]);
  DisposeObject(TKDT5DC_Test);
  DoStatus(n);
  n := '';
end;

function TKDT6DC.InternalBuildKdTree(const KDSourceBufferPtr: PKDT6DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT6DC_Node;
  function SortCompare(const p1, p2: PKDT6DC_Source; const axis: NativeInt): ShortInt;
  begin
    if p1^.buff[axis] = p2^.buff[axis] then
      begin
        if p1^.Index = p2^.Index then
            Result := 0
        else if p1^.Index < p2^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.buff[axis] < p2^.buff[axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT6DC_SourceBuffer; L, R: NativeInt; const axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT6DC_Source;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer^[(L + R) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, axis) < 0 do
            Inc(i);
        while SortCompare(SortBuffer^[j], p, axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, axis);
      L := i;
    until i >= R;
  end;

var
  M: NativeInt;
  axis: NativeInt;
  kdBuffPtr: PKDT6DC_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      new(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.Vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);
    end
  else
    begin
      axis := Depth mod KDT6DC_Axis;
      M := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr^[0], 0, PlanCount - 1, axis);

      new(Result);
      Result^.Parent := nil;
      Result^.Vec := kdBuffPtr^[M];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], M, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[M + 1], PlanCount - (M + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT6DC.GetData(const Index: NativeInt): PKDT6DC_Source;
begin
  Result := @KDStoreBuff[Index];
end;

constructor TKDT6DC.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT6DC.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT6DC.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT6DC_Node(KDNodes[i]));
      Inc(i);
    end;

  for i := 0 to length(KDStoreBuff) - 1 do
      KDStoreBuff[i].Token := '';

  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT6DC.StoreBuffPtr: PKDT6DC_DyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT6DC.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT6DC_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT6DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT6DC.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT6DC_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT6DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT6DC.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT6DC_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT6DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{ k-means++ clusterization }
procedure TKDT6DC.BuildKDTreeWithCluster(const inBuff: TKDT6DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  SetLength(Source, length(inBuff), KDT6DC_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT6DC_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT6DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT6DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT6DC.BuildKDTreeWithCluster(const inBuff: TKDT6DC_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TKMIntegerArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT6DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT6DC_BuildCall);
var
  TempStoreBuff: TKDT6DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT6DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT6DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT6DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT6DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT6DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT6DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT6DC_BuildMethod);
var
  TempStoreBuff: TKDT6DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT6DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT6DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT6DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT6DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT6DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT6DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT6DC_BuildProc);
var
  TempStoreBuff: TKDT6DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT6DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT6DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT6DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT6DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT6DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

function TKDT6DC.Search(const buff: TKDT6DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT6DC_Node;

var
  NearestNeighbour: PKDT6DC_Node;

  function FindParentNode(const buffPtr: PKDT6DC_Vec; NodePtr: PKDT6DC_Node): PKDT6DC_Node;
  var
    Next: PKDT6DC_Node;
    Depth, axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        axis := Depth mod KDT6DC_Axis;
        if buffPtr^[axis] > Next^.Vec^.buff[axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT6DC_Node; const buffPtr: PKDT6DC_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    Inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := Distance(buffPtr^, NodePtr^.Vec^.buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.Vec^.Index < NearestNeighbour^.Vec^.Index) then
        NearestNeighbour := NodePtr;

    axis := Depth mod KDT6DC_Axis;
    Dist := NodePtr^.Vec^.buff[axis] - buffPtr^[axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.Vec^.buff[axis] > buffPtr^[axis] then
            ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const buffPtr: PKDT6DC_Vec; const p1, p2: PKDT6DC_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := Distance(buffPtr^, p1^.Vec^.buff);
    d2 := Distance(buffPtr^, p2^.Vec^.buff);
    if d1 = d2 then
      begin
        if p1^.Vec^.Index = p2^.Vec^.Index then
            Result := 0
        else if p1^.Vec^.Index < p2^.Vec^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; L, R: NativeInt; const buffPtr: PKDT6DC_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT6DC_Node;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer[(L + R) shr 1];
      repeat
        while SortCompare(buffPtr, SortBuffer[i], p) < 0 do
            Inc(i);
        while SortCompare(buffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, buffPtr);
      L := i;
    until i >= R;
  end;

var
  Parent: PKDT6DC_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := Distance(buff, Parent^.Vec^.buff);

  ScanSubtree(RootNode, @buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT6DC_Node(NearestNodes[0]);
    end;
end;

function TKDT6DC.Search(const buff: TKDT6DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT6DC_Node;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT6DC.Search(const buff: TKDT6DC_Vec; var SearchedDistanceMin: Double): PKDT6DC_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT6DC.Search(const buff: TKDT6DC_Vec): PKDT6DC_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT6DC.SearchToken(const buff: TKDT6DC_Vec): TPascalString;
var
  p: PKDT6DC_Node;
begin
  p := Search(buff);
  if p <> nil then
      Result := p^.Vec^.Token
  else
      Result := '';
end;

procedure TKDT6DC.Search(const inBuff: TKDT6DC_DynamicVecBuffer; var OutBuff: TKDT6DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT6DC_DynamicVecBuffer;
  outBuffPtr: PKDT6DC_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT6DC_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outBuffPtr^[pass] := p^.Vec^.buff;
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT6DC_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outBuffPtr^[pass] := p^.Vec^.buff;
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT6DC_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.Vec^.buff;
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT6DC.Search(const inBuff: TKDT6DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT6DC_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT6DC_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT6DC_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT6DC_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT6DC.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  ID := KDT6DC_Axis;

  stream.write(st, 4);
  stream.write(ID, 4);

  stream.write(cnt, 8);

  i := 0;
  while i < cnt do
    begin
      stream.write(KDStoreBuff[i].buff[0], SizeOf(TKDT6DC_Vec));
      stream.write(KDStoreBuff[i].Index, 8);
      token_B := KDStoreBuff[i].Token.Bytes;
      token_L := length(token_B);
      stream.write(token_L, 4);
      if token_L > 0 then
        begin
          stream.write(token_B[0], token_L);
          SetLength(token_B, 0);
        end;
      Inc(i);
    end;
end;

procedure TKDT6DC.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  Clear;

  stream.read(st, 4);
  stream.read(ID, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if ID <> KDT6DC_Axis then
      RaiseInfo('kdtree axis error!');

  stream.read(cnt, 8);

  SetLength(KDStoreBuff, cnt);

  i := 0;
  try
    while i < cnt do
      begin
        if stream.read(KDStoreBuff[i].buff[0], SizeOf(TKDT6DC_Vec)) <> SizeOf(TKDT6DC_Vec) then
          begin
            Clear;
            Exit;
          end;
        if stream.read(KDStoreBuff[i].Index, 8) <> 8 then
          begin
            Clear;
            Exit;
          end;
        if stream.read(token_L, 4) <> 4 then
          begin
            Clear;
            Exit;
          end;
        if token_L > 0 then
          begin
            SetLength(token_B, token_L);
            if stream.read(token_B[0], token_L) <> token_L then
              begin
                Clear;
                Exit;
              end;
            KDStoreBuff[i].Token.Bytes := token_B;
            SetLength(token_B, 0);
          end
        else
            KDStoreBuff[i].Token := '';
        Inc(i);
      end;
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      Inc(i);
    end;

  if cnt > 0 then
      RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT6DC.SaveToFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(FileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT6DC.LoadFromFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT6DC.PrintNodeTree(const NodePtr: PKDT6DC_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT6DC_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.Vec^.Index, Vec(p^.Vec^.buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT6DC.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d - %d : %s ', [i, KDStoreBuff[i].Index, Vec(KDStoreBuff[i].buff)]);
end;

class function TKDT6DC.Vec(const s: SystemString): TKDT6DC_Vec;
var
  t: TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j: NativeInt;
begin
  for i := 0 to KDT6DC_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            Inc(j);
            if j >= KDT6DC_Axis then
                Break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT6DC.Vec(const v: TKDT6DC_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT6DC_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT6DC.Distance(const v1, v2: TKDT6DC_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT6DC_Axis - 1 do
      Result := Result + (v2[i] - v1[i]) * (v2[i] - v1[i]);
end;

procedure TKDT6DC.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT6DC_Source; const Data: Pointer);
begin
  Source.buff := TestBuff[IndexFor];
  Source.Token := umlIntToStr(IndexFor);
end;

class procedure TKDT6DC.Test;
var
  TKDT6DC_Test: TKDT6DC;
  t: TTimeTick;
  i, j: NativeInt;
  TestResultBuff: TKDT6DC_DynamicVecBuffer;
  TestResultIndex: TKMIntegerArray;
  KMeanOutIndex: TKMIntegerArray;
  errored: Boolean;
  m64: TMemoryStream64;
  p: PKDT6DC_Node;
  n: TPascalString;
begin
  errored := False;
  n := PFormat('test %s...', [ClassName]);
  t := GetTimeTick;

  n.Append('...build');
  TKDT6DC_Test := TKDT6DC.Create;

  n.Append('...');
  SetLength(TKDT6DC_Test.TestBuff, 1000);
  for i := 0 to length(TKDT6DC_Test.TestBuff) - 1 do
    for j := 0 to KDT6DC_Axis - 1 do
        TKDT6DC_Test.TestBuff[i][j] := i * KDT6DC_Axis + j;

{$IFDEF FPC}
  TKDT6DC_Test.BuildKDTreeM(length(TKDT6DC_Test.TestBuff), nil, @TKDT6DC_Test.Test_BuildM);
{$ELSE FPC}
  TKDT6DC_Test.BuildKDTreeM(length(TKDT6DC_Test.TestBuff), nil, TKDT6DC_Test.Test_BuildM);
{$ENDIF FPC}
  { save/load test }
  n.Append('...save/load');
  m64 := TMemoryStream64.CustomCreate(1024 * 1024);
  TKDT6DC_Test.SaveToStream(m64);
  m64.Position := 0;
  TKDT6DC_Test.LoadFromStream(m64);
  for i := 0 to length(TKDT6DC_Test.TestBuff) - 1 do
    begin
      p := TKDT6DC_Test.Search(TKDT6DC_Test.TestBuff[i]);
      if p^.Vec^.Index <> i then
          errored := True;
      if not p^.Vec^.Token.Same(umlIntToStr(i)) then
          errored := True;
      if errored then
          Break;
    end;
  DisposeObject(m64);

  if not errored then
    begin
      { parallel search test }
      n.Append('...parallel');
      SetLength(TestResultBuff, length(TKDT6DC_Test.TestBuff));
      SetLength(TestResultIndex, length(TKDT6DC_Test.TestBuff));
      TKDT6DC_Test.Search(TKDT6DC_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if Distance(TKDT6DC_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
            errored := True;
    end;

  if not errored then
    begin
      n.Append('...kMean');
      TKDT6DC_Test.Clear;
      { kMean test }
      TKDT6DC_Test.BuildKDTreeWithCluster(TKDT6DC_Test.TestBuff, 10, 1, KMeanOutIndex);
      { parallel search test }
      TKDT6DC_Test.Search(TKDT6DC_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if TestResultIndex[i] <> KMeanOutIndex[i] then
            errored := True;
    end;

  SetLength(TKDT6DC_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT6DC_Test.Clear;

  n.Append('...');
  if errored then
      n.Append('error!')
  else
      n.Append('passed ok %dms', [GetTimeTick - t]);
  DisposeObject(TKDT6DC_Test);
  DoStatus(n);
  n := '';
end;

function TKDT7DC.InternalBuildKdTree(const KDSourceBufferPtr: PKDT7DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT7DC_Node;
  function SortCompare(const p1, p2: PKDT7DC_Source; const axis: NativeInt): ShortInt;
  begin
    if p1^.buff[axis] = p2^.buff[axis] then
      begin
        if p1^.Index = p2^.Index then
            Result := 0
        else if p1^.Index < p2^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.buff[axis] < p2^.buff[axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT7DC_SourceBuffer; L, R: NativeInt; const axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT7DC_Source;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer^[(L + R) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, axis) < 0 do
            Inc(i);
        while SortCompare(SortBuffer^[j], p, axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, axis);
      L := i;
    until i >= R;
  end;

var
  M: NativeInt;
  axis: NativeInt;
  kdBuffPtr: PKDT7DC_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      new(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.Vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);
    end
  else
    begin
      axis := Depth mod KDT7DC_Axis;
      M := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr^[0], 0, PlanCount - 1, axis);

      new(Result);
      Result^.Parent := nil;
      Result^.Vec := kdBuffPtr^[M];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], M, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[M + 1], PlanCount - (M + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT7DC.GetData(const Index: NativeInt): PKDT7DC_Source;
begin
  Result := @KDStoreBuff[Index];
end;

constructor TKDT7DC.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT7DC.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT7DC.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT7DC_Node(KDNodes[i]));
      Inc(i);
    end;

  for i := 0 to length(KDStoreBuff) - 1 do
      KDStoreBuff[i].Token := '';

  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT7DC.StoreBuffPtr: PKDT7DC_DyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT7DC.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT7DC_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT7DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT7DC.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT7DC_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT7DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT7DC.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT7DC_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT7DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{ k-means++ clusterization }
procedure TKDT7DC.BuildKDTreeWithCluster(const inBuff: TKDT7DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  SetLength(Source, length(inBuff), KDT7DC_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT7DC_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT7DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT7DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT7DC.BuildKDTreeWithCluster(const inBuff: TKDT7DC_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TKMIntegerArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT7DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT7DC_BuildCall);
var
  TempStoreBuff: TKDT7DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT7DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT7DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT7DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT7DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT7DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT7DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT7DC_BuildMethod);
var
  TempStoreBuff: TKDT7DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT7DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT7DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT7DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT7DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT7DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT7DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT7DC_BuildProc);
var
  TempStoreBuff: TKDT7DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT7DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT7DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT7DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT7DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT7DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

function TKDT7DC.Search(const buff: TKDT7DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT7DC_Node;

var
  NearestNeighbour: PKDT7DC_Node;

  function FindParentNode(const buffPtr: PKDT7DC_Vec; NodePtr: PKDT7DC_Node): PKDT7DC_Node;
  var
    Next: PKDT7DC_Node;
    Depth, axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        axis := Depth mod KDT7DC_Axis;
        if buffPtr^[axis] > Next^.Vec^.buff[axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT7DC_Node; const buffPtr: PKDT7DC_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    Inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := Distance(buffPtr^, NodePtr^.Vec^.buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.Vec^.Index < NearestNeighbour^.Vec^.Index) then
        NearestNeighbour := NodePtr;

    axis := Depth mod KDT7DC_Axis;
    Dist := NodePtr^.Vec^.buff[axis] - buffPtr^[axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.Vec^.buff[axis] > buffPtr^[axis] then
            ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const buffPtr: PKDT7DC_Vec; const p1, p2: PKDT7DC_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := Distance(buffPtr^, p1^.Vec^.buff);
    d2 := Distance(buffPtr^, p2^.Vec^.buff);
    if d1 = d2 then
      begin
        if p1^.Vec^.Index = p2^.Vec^.Index then
            Result := 0
        else if p1^.Vec^.Index < p2^.Vec^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; L, R: NativeInt; const buffPtr: PKDT7DC_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT7DC_Node;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer[(L + R) shr 1];
      repeat
        while SortCompare(buffPtr, SortBuffer[i], p) < 0 do
            Inc(i);
        while SortCompare(buffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, buffPtr);
      L := i;
    until i >= R;
  end;

var
  Parent: PKDT7DC_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := Distance(buff, Parent^.Vec^.buff);

  ScanSubtree(RootNode, @buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT7DC_Node(NearestNodes[0]);
    end;
end;

function TKDT7DC.Search(const buff: TKDT7DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT7DC_Node;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT7DC.Search(const buff: TKDT7DC_Vec; var SearchedDistanceMin: Double): PKDT7DC_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT7DC.Search(const buff: TKDT7DC_Vec): PKDT7DC_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT7DC.SearchToken(const buff: TKDT7DC_Vec): TPascalString;
var
  p: PKDT7DC_Node;
begin
  p := Search(buff);
  if p <> nil then
      Result := p^.Vec^.Token
  else
      Result := '';
end;

procedure TKDT7DC.Search(const inBuff: TKDT7DC_DynamicVecBuffer; var OutBuff: TKDT7DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT7DC_DynamicVecBuffer;
  outBuffPtr: PKDT7DC_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT7DC_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outBuffPtr^[pass] := p^.Vec^.buff;
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT7DC_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outBuffPtr^[pass] := p^.Vec^.buff;
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT7DC_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.Vec^.buff;
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT7DC.Search(const inBuff: TKDT7DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT7DC_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT7DC_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT7DC_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT7DC_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT7DC.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  ID := KDT7DC_Axis;

  stream.write(st, 4);
  stream.write(ID, 4);

  stream.write(cnt, 8);

  i := 0;
  while i < cnt do
    begin
      stream.write(KDStoreBuff[i].buff[0], SizeOf(TKDT7DC_Vec));
      stream.write(KDStoreBuff[i].Index, 8);
      token_B := KDStoreBuff[i].Token.Bytes;
      token_L := length(token_B);
      stream.write(token_L, 4);
      if token_L > 0 then
        begin
          stream.write(token_B[0], token_L);
          SetLength(token_B, 0);
        end;
      Inc(i);
    end;
end;

procedure TKDT7DC.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  Clear;

  stream.read(st, 4);
  stream.read(ID, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if ID <> KDT7DC_Axis then
      RaiseInfo('kdtree axis error!');

  stream.read(cnt, 8);

  SetLength(KDStoreBuff, cnt);

  i := 0;
  try
    while i < cnt do
      begin
        if stream.read(KDStoreBuff[i].buff[0], SizeOf(TKDT7DC_Vec)) <> SizeOf(TKDT7DC_Vec) then
          begin
            Clear;
            Exit;
          end;
        if stream.read(KDStoreBuff[i].Index, 8) <> 8 then
          begin
            Clear;
            Exit;
          end;
        if stream.read(token_L, 4) <> 4 then
          begin
            Clear;
            Exit;
          end;
        if token_L > 0 then
          begin
            SetLength(token_B, token_L);
            if stream.read(token_B[0], token_L) <> token_L then
              begin
                Clear;
                Exit;
              end;
            KDStoreBuff[i].Token.Bytes := token_B;
            SetLength(token_B, 0);
          end
        else
            KDStoreBuff[i].Token := '';
        Inc(i);
      end;
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      Inc(i);
    end;

  if cnt > 0 then
      RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT7DC.SaveToFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(FileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT7DC.LoadFromFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT7DC.PrintNodeTree(const NodePtr: PKDT7DC_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT7DC_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.Vec^.Index, Vec(p^.Vec^.buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT7DC.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d - %d : %s ', [i, KDStoreBuff[i].Index, Vec(KDStoreBuff[i].buff)]);
end;

class function TKDT7DC.Vec(const s: SystemString): TKDT7DC_Vec;
var
  t: TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j: NativeInt;
begin
  for i := 0 to KDT7DC_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            Inc(j);
            if j >= KDT7DC_Axis then
                Break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT7DC.Vec(const v: TKDT7DC_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT7DC_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT7DC.Distance(const v1, v2: TKDT7DC_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT7DC_Axis - 1 do
      Result := Result + (v2[i] - v1[i]) * (v2[i] - v1[i]);
end;

procedure TKDT7DC.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT7DC_Source; const Data: Pointer);
begin
  Source.buff := TestBuff[IndexFor];
  Source.Token := umlIntToStr(IndexFor);
end;

class procedure TKDT7DC.Test;
var
  TKDT7DC_Test: TKDT7DC;
  t: TTimeTick;
  i, j: NativeInt;
  TestResultBuff: TKDT7DC_DynamicVecBuffer;
  TestResultIndex: TKMIntegerArray;
  KMeanOutIndex: TKMIntegerArray;
  errored: Boolean;
  m64: TMemoryStream64;
  p: PKDT7DC_Node;
  n: TPascalString;
begin
  errored := False;
  n := PFormat('test %s...', [ClassName]);
  t := GetTimeTick;

  n.Append('...build');
  TKDT7DC_Test := TKDT7DC.Create;

  n.Append('...');
  SetLength(TKDT7DC_Test.TestBuff, 1000);
  for i := 0 to length(TKDT7DC_Test.TestBuff) - 1 do
    for j := 0 to KDT7DC_Axis - 1 do
        TKDT7DC_Test.TestBuff[i][j] := i * KDT7DC_Axis + j;

{$IFDEF FPC}
  TKDT7DC_Test.BuildKDTreeM(length(TKDT7DC_Test.TestBuff), nil, @TKDT7DC_Test.Test_BuildM);
{$ELSE FPC}
  TKDT7DC_Test.BuildKDTreeM(length(TKDT7DC_Test.TestBuff), nil, TKDT7DC_Test.Test_BuildM);
{$ENDIF FPC}
  { save/load test }
  n.Append('...save/load');
  m64 := TMemoryStream64.CustomCreate(1024 * 1024);
  TKDT7DC_Test.SaveToStream(m64);
  m64.Position := 0;
  TKDT7DC_Test.LoadFromStream(m64);
  for i := 0 to length(TKDT7DC_Test.TestBuff) - 1 do
    begin
      p := TKDT7DC_Test.Search(TKDT7DC_Test.TestBuff[i]);
      if p^.Vec^.Index <> i then
          errored := True;
      if not p^.Vec^.Token.Same(umlIntToStr(i)) then
          errored := True;
      if errored then
          Break;
    end;
  DisposeObject(m64);

  if not errored then
    begin
      { parallel search test }
      n.Append('...parallel');
      SetLength(TestResultBuff, length(TKDT7DC_Test.TestBuff));
      SetLength(TestResultIndex, length(TKDT7DC_Test.TestBuff));
      TKDT7DC_Test.Search(TKDT7DC_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if Distance(TKDT7DC_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
            errored := True;
    end;

  if not errored then
    begin
      n.Append('...kMean');
      TKDT7DC_Test.Clear;
      { kMean test }
      TKDT7DC_Test.BuildKDTreeWithCluster(TKDT7DC_Test.TestBuff, 10, 1, KMeanOutIndex);
      { parallel search test }
      TKDT7DC_Test.Search(TKDT7DC_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if TestResultIndex[i] <> KMeanOutIndex[i] then
            errored := True;
    end;

  SetLength(TKDT7DC_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT7DC_Test.Clear;

  n.Append('...');
  if errored then
      n.Append('error!')
  else
      n.Append('passed ok %dms', [GetTimeTick - t]);
  DisposeObject(TKDT7DC_Test);
  DoStatus(n);
  n := '';
end;

function TKDT8DC.InternalBuildKdTree(const KDSourceBufferPtr: PKDT8DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT8DC_Node;
  function SortCompare(const p1, p2: PKDT8DC_Source; const axis: NativeInt): ShortInt;
  begin
    if p1^.buff[axis] = p2^.buff[axis] then
      begin
        if p1^.Index = p2^.Index then
            Result := 0
        else if p1^.Index < p2^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.buff[axis] < p2^.buff[axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT8DC_SourceBuffer; L, R: NativeInt; const axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT8DC_Source;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer^[(L + R) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, axis) < 0 do
            Inc(i);
        while SortCompare(SortBuffer^[j], p, axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, axis);
      L := i;
    until i >= R;
  end;

var
  M: NativeInt;
  axis: NativeInt;
  kdBuffPtr: PKDT8DC_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      new(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.Vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);
    end
  else
    begin
      axis := Depth mod KDT8DC_Axis;
      M := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr^[0], 0, PlanCount - 1, axis);

      new(Result);
      Result^.Parent := nil;
      Result^.Vec := kdBuffPtr^[M];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], M, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[M + 1], PlanCount - (M + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT8DC.GetData(const Index: NativeInt): PKDT8DC_Source;
begin
  Result := @KDStoreBuff[Index];
end;

constructor TKDT8DC.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT8DC.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT8DC.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT8DC_Node(KDNodes[i]));
      Inc(i);
    end;

  for i := 0 to length(KDStoreBuff) - 1 do
      KDStoreBuff[i].Token := '';

  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT8DC.StoreBuffPtr: PKDT8DC_DyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT8DC.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT8DC_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT8DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT8DC.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT8DC_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT8DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT8DC.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT8DC_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT8DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{ k-means++ clusterization }
procedure TKDT8DC.BuildKDTreeWithCluster(const inBuff: TKDT8DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  SetLength(Source, length(inBuff), KDT8DC_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT8DC_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT8DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT8DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT8DC.BuildKDTreeWithCluster(const inBuff: TKDT8DC_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TKMIntegerArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT8DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT8DC_BuildCall);
var
  TempStoreBuff: TKDT8DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT8DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT8DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT8DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT8DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT8DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT8DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT8DC_BuildMethod);
var
  TempStoreBuff: TKDT8DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT8DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT8DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT8DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT8DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT8DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT8DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT8DC_BuildProc);
var
  TempStoreBuff: TKDT8DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT8DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT8DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT8DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT8DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT8DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

function TKDT8DC.Search(const buff: TKDT8DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT8DC_Node;

var
  NearestNeighbour: PKDT8DC_Node;

  function FindParentNode(const buffPtr: PKDT8DC_Vec; NodePtr: PKDT8DC_Node): PKDT8DC_Node;
  var
    Next: PKDT8DC_Node;
    Depth, axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        axis := Depth mod KDT8DC_Axis;
        if buffPtr^[axis] > Next^.Vec^.buff[axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT8DC_Node; const buffPtr: PKDT8DC_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    Inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := Distance(buffPtr^, NodePtr^.Vec^.buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.Vec^.Index < NearestNeighbour^.Vec^.Index) then
        NearestNeighbour := NodePtr;

    axis := Depth mod KDT8DC_Axis;
    Dist := NodePtr^.Vec^.buff[axis] - buffPtr^[axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.Vec^.buff[axis] > buffPtr^[axis] then
            ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const buffPtr: PKDT8DC_Vec; const p1, p2: PKDT8DC_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := Distance(buffPtr^, p1^.Vec^.buff);
    d2 := Distance(buffPtr^, p2^.Vec^.buff);
    if d1 = d2 then
      begin
        if p1^.Vec^.Index = p2^.Vec^.Index then
            Result := 0
        else if p1^.Vec^.Index < p2^.Vec^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; L, R: NativeInt; const buffPtr: PKDT8DC_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT8DC_Node;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer[(L + R) shr 1];
      repeat
        while SortCompare(buffPtr, SortBuffer[i], p) < 0 do
            Inc(i);
        while SortCompare(buffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, buffPtr);
      L := i;
    until i >= R;
  end;

var
  Parent: PKDT8DC_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := Distance(buff, Parent^.Vec^.buff);

  ScanSubtree(RootNode, @buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT8DC_Node(NearestNodes[0]);
    end;
end;

function TKDT8DC.Search(const buff: TKDT8DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT8DC_Node;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT8DC.Search(const buff: TKDT8DC_Vec; var SearchedDistanceMin: Double): PKDT8DC_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT8DC.Search(const buff: TKDT8DC_Vec): PKDT8DC_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT8DC.SearchToken(const buff: TKDT8DC_Vec): TPascalString;
var
  p: PKDT8DC_Node;
begin
  p := Search(buff);
  if p <> nil then
      Result := p^.Vec^.Token
  else
      Result := '';
end;

procedure TKDT8DC.Search(const inBuff: TKDT8DC_DynamicVecBuffer; var OutBuff: TKDT8DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT8DC_DynamicVecBuffer;
  outBuffPtr: PKDT8DC_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT8DC_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outBuffPtr^[pass] := p^.Vec^.buff;
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT8DC_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outBuffPtr^[pass] := p^.Vec^.buff;
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT8DC_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.Vec^.buff;
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT8DC.Search(const inBuff: TKDT8DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT8DC_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT8DC_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT8DC_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT8DC_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT8DC.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  ID := KDT8DC_Axis;

  stream.write(st, 4);
  stream.write(ID, 4);

  stream.write(cnt, 8);

  i := 0;
  while i < cnt do
    begin
      stream.write(KDStoreBuff[i].buff[0], SizeOf(TKDT8DC_Vec));
      stream.write(KDStoreBuff[i].Index, 8);
      token_B := KDStoreBuff[i].Token.Bytes;
      token_L := length(token_B);
      stream.write(token_L, 4);
      if token_L > 0 then
        begin
          stream.write(token_B[0], token_L);
          SetLength(token_B, 0);
        end;
      Inc(i);
    end;
end;

procedure TKDT8DC.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  Clear;

  stream.read(st, 4);
  stream.read(ID, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if ID <> KDT8DC_Axis then
      RaiseInfo('kdtree axis error!');

  stream.read(cnt, 8);

  SetLength(KDStoreBuff, cnt);

  i := 0;
  try
    while i < cnt do
      begin
        if stream.read(KDStoreBuff[i].buff[0], SizeOf(TKDT8DC_Vec)) <> SizeOf(TKDT8DC_Vec) then
          begin
            Clear;
            Exit;
          end;
        if stream.read(KDStoreBuff[i].Index, 8) <> 8 then
          begin
            Clear;
            Exit;
          end;
        if stream.read(token_L, 4) <> 4 then
          begin
            Clear;
            Exit;
          end;
        if token_L > 0 then
          begin
            SetLength(token_B, token_L);
            if stream.read(token_B[0], token_L) <> token_L then
              begin
                Clear;
                Exit;
              end;
            KDStoreBuff[i].Token.Bytes := token_B;
            SetLength(token_B, 0);
          end
        else
            KDStoreBuff[i].Token := '';
        Inc(i);
      end;
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      Inc(i);
    end;

  if cnt > 0 then
      RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT8DC.SaveToFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(FileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT8DC.LoadFromFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT8DC.PrintNodeTree(const NodePtr: PKDT8DC_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT8DC_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.Vec^.Index, Vec(p^.Vec^.buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT8DC.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d - %d : %s ', [i, KDStoreBuff[i].Index, Vec(KDStoreBuff[i].buff)]);
end;

class function TKDT8DC.Vec(const s: SystemString): TKDT8DC_Vec;
var
  t: TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j: NativeInt;
begin
  for i := 0 to KDT8DC_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            Inc(j);
            if j >= KDT8DC_Axis then
                Break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT8DC.Vec(const v: TKDT8DC_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT8DC_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT8DC.Distance(const v1, v2: TKDT8DC_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT8DC_Axis - 1 do
      Result := Result + (v2[i] - v1[i]) * (v2[i] - v1[i]);
end;

procedure TKDT8DC.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT8DC_Source; const Data: Pointer);
begin
  Source.buff := TestBuff[IndexFor];
  Source.Token := umlIntToStr(IndexFor);
end;

class procedure TKDT8DC.Test;
var
  TKDT8DC_Test: TKDT8DC;
  t: TTimeTick;
  i, j: NativeInt;
  TestResultBuff: TKDT8DC_DynamicVecBuffer;
  TestResultIndex: TKMIntegerArray;
  KMeanOutIndex: TKMIntegerArray;
  errored: Boolean;
  m64: TMemoryStream64;
  p: PKDT8DC_Node;
  n: TPascalString;
begin
  errored := False;
  n := PFormat('test %s...', [ClassName]);
  t := GetTimeTick;

  n.Append('...build');
  TKDT8DC_Test := TKDT8DC.Create;

  n.Append('...');
  SetLength(TKDT8DC_Test.TestBuff, 1000);
  for i := 0 to length(TKDT8DC_Test.TestBuff) - 1 do
    for j := 0 to KDT8DC_Axis - 1 do
        TKDT8DC_Test.TestBuff[i][j] := i * KDT8DC_Axis + j;

{$IFDEF FPC}
  TKDT8DC_Test.BuildKDTreeM(length(TKDT8DC_Test.TestBuff), nil, @TKDT8DC_Test.Test_BuildM);
{$ELSE FPC}
  TKDT8DC_Test.BuildKDTreeM(length(TKDT8DC_Test.TestBuff), nil, TKDT8DC_Test.Test_BuildM);
{$ENDIF FPC}
  { save/load test }
  n.Append('...save/load');
  m64 := TMemoryStream64.CustomCreate(1024 * 1024);
  TKDT8DC_Test.SaveToStream(m64);
  m64.Position := 0;
  TKDT8DC_Test.LoadFromStream(m64);
  for i := 0 to length(TKDT8DC_Test.TestBuff) - 1 do
    begin
      p := TKDT8DC_Test.Search(TKDT8DC_Test.TestBuff[i]);
      if p^.Vec^.Index <> i then
          errored := True;
      if not p^.Vec^.Token.Same(umlIntToStr(i)) then
          errored := True;
      if errored then
          Break;
    end;
  DisposeObject(m64);

  if not errored then
    begin
      { parallel search test }
      n.Append('...parallel');
      SetLength(TestResultBuff, length(TKDT8DC_Test.TestBuff));
      SetLength(TestResultIndex, length(TKDT8DC_Test.TestBuff));
      TKDT8DC_Test.Search(TKDT8DC_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if Distance(TKDT8DC_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
            errored := True;
    end;

  if not errored then
    begin
      n.Append('...kMean');
      TKDT8DC_Test.Clear;
      { kMean test }
      TKDT8DC_Test.BuildKDTreeWithCluster(TKDT8DC_Test.TestBuff, 10, 1, KMeanOutIndex);
      { parallel search test }
      TKDT8DC_Test.Search(TKDT8DC_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if TestResultIndex[i] <> KMeanOutIndex[i] then
            errored := True;
    end;

  SetLength(TKDT8DC_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT8DC_Test.Clear;

  n.Append('...');
  if errored then
      n.Append('error!')
  else
      n.Append('passed ok %dms', [GetTimeTick - t]);
  DisposeObject(TKDT8DC_Test);
  DoStatus(n);
  n := '';
end;

function TKDT9DC.InternalBuildKdTree(const KDSourceBufferPtr: PKDT9DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT9DC_Node;
  function SortCompare(const p1, p2: PKDT9DC_Source; const axis: NativeInt): ShortInt;
  begin
    if p1^.buff[axis] = p2^.buff[axis] then
      begin
        if p1^.Index = p2^.Index then
            Result := 0
        else if p1^.Index < p2^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.buff[axis] < p2^.buff[axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT9DC_SourceBuffer; L, R: NativeInt; const axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT9DC_Source;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer^[(L + R) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, axis) < 0 do
            Inc(i);
        while SortCompare(SortBuffer^[j], p, axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, axis);
      L := i;
    until i >= R;
  end;

var
  M: NativeInt;
  axis: NativeInt;
  kdBuffPtr: PKDT9DC_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      new(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.Vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);
    end
  else
    begin
      axis := Depth mod KDT9DC_Axis;
      M := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr^[0], 0, PlanCount - 1, axis);

      new(Result);
      Result^.Parent := nil;
      Result^.Vec := kdBuffPtr^[M];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], M, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[M + 1], PlanCount - (M + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT9DC.GetData(const Index: NativeInt): PKDT9DC_Source;
begin
  Result := @KDStoreBuff[Index];
end;

constructor TKDT9DC.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT9DC.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT9DC.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT9DC_Node(KDNodes[i]));
      Inc(i);
    end;

  for i := 0 to length(KDStoreBuff) - 1 do
      KDStoreBuff[i].Token := '';

  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT9DC.StoreBuffPtr: PKDT9DC_DyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT9DC.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT9DC_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT9DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT9DC.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT9DC_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT9DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT9DC.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT9DC_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT9DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{ k-means++ clusterization }
procedure TKDT9DC.BuildKDTreeWithCluster(const inBuff: TKDT9DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  SetLength(Source, length(inBuff), KDT9DC_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT9DC_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT9DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT9DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT9DC.BuildKDTreeWithCluster(const inBuff: TKDT9DC_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TKMIntegerArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT9DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT9DC_BuildCall);
var
  TempStoreBuff: TKDT9DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT9DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT9DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT9DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT9DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT9DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT9DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT9DC_BuildMethod);
var
  TempStoreBuff: TKDT9DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT9DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT9DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT9DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT9DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT9DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT9DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT9DC_BuildProc);
var
  TempStoreBuff: TKDT9DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT9DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT9DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT9DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT9DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT9DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

function TKDT9DC.Search(const buff: TKDT9DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT9DC_Node;

var
  NearestNeighbour: PKDT9DC_Node;

  function FindParentNode(const buffPtr: PKDT9DC_Vec; NodePtr: PKDT9DC_Node): PKDT9DC_Node;
  var
    Next: PKDT9DC_Node;
    Depth, axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        axis := Depth mod KDT9DC_Axis;
        if buffPtr^[axis] > Next^.Vec^.buff[axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT9DC_Node; const buffPtr: PKDT9DC_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    Inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := Distance(buffPtr^, NodePtr^.Vec^.buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.Vec^.Index < NearestNeighbour^.Vec^.Index) then
        NearestNeighbour := NodePtr;

    axis := Depth mod KDT9DC_Axis;
    Dist := NodePtr^.Vec^.buff[axis] - buffPtr^[axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.Vec^.buff[axis] > buffPtr^[axis] then
            ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const buffPtr: PKDT9DC_Vec; const p1, p2: PKDT9DC_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := Distance(buffPtr^, p1^.Vec^.buff);
    d2 := Distance(buffPtr^, p2^.Vec^.buff);
    if d1 = d2 then
      begin
        if p1^.Vec^.Index = p2^.Vec^.Index then
            Result := 0
        else if p1^.Vec^.Index < p2^.Vec^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; L, R: NativeInt; const buffPtr: PKDT9DC_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT9DC_Node;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer[(L + R) shr 1];
      repeat
        while SortCompare(buffPtr, SortBuffer[i], p) < 0 do
            Inc(i);
        while SortCompare(buffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, buffPtr);
      L := i;
    until i >= R;
  end;

var
  Parent: PKDT9DC_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := Distance(buff, Parent^.Vec^.buff);

  ScanSubtree(RootNode, @buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT9DC_Node(NearestNodes[0]);
    end;
end;

function TKDT9DC.Search(const buff: TKDT9DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT9DC_Node;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT9DC.Search(const buff: TKDT9DC_Vec; var SearchedDistanceMin: Double): PKDT9DC_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT9DC.Search(const buff: TKDT9DC_Vec): PKDT9DC_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT9DC.SearchToken(const buff: TKDT9DC_Vec): TPascalString;
var
  p: PKDT9DC_Node;
begin
  p := Search(buff);
  if p <> nil then
      Result := p^.Vec^.Token
  else
      Result := '';
end;

procedure TKDT9DC.Search(const inBuff: TKDT9DC_DynamicVecBuffer; var OutBuff: TKDT9DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT9DC_DynamicVecBuffer;
  outBuffPtr: PKDT9DC_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT9DC_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outBuffPtr^[pass] := p^.Vec^.buff;
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT9DC_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outBuffPtr^[pass] := p^.Vec^.buff;
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT9DC_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.Vec^.buff;
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT9DC.Search(const inBuff: TKDT9DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT9DC_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT9DC_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT9DC_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT9DC_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT9DC.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  ID := KDT9DC_Axis;

  stream.write(st, 4);
  stream.write(ID, 4);

  stream.write(cnt, 8);

  i := 0;
  while i < cnt do
    begin
      stream.write(KDStoreBuff[i].buff[0], SizeOf(TKDT9DC_Vec));
      stream.write(KDStoreBuff[i].Index, 8);
      token_B := KDStoreBuff[i].Token.Bytes;
      token_L := length(token_B);
      stream.write(token_L, 4);
      if token_L > 0 then
        begin
          stream.write(token_B[0], token_L);
          SetLength(token_B, 0);
        end;
      Inc(i);
    end;
end;

procedure TKDT9DC.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  Clear;

  stream.read(st, 4);
  stream.read(ID, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if ID <> KDT9DC_Axis then
      RaiseInfo('kdtree axis error!');

  stream.read(cnt, 8);

  SetLength(KDStoreBuff, cnt);

  i := 0;
  try
    while i < cnt do
      begin
        if stream.read(KDStoreBuff[i].buff[0], SizeOf(TKDT9DC_Vec)) <> SizeOf(TKDT9DC_Vec) then
          begin
            Clear;
            Exit;
          end;
        if stream.read(KDStoreBuff[i].Index, 8) <> 8 then
          begin
            Clear;
            Exit;
          end;
        if stream.read(token_L, 4) <> 4 then
          begin
            Clear;
            Exit;
          end;
        if token_L > 0 then
          begin
            SetLength(token_B, token_L);
            if stream.read(token_B[0], token_L) <> token_L then
              begin
                Clear;
                Exit;
              end;
            KDStoreBuff[i].Token.Bytes := token_B;
            SetLength(token_B, 0);
          end
        else
            KDStoreBuff[i].Token := '';
        Inc(i);
      end;
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      Inc(i);
    end;

  if cnt > 0 then
      RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT9DC.SaveToFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(FileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT9DC.LoadFromFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT9DC.PrintNodeTree(const NodePtr: PKDT9DC_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT9DC_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.Vec^.Index, Vec(p^.Vec^.buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT9DC.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d - %d : %s ', [i, KDStoreBuff[i].Index, Vec(KDStoreBuff[i].buff)]);
end;

class function TKDT9DC.Vec(const s: SystemString): TKDT9DC_Vec;
var
  t: TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j: NativeInt;
begin
  for i := 0 to KDT9DC_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            Inc(j);
            if j >= KDT9DC_Axis then
                Break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT9DC.Vec(const v: TKDT9DC_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT9DC_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT9DC.Distance(const v1, v2: TKDT9DC_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT9DC_Axis - 1 do
      Result := Result + (v2[i] - v1[i]) * (v2[i] - v1[i]);
end;

procedure TKDT9DC.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT9DC_Source; const Data: Pointer);
begin
  Source.buff := TestBuff[IndexFor];
  Source.Token := umlIntToStr(IndexFor);
end;

class procedure TKDT9DC.Test;
var
  TKDT9DC_Test: TKDT9DC;
  t: TTimeTick;
  i, j: NativeInt;
  TestResultBuff: TKDT9DC_DynamicVecBuffer;
  TestResultIndex: TKMIntegerArray;
  KMeanOutIndex: TKMIntegerArray;
  errored: Boolean;
  m64: TMemoryStream64;
  p: PKDT9DC_Node;
  n: TPascalString;
begin
  errored := False;
  n := PFormat('test %s...', [ClassName]);
  t := GetTimeTick;

  n.Append('...build');
  TKDT9DC_Test := TKDT9DC.Create;

  n.Append('...');
  SetLength(TKDT9DC_Test.TestBuff, 1000);
  for i := 0 to length(TKDT9DC_Test.TestBuff) - 1 do
    for j := 0 to KDT9DC_Axis - 1 do
        TKDT9DC_Test.TestBuff[i][j] := i * KDT9DC_Axis + j;

{$IFDEF FPC}
  TKDT9DC_Test.BuildKDTreeM(length(TKDT9DC_Test.TestBuff), nil, @TKDT9DC_Test.Test_BuildM);
{$ELSE FPC}
  TKDT9DC_Test.BuildKDTreeM(length(TKDT9DC_Test.TestBuff), nil, TKDT9DC_Test.Test_BuildM);
{$ENDIF FPC}
  { save/load test }
  n.Append('...save/load');
  m64 := TMemoryStream64.CustomCreate(1024 * 1024);
  TKDT9DC_Test.SaveToStream(m64);
  m64.Position := 0;
  TKDT9DC_Test.LoadFromStream(m64);
  for i := 0 to length(TKDT9DC_Test.TestBuff) - 1 do
    begin
      p := TKDT9DC_Test.Search(TKDT9DC_Test.TestBuff[i]);
      if p^.Vec^.Index <> i then
          errored := True;
      if not p^.Vec^.Token.Same(umlIntToStr(i)) then
          errored := True;
      if errored then
          Break;
    end;
  DisposeObject(m64);

  if not errored then
    begin
      { parallel search test }
      n.Append('...parallel');
      SetLength(TestResultBuff, length(TKDT9DC_Test.TestBuff));
      SetLength(TestResultIndex, length(TKDT9DC_Test.TestBuff));
      TKDT9DC_Test.Search(TKDT9DC_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if Distance(TKDT9DC_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
            errored := True;
    end;

  if not errored then
    begin
      n.Append('...kMean');
      TKDT9DC_Test.Clear;
      { kMean test }
      TKDT9DC_Test.BuildKDTreeWithCluster(TKDT9DC_Test.TestBuff, 10, 1, KMeanOutIndex);
      { parallel search test }
      TKDT9DC_Test.Search(TKDT9DC_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if TestResultIndex[i] <> KMeanOutIndex[i] then
            errored := True;
    end;

  SetLength(TKDT9DC_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT9DC_Test.Clear;

  n.Append('...');
  if errored then
      n.Append('error!')
  else
      n.Append('passed ok %dms', [GetTimeTick - t]);
  DisposeObject(TKDT9DC_Test);
  DoStatus(n);
  n := '';
end;

function TKDT10DC.InternalBuildKdTree(const KDSourceBufferPtr: PKDT10DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT10DC_Node;
  function SortCompare(const p1, p2: PKDT10DC_Source; const axis: NativeInt): ShortInt;
  begin
    if p1^.buff[axis] = p2^.buff[axis] then
      begin
        if p1^.Index = p2^.Index then
            Result := 0
        else if p1^.Index < p2^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.buff[axis] < p2^.buff[axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT10DC_SourceBuffer; L, R: NativeInt; const axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT10DC_Source;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer^[(L + R) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, axis) < 0 do
            Inc(i);
        while SortCompare(SortBuffer^[j], p, axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, axis);
      L := i;
    until i >= R;
  end;

var
  M: NativeInt;
  axis: NativeInt;
  kdBuffPtr: PKDT10DC_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      new(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.Vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);
    end
  else
    begin
      axis := Depth mod KDT10DC_Axis;
      M := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr^[0], 0, PlanCount - 1, axis);

      new(Result);
      Result^.Parent := nil;
      Result^.Vec := kdBuffPtr^[M];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], M, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[M + 1], PlanCount - (M + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT10DC.GetData(const Index: NativeInt): PKDT10DC_Source;
begin
  Result := @KDStoreBuff[Index];
end;

constructor TKDT10DC.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT10DC.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT10DC.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT10DC_Node(KDNodes[i]));
      Inc(i);
    end;

  for i := 0 to length(KDStoreBuff) - 1 do
      KDStoreBuff[i].Token := '';

  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT10DC.StoreBuffPtr: PKDT10DC_DyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT10DC.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT10DC_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT10DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT10DC.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT10DC_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT10DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT10DC.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT10DC_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT10DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{ k-means++ clusterization }
procedure TKDT10DC.BuildKDTreeWithCluster(const inBuff: TKDT10DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  SetLength(Source, length(inBuff), KDT10DC_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT10DC_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT10DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT10DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT10DC.BuildKDTreeWithCluster(const inBuff: TKDT10DC_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TKMIntegerArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT10DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT10DC_BuildCall);
var
  TempStoreBuff: TKDT10DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT10DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT10DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT10DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT10DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT10DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT10DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT10DC_BuildMethod);
var
  TempStoreBuff: TKDT10DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT10DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT10DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT10DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT10DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT10DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT10DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT10DC_BuildProc);
var
  TempStoreBuff: TKDT10DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT10DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT10DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT10DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT10DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT10DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

function TKDT10DC.Search(const buff: TKDT10DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT10DC_Node;

var
  NearestNeighbour: PKDT10DC_Node;

  function FindParentNode(const buffPtr: PKDT10DC_Vec; NodePtr: PKDT10DC_Node): PKDT10DC_Node;
  var
    Next: PKDT10DC_Node;
    Depth, axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        axis := Depth mod KDT10DC_Axis;
        if buffPtr^[axis] > Next^.Vec^.buff[axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT10DC_Node; const buffPtr: PKDT10DC_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    Inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := Distance(buffPtr^, NodePtr^.Vec^.buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.Vec^.Index < NearestNeighbour^.Vec^.Index) then
        NearestNeighbour := NodePtr;

    axis := Depth mod KDT10DC_Axis;
    Dist := NodePtr^.Vec^.buff[axis] - buffPtr^[axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.Vec^.buff[axis] > buffPtr^[axis] then
            ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const buffPtr: PKDT10DC_Vec; const p1, p2: PKDT10DC_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := Distance(buffPtr^, p1^.Vec^.buff);
    d2 := Distance(buffPtr^, p2^.Vec^.buff);
    if d1 = d2 then
      begin
        if p1^.Vec^.Index = p2^.Vec^.Index then
            Result := 0
        else if p1^.Vec^.Index < p2^.Vec^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; L, R: NativeInt; const buffPtr: PKDT10DC_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT10DC_Node;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer[(L + R) shr 1];
      repeat
        while SortCompare(buffPtr, SortBuffer[i], p) < 0 do
            Inc(i);
        while SortCompare(buffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, buffPtr);
      L := i;
    until i >= R;
  end;

var
  Parent: PKDT10DC_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := Distance(buff, Parent^.Vec^.buff);

  ScanSubtree(RootNode, @buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT10DC_Node(NearestNodes[0]);
    end;
end;

function TKDT10DC.Search(const buff: TKDT10DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT10DC_Node;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT10DC.Search(const buff: TKDT10DC_Vec; var SearchedDistanceMin: Double): PKDT10DC_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT10DC.Search(const buff: TKDT10DC_Vec): PKDT10DC_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT10DC.SearchToken(const buff: TKDT10DC_Vec): TPascalString;
var
  p: PKDT10DC_Node;
begin
  p := Search(buff);
  if p <> nil then
      Result := p^.Vec^.Token
  else
      Result := '';
end;

procedure TKDT10DC.Search(const inBuff: TKDT10DC_DynamicVecBuffer; var OutBuff: TKDT10DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT10DC_DynamicVecBuffer;
  outBuffPtr: PKDT10DC_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT10DC_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outBuffPtr^[pass] := p^.Vec^.buff;
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT10DC_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outBuffPtr^[pass] := p^.Vec^.buff;
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT10DC_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.Vec^.buff;
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT10DC.Search(const inBuff: TKDT10DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT10DC_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT10DC_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT10DC_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT10DC_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT10DC.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  ID := KDT10DC_Axis;

  stream.write(st, 4);
  stream.write(ID, 4);

  stream.write(cnt, 8);

  i := 0;
  while i < cnt do
    begin
      stream.write(KDStoreBuff[i].buff[0], SizeOf(TKDT10DC_Vec));
      stream.write(KDStoreBuff[i].Index, 8);
      token_B := KDStoreBuff[i].Token.Bytes;
      token_L := length(token_B);
      stream.write(token_L, 4);
      if token_L > 0 then
        begin
          stream.write(token_B[0], token_L);
          SetLength(token_B, 0);
        end;
      Inc(i);
    end;
end;

procedure TKDT10DC.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  Clear;

  stream.read(st, 4);
  stream.read(ID, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if ID <> KDT10DC_Axis then
      RaiseInfo('kdtree axis error!');

  stream.read(cnt, 8);

  SetLength(KDStoreBuff, cnt);

  i := 0;
  try
    while i < cnt do
      begin
        if stream.read(KDStoreBuff[i].buff[0], SizeOf(TKDT10DC_Vec)) <> SizeOf(TKDT10DC_Vec) then
          begin
            Clear;
            Exit;
          end;
        if stream.read(KDStoreBuff[i].Index, 8) <> 8 then
          begin
            Clear;
            Exit;
          end;
        if stream.read(token_L, 4) <> 4 then
          begin
            Clear;
            Exit;
          end;
        if token_L > 0 then
          begin
            SetLength(token_B, token_L);
            if stream.read(token_B[0], token_L) <> token_L then
              begin
                Clear;
                Exit;
              end;
            KDStoreBuff[i].Token.Bytes := token_B;
            SetLength(token_B, 0);
          end
        else
            KDStoreBuff[i].Token := '';
        Inc(i);
      end;
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      Inc(i);
    end;

  if cnt > 0 then
      RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT10DC.SaveToFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(FileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT10DC.LoadFromFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT10DC.PrintNodeTree(const NodePtr: PKDT10DC_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT10DC_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.Vec^.Index, Vec(p^.Vec^.buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT10DC.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d - %d : %s ', [i, KDStoreBuff[i].Index, Vec(KDStoreBuff[i].buff)]);
end;

class function TKDT10DC.Vec(const s: SystemString): TKDT10DC_Vec;
var
  t: TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j: NativeInt;
begin
  for i := 0 to KDT10DC_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            Inc(j);
            if j >= KDT10DC_Axis then
                Break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT10DC.Vec(const v: TKDT10DC_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT10DC_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT10DC.Distance(const v1, v2: TKDT10DC_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT10DC_Axis - 1 do
      Result := Result + (v2[i] - v1[i]) * (v2[i] - v1[i]);
end;

procedure TKDT10DC.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT10DC_Source; const Data: Pointer);
begin
  Source.buff := TestBuff[IndexFor];
  Source.Token := umlIntToStr(IndexFor);
end;

class procedure TKDT10DC.Test;
var
  TKDT10DC_Test: TKDT10DC;
  t: TTimeTick;
  i, j: NativeInt;
  TestResultBuff: TKDT10DC_DynamicVecBuffer;
  TestResultIndex: TKMIntegerArray;
  KMeanOutIndex: TKMIntegerArray;
  errored: Boolean;
  m64: TMemoryStream64;
  p: PKDT10DC_Node;
  n: TPascalString;
begin
  errored := False;
  n := PFormat('test %s...', [ClassName]);
  t := GetTimeTick;

  n.Append('...build');
  TKDT10DC_Test := TKDT10DC.Create;

  n.Append('...');
  SetLength(TKDT10DC_Test.TestBuff, 1000);
  for i := 0 to length(TKDT10DC_Test.TestBuff) - 1 do
    for j := 0 to KDT10DC_Axis - 1 do
        TKDT10DC_Test.TestBuff[i][j] := i * KDT10DC_Axis + j;

{$IFDEF FPC}
  TKDT10DC_Test.BuildKDTreeM(length(TKDT10DC_Test.TestBuff), nil, @TKDT10DC_Test.Test_BuildM);
{$ELSE FPC}
  TKDT10DC_Test.BuildKDTreeM(length(TKDT10DC_Test.TestBuff), nil, TKDT10DC_Test.Test_BuildM);
{$ENDIF FPC}
  { save/load test }
  n.Append('...save/load');
  m64 := TMemoryStream64.CustomCreate(1024 * 1024);
  TKDT10DC_Test.SaveToStream(m64);
  m64.Position := 0;
  TKDT10DC_Test.LoadFromStream(m64);
  for i := 0 to length(TKDT10DC_Test.TestBuff) - 1 do
    begin
      p := TKDT10DC_Test.Search(TKDT10DC_Test.TestBuff[i]);
      if p^.Vec^.Index <> i then
          errored := True;
      if not p^.Vec^.Token.Same(umlIntToStr(i)) then
          errored := True;
      if errored then
          Break;
    end;
  DisposeObject(m64);

  if not errored then
    begin
      { parallel search test }
      n.Append('...parallel');
      SetLength(TestResultBuff, length(TKDT10DC_Test.TestBuff));
      SetLength(TestResultIndex, length(TKDT10DC_Test.TestBuff));
      TKDT10DC_Test.Search(TKDT10DC_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if Distance(TKDT10DC_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
            errored := True;
    end;

  if not errored then
    begin
      n.Append('...kMean');
      TKDT10DC_Test.Clear;
      { kMean test }
      TKDT10DC_Test.BuildKDTreeWithCluster(TKDT10DC_Test.TestBuff, 10, 1, KMeanOutIndex);
      { parallel search test }
      TKDT10DC_Test.Search(TKDT10DC_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if TestResultIndex[i] <> KMeanOutIndex[i] then
            errored := True;
    end;

  SetLength(TKDT10DC_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT10DC_Test.Clear;

  n.Append('...');
  if errored then
      n.Append('error!')
  else
      n.Append('passed ok %dms', [GetTimeTick - t]);
  DisposeObject(TKDT10DC_Test);
  DoStatus(n);
  n := '';
end;

function TKDT11DC.InternalBuildKdTree(const KDSourceBufferPtr: PKDT11DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT11DC_Node;
  function SortCompare(const p1, p2: PKDT11DC_Source; const axis: NativeInt): ShortInt;
  begin
    if p1^.buff[axis] = p2^.buff[axis] then
      begin
        if p1^.Index = p2^.Index then
            Result := 0
        else if p1^.Index < p2^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.buff[axis] < p2^.buff[axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT11DC_SourceBuffer; L, R: NativeInt; const axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT11DC_Source;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer^[(L + R) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, axis) < 0 do
            Inc(i);
        while SortCompare(SortBuffer^[j], p, axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, axis);
      L := i;
    until i >= R;
  end;

var
  M: NativeInt;
  axis: NativeInt;
  kdBuffPtr: PKDT11DC_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      new(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.Vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);
    end
  else
    begin
      axis := Depth mod KDT11DC_Axis;
      M := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr^[0], 0, PlanCount - 1, axis);

      new(Result);
      Result^.Parent := nil;
      Result^.Vec := kdBuffPtr^[M];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], M, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[M + 1], PlanCount - (M + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT11DC.GetData(const Index: NativeInt): PKDT11DC_Source;
begin
  Result := @KDStoreBuff[Index];
end;

constructor TKDT11DC.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT11DC.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT11DC.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT11DC_Node(KDNodes[i]));
      Inc(i);
    end;

  for i := 0 to length(KDStoreBuff) - 1 do
      KDStoreBuff[i].Token := '';

  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT11DC.StoreBuffPtr: PKDT11DC_DyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT11DC.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT11DC_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT11DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT11DC.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT11DC_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT11DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT11DC.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT11DC_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT11DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{ k-means++ clusterization }
procedure TKDT11DC.BuildKDTreeWithCluster(const inBuff: TKDT11DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  SetLength(Source, length(inBuff), KDT11DC_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT11DC_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT11DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT11DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT11DC.BuildKDTreeWithCluster(const inBuff: TKDT11DC_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TKMIntegerArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT11DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT11DC_BuildCall);
var
  TempStoreBuff: TKDT11DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT11DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT11DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT11DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT11DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT11DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT11DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT11DC_BuildMethod);
var
  TempStoreBuff: TKDT11DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT11DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT11DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT11DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT11DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT11DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT11DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT11DC_BuildProc);
var
  TempStoreBuff: TKDT11DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT11DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT11DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT11DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT11DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT11DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

function TKDT11DC.Search(const buff: TKDT11DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT11DC_Node;

var
  NearestNeighbour: PKDT11DC_Node;

  function FindParentNode(const buffPtr: PKDT11DC_Vec; NodePtr: PKDT11DC_Node): PKDT11DC_Node;
  var
    Next: PKDT11DC_Node;
    Depth, axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        axis := Depth mod KDT11DC_Axis;
        if buffPtr^[axis] > Next^.Vec^.buff[axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT11DC_Node; const buffPtr: PKDT11DC_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    Inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := Distance(buffPtr^, NodePtr^.Vec^.buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.Vec^.Index < NearestNeighbour^.Vec^.Index) then
        NearestNeighbour := NodePtr;

    axis := Depth mod KDT11DC_Axis;
    Dist := NodePtr^.Vec^.buff[axis] - buffPtr^[axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.Vec^.buff[axis] > buffPtr^[axis] then
            ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const buffPtr: PKDT11DC_Vec; const p1, p2: PKDT11DC_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := Distance(buffPtr^, p1^.Vec^.buff);
    d2 := Distance(buffPtr^, p2^.Vec^.buff);
    if d1 = d2 then
      begin
        if p1^.Vec^.Index = p2^.Vec^.Index then
            Result := 0
        else if p1^.Vec^.Index < p2^.Vec^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; L, R: NativeInt; const buffPtr: PKDT11DC_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT11DC_Node;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer[(L + R) shr 1];
      repeat
        while SortCompare(buffPtr, SortBuffer[i], p) < 0 do
            Inc(i);
        while SortCompare(buffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, buffPtr);
      L := i;
    until i >= R;
  end;

var
  Parent: PKDT11DC_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := Distance(buff, Parent^.Vec^.buff);

  ScanSubtree(RootNode, @buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT11DC_Node(NearestNodes[0]);
    end;
end;

function TKDT11DC.Search(const buff: TKDT11DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT11DC_Node;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT11DC.Search(const buff: TKDT11DC_Vec; var SearchedDistanceMin: Double): PKDT11DC_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT11DC.Search(const buff: TKDT11DC_Vec): PKDT11DC_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT11DC.SearchToken(const buff: TKDT11DC_Vec): TPascalString;
var
  p: PKDT11DC_Node;
begin
  p := Search(buff);
  if p <> nil then
      Result := p^.Vec^.Token
  else
      Result := '';
end;

procedure TKDT11DC.Search(const inBuff: TKDT11DC_DynamicVecBuffer; var OutBuff: TKDT11DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT11DC_DynamicVecBuffer;
  outBuffPtr: PKDT11DC_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT11DC_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outBuffPtr^[pass] := p^.Vec^.buff;
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT11DC_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outBuffPtr^[pass] := p^.Vec^.buff;
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT11DC_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.Vec^.buff;
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT11DC.Search(const inBuff: TKDT11DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT11DC_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT11DC_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT11DC_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT11DC_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT11DC.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  ID := KDT11DC_Axis;

  stream.write(st, 4);
  stream.write(ID, 4);

  stream.write(cnt, 8);

  i := 0;
  while i < cnt do
    begin
      stream.write(KDStoreBuff[i].buff[0], SizeOf(TKDT11DC_Vec));
      stream.write(KDStoreBuff[i].Index, 8);
      token_B := KDStoreBuff[i].Token.Bytes;
      token_L := length(token_B);
      stream.write(token_L, 4);
      if token_L > 0 then
        begin
          stream.write(token_B[0], token_L);
          SetLength(token_B, 0);
        end;
      Inc(i);
    end;
end;

procedure TKDT11DC.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  Clear;

  stream.read(st, 4);
  stream.read(ID, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if ID <> KDT11DC_Axis then
      RaiseInfo('kdtree axis error!');

  stream.read(cnt, 8);

  SetLength(KDStoreBuff, cnt);

  i := 0;
  try
    while i < cnt do
      begin
        if stream.read(KDStoreBuff[i].buff[0], SizeOf(TKDT11DC_Vec)) <> SizeOf(TKDT11DC_Vec) then
          begin
            Clear;
            Exit;
          end;
        if stream.read(KDStoreBuff[i].Index, 8) <> 8 then
          begin
            Clear;
            Exit;
          end;
        if stream.read(token_L, 4) <> 4 then
          begin
            Clear;
            Exit;
          end;
        if token_L > 0 then
          begin
            SetLength(token_B, token_L);
            if stream.read(token_B[0], token_L) <> token_L then
              begin
                Clear;
                Exit;
              end;
            KDStoreBuff[i].Token.Bytes := token_B;
            SetLength(token_B, 0);
          end
        else
            KDStoreBuff[i].Token := '';
        Inc(i);
      end;
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      Inc(i);
    end;

  if cnt > 0 then
      RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT11DC.SaveToFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(FileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT11DC.LoadFromFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT11DC.PrintNodeTree(const NodePtr: PKDT11DC_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT11DC_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.Vec^.Index, Vec(p^.Vec^.buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT11DC.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d - %d : %s ', [i, KDStoreBuff[i].Index, Vec(KDStoreBuff[i].buff)]);
end;

class function TKDT11DC.Vec(const s: SystemString): TKDT11DC_Vec;
var
  t: TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j: NativeInt;
begin
  for i := 0 to KDT11DC_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            Inc(j);
            if j >= KDT11DC_Axis then
                Break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT11DC.Vec(const v: TKDT11DC_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT11DC_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT11DC.Distance(const v1, v2: TKDT11DC_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT11DC_Axis - 1 do
      Result := Result + (v2[i] - v1[i]) * (v2[i] - v1[i]);
end;

procedure TKDT11DC.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT11DC_Source; const Data: Pointer);
begin
  Source.buff := TestBuff[IndexFor];
  Source.Token := umlIntToStr(IndexFor);
end;

class procedure TKDT11DC.Test;
var
  TKDT11DC_Test: TKDT11DC;
  t: TTimeTick;
  i, j: NativeInt;
  TestResultBuff: TKDT11DC_DynamicVecBuffer;
  TestResultIndex: TKMIntegerArray;
  KMeanOutIndex: TKMIntegerArray;
  errored: Boolean;
  m64: TMemoryStream64;
  p: PKDT11DC_Node;
  n: TPascalString;
begin
  errored := False;
  n := PFormat('test %s...', [ClassName]);
  t := GetTimeTick;

  n.Append('...build');
  TKDT11DC_Test := TKDT11DC.Create;

  n.Append('...');
  SetLength(TKDT11DC_Test.TestBuff, 1000);
  for i := 0 to length(TKDT11DC_Test.TestBuff) - 1 do
    for j := 0 to KDT11DC_Axis - 1 do
        TKDT11DC_Test.TestBuff[i][j] := i * KDT11DC_Axis + j;

{$IFDEF FPC}
  TKDT11DC_Test.BuildKDTreeM(length(TKDT11DC_Test.TestBuff), nil, @TKDT11DC_Test.Test_BuildM);
{$ELSE FPC}
  TKDT11DC_Test.BuildKDTreeM(length(TKDT11DC_Test.TestBuff), nil, TKDT11DC_Test.Test_BuildM);
{$ENDIF FPC}
  { save/load test }
  n.Append('...save/load');
  m64 := TMemoryStream64.CustomCreate(1024 * 1024);
  TKDT11DC_Test.SaveToStream(m64);
  m64.Position := 0;
  TKDT11DC_Test.LoadFromStream(m64);
  for i := 0 to length(TKDT11DC_Test.TestBuff) - 1 do
    begin
      p := TKDT11DC_Test.Search(TKDT11DC_Test.TestBuff[i]);
      if p^.Vec^.Index <> i then
          errored := True;
      if not p^.Vec^.Token.Same(umlIntToStr(i)) then
          errored := True;
      if errored then
          Break;
    end;
  DisposeObject(m64);

  if not errored then
    begin
      { parallel search test }
      n.Append('...parallel');
      SetLength(TestResultBuff, length(TKDT11DC_Test.TestBuff));
      SetLength(TestResultIndex, length(TKDT11DC_Test.TestBuff));
      TKDT11DC_Test.Search(TKDT11DC_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if Distance(TKDT11DC_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
            errored := True;
    end;

  if not errored then
    begin
      n.Append('...kMean');
      TKDT11DC_Test.Clear;
      { kMean test }
      TKDT11DC_Test.BuildKDTreeWithCluster(TKDT11DC_Test.TestBuff, 10, 1, KMeanOutIndex);
      { parallel search test }
      TKDT11DC_Test.Search(TKDT11DC_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if TestResultIndex[i] <> KMeanOutIndex[i] then
            errored := True;
    end;

  SetLength(TKDT11DC_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT11DC_Test.Clear;

  n.Append('...');
  if errored then
      n.Append('error!')
  else
      n.Append('passed ok %dms', [GetTimeTick - t]);
  DisposeObject(TKDT11DC_Test);
  DoStatus(n);
  n := '';
end;

function TKDT12DC.InternalBuildKdTree(const KDSourceBufferPtr: PKDT12DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT12DC_Node;
  function SortCompare(const p1, p2: PKDT12DC_Source; const axis: NativeInt): ShortInt;
  begin
    if p1^.buff[axis] = p2^.buff[axis] then
      begin
        if p1^.Index = p2^.Index then
            Result := 0
        else if p1^.Index < p2^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.buff[axis] < p2^.buff[axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT12DC_SourceBuffer; L, R: NativeInt; const axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT12DC_Source;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer^[(L + R) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, axis) < 0 do
            Inc(i);
        while SortCompare(SortBuffer^[j], p, axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, axis);
      L := i;
    until i >= R;
  end;

var
  M: NativeInt;
  axis: NativeInt;
  kdBuffPtr: PKDT12DC_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      new(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.Vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);
    end
  else
    begin
      axis := Depth mod KDT12DC_Axis;
      M := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr^[0], 0, PlanCount - 1, axis);

      new(Result);
      Result^.Parent := nil;
      Result^.Vec := kdBuffPtr^[M];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], M, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[M + 1], PlanCount - (M + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT12DC.GetData(const Index: NativeInt): PKDT12DC_Source;
begin
  Result := @KDStoreBuff[Index];
end;

constructor TKDT12DC.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT12DC.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT12DC.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT12DC_Node(KDNodes[i]));
      Inc(i);
    end;

  for i := 0 to length(KDStoreBuff) - 1 do
      KDStoreBuff[i].Token := '';

  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT12DC.StoreBuffPtr: PKDT12DC_DyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT12DC.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT12DC_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT12DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT12DC.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT12DC_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT12DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT12DC.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT12DC_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT12DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{ k-means++ clusterization }
procedure TKDT12DC.BuildKDTreeWithCluster(const inBuff: TKDT12DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  SetLength(Source, length(inBuff), KDT12DC_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT12DC_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT12DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT12DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT12DC.BuildKDTreeWithCluster(const inBuff: TKDT12DC_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TKMIntegerArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT12DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT12DC_BuildCall);
var
  TempStoreBuff: TKDT12DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT12DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT12DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT12DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT12DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT12DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT12DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT12DC_BuildMethod);
var
  TempStoreBuff: TKDT12DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT12DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT12DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT12DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT12DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT12DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT12DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT12DC_BuildProc);
var
  TempStoreBuff: TKDT12DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT12DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT12DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT12DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT12DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT12DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

function TKDT12DC.Search(const buff: TKDT12DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT12DC_Node;

var
  NearestNeighbour: PKDT12DC_Node;

  function FindParentNode(const buffPtr: PKDT12DC_Vec; NodePtr: PKDT12DC_Node): PKDT12DC_Node;
  var
    Next: PKDT12DC_Node;
    Depth, axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        axis := Depth mod KDT12DC_Axis;
        if buffPtr^[axis] > Next^.Vec^.buff[axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT12DC_Node; const buffPtr: PKDT12DC_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    Inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := Distance(buffPtr^, NodePtr^.Vec^.buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.Vec^.Index < NearestNeighbour^.Vec^.Index) then
        NearestNeighbour := NodePtr;

    axis := Depth mod KDT12DC_Axis;
    Dist := NodePtr^.Vec^.buff[axis] - buffPtr^[axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.Vec^.buff[axis] > buffPtr^[axis] then
            ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const buffPtr: PKDT12DC_Vec; const p1, p2: PKDT12DC_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := Distance(buffPtr^, p1^.Vec^.buff);
    d2 := Distance(buffPtr^, p2^.Vec^.buff);
    if d1 = d2 then
      begin
        if p1^.Vec^.Index = p2^.Vec^.Index then
            Result := 0
        else if p1^.Vec^.Index < p2^.Vec^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; L, R: NativeInt; const buffPtr: PKDT12DC_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT12DC_Node;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer[(L + R) shr 1];
      repeat
        while SortCompare(buffPtr, SortBuffer[i], p) < 0 do
            Inc(i);
        while SortCompare(buffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, buffPtr);
      L := i;
    until i >= R;
  end;

var
  Parent: PKDT12DC_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := Distance(buff, Parent^.Vec^.buff);

  ScanSubtree(RootNode, @buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT12DC_Node(NearestNodes[0]);
    end;
end;

function TKDT12DC.Search(const buff: TKDT12DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT12DC_Node;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT12DC.Search(const buff: TKDT12DC_Vec; var SearchedDistanceMin: Double): PKDT12DC_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT12DC.Search(const buff: TKDT12DC_Vec): PKDT12DC_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT12DC.SearchToken(const buff: TKDT12DC_Vec): TPascalString;
var
  p: PKDT12DC_Node;
begin
  p := Search(buff);
  if p <> nil then
      Result := p^.Vec^.Token
  else
      Result := '';
end;

procedure TKDT12DC.Search(const inBuff: TKDT12DC_DynamicVecBuffer; var OutBuff: TKDT12DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT12DC_DynamicVecBuffer;
  outBuffPtr: PKDT12DC_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT12DC_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outBuffPtr^[pass] := p^.Vec^.buff;
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT12DC_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outBuffPtr^[pass] := p^.Vec^.buff;
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT12DC_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.Vec^.buff;
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT12DC.Search(const inBuff: TKDT12DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT12DC_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT12DC_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT12DC_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT12DC_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT12DC.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  ID := KDT12DC_Axis;

  stream.write(st, 4);
  stream.write(ID, 4);

  stream.write(cnt, 8);

  i := 0;
  while i < cnt do
    begin
      stream.write(KDStoreBuff[i].buff[0], SizeOf(TKDT12DC_Vec));
      stream.write(KDStoreBuff[i].Index, 8);
      token_B := KDStoreBuff[i].Token.Bytes;
      token_L := length(token_B);
      stream.write(token_L, 4);
      if token_L > 0 then
        begin
          stream.write(token_B[0], token_L);
          SetLength(token_B, 0);
        end;
      Inc(i);
    end;
end;

procedure TKDT12DC.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  Clear;

  stream.read(st, 4);
  stream.read(ID, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if ID <> KDT12DC_Axis then
      RaiseInfo('kdtree axis error!');

  stream.read(cnt, 8);

  SetLength(KDStoreBuff, cnt);

  i := 0;
  try
    while i < cnt do
      begin
        if stream.read(KDStoreBuff[i].buff[0], SizeOf(TKDT12DC_Vec)) <> SizeOf(TKDT12DC_Vec) then
          begin
            Clear;
            Exit;
          end;
        if stream.read(KDStoreBuff[i].Index, 8) <> 8 then
          begin
            Clear;
            Exit;
          end;
        if stream.read(token_L, 4) <> 4 then
          begin
            Clear;
            Exit;
          end;
        if token_L > 0 then
          begin
            SetLength(token_B, token_L);
            if stream.read(token_B[0], token_L) <> token_L then
              begin
                Clear;
                Exit;
              end;
            KDStoreBuff[i].Token.Bytes := token_B;
            SetLength(token_B, 0);
          end
        else
            KDStoreBuff[i].Token := '';
        Inc(i);
      end;
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      Inc(i);
    end;

  if cnt > 0 then
      RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT12DC.SaveToFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(FileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT12DC.LoadFromFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT12DC.PrintNodeTree(const NodePtr: PKDT12DC_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT12DC_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.Vec^.Index, Vec(p^.Vec^.buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT12DC.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d - %d : %s ', [i, KDStoreBuff[i].Index, Vec(KDStoreBuff[i].buff)]);
end;

class function TKDT12DC.Vec(const s: SystemString): TKDT12DC_Vec;
var
  t: TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j: NativeInt;
begin
  for i := 0 to KDT12DC_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            Inc(j);
            if j >= KDT12DC_Axis then
                Break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT12DC.Vec(const v: TKDT12DC_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT12DC_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT12DC.Distance(const v1, v2: TKDT12DC_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT12DC_Axis - 1 do
      Result := Result + (v2[i] - v1[i]) * (v2[i] - v1[i]);
end;

procedure TKDT12DC.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT12DC_Source; const Data: Pointer);
begin
  Source.buff := TestBuff[IndexFor];
  Source.Token := umlIntToStr(IndexFor);
end;

class procedure TKDT12DC.Test;
var
  TKDT12DC_Test: TKDT12DC;
  t: TTimeTick;
  i, j: NativeInt;
  TestResultBuff: TKDT12DC_DynamicVecBuffer;
  TestResultIndex: TKMIntegerArray;
  KMeanOutIndex: TKMIntegerArray;
  errored: Boolean;
  m64: TMemoryStream64;
  p: PKDT12DC_Node;
  n: TPascalString;
begin
  errored := False;
  n := PFormat('test %s...', [ClassName]);
  t := GetTimeTick;

  n.Append('...build');
  TKDT12DC_Test := TKDT12DC.Create;

  n.Append('...');
  SetLength(TKDT12DC_Test.TestBuff, 1000);
  for i := 0 to length(TKDT12DC_Test.TestBuff) - 1 do
    for j := 0 to KDT12DC_Axis - 1 do
        TKDT12DC_Test.TestBuff[i][j] := i * KDT12DC_Axis + j;

{$IFDEF FPC}
  TKDT12DC_Test.BuildKDTreeM(length(TKDT12DC_Test.TestBuff), nil, @TKDT12DC_Test.Test_BuildM);
{$ELSE FPC}
  TKDT12DC_Test.BuildKDTreeM(length(TKDT12DC_Test.TestBuff), nil, TKDT12DC_Test.Test_BuildM);
{$ENDIF FPC}
  { save/load test }
  n.Append('...save/load');
  m64 := TMemoryStream64.CustomCreate(1024 * 1024);
  TKDT12DC_Test.SaveToStream(m64);
  m64.Position := 0;
  TKDT12DC_Test.LoadFromStream(m64);
  for i := 0 to length(TKDT12DC_Test.TestBuff) - 1 do
    begin
      p := TKDT12DC_Test.Search(TKDT12DC_Test.TestBuff[i]);
      if p^.Vec^.Index <> i then
          errored := True;
      if not p^.Vec^.Token.Same(umlIntToStr(i)) then
          errored := True;
      if errored then
          Break;
    end;
  DisposeObject(m64);

  if not errored then
    begin
      { parallel search test }
      n.Append('...parallel');
      SetLength(TestResultBuff, length(TKDT12DC_Test.TestBuff));
      SetLength(TestResultIndex, length(TKDT12DC_Test.TestBuff));
      TKDT12DC_Test.Search(TKDT12DC_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if Distance(TKDT12DC_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
            errored := True;
    end;

  if not errored then
    begin
      n.Append('...kMean');
      TKDT12DC_Test.Clear;
      { kMean test }
      TKDT12DC_Test.BuildKDTreeWithCluster(TKDT12DC_Test.TestBuff, 10, 1, KMeanOutIndex);
      { parallel search test }
      TKDT12DC_Test.Search(TKDT12DC_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if TestResultIndex[i] <> KMeanOutIndex[i] then
            errored := True;
    end;

  SetLength(TKDT12DC_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT12DC_Test.Clear;

  n.Append('...');
  if errored then
      n.Append('error!')
  else
      n.Append('passed ok %dms', [GetTimeTick - t]);
  DisposeObject(TKDT12DC_Test);
  DoStatus(n);
  n := '';
end;

function TKDT13DC.InternalBuildKdTree(const KDSourceBufferPtr: PKDT13DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT13DC_Node;
  function SortCompare(const p1, p2: PKDT13DC_Source; const axis: NativeInt): ShortInt;
  begin
    if p1^.buff[axis] = p2^.buff[axis] then
      begin
        if p1^.Index = p2^.Index then
            Result := 0
        else if p1^.Index < p2^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.buff[axis] < p2^.buff[axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT13DC_SourceBuffer; L, R: NativeInt; const axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT13DC_Source;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer^[(L + R) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, axis) < 0 do
            Inc(i);
        while SortCompare(SortBuffer^[j], p, axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, axis);
      L := i;
    until i >= R;
  end;

var
  M: NativeInt;
  axis: NativeInt;
  kdBuffPtr: PKDT13DC_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      new(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.Vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);
    end
  else
    begin
      axis := Depth mod KDT13DC_Axis;
      M := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr^[0], 0, PlanCount - 1, axis);

      new(Result);
      Result^.Parent := nil;
      Result^.Vec := kdBuffPtr^[M];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], M, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[M + 1], PlanCount - (M + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT13DC.GetData(const Index: NativeInt): PKDT13DC_Source;
begin
  Result := @KDStoreBuff[Index];
end;

constructor TKDT13DC.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT13DC.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT13DC.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT13DC_Node(KDNodes[i]));
      Inc(i);
    end;

  for i := 0 to length(KDStoreBuff) - 1 do
      KDStoreBuff[i].Token := '';

  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT13DC.StoreBuffPtr: PKDT13DC_DyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT13DC.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT13DC_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT13DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT13DC.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT13DC_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT13DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT13DC.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT13DC_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT13DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{ k-means++ clusterization }
procedure TKDT13DC.BuildKDTreeWithCluster(const inBuff: TKDT13DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  SetLength(Source, length(inBuff), KDT13DC_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT13DC_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT13DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT13DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT13DC.BuildKDTreeWithCluster(const inBuff: TKDT13DC_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TKMIntegerArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT13DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT13DC_BuildCall);
var
  TempStoreBuff: TKDT13DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT13DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT13DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT13DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT13DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT13DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT13DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT13DC_BuildMethod);
var
  TempStoreBuff: TKDT13DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT13DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT13DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT13DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT13DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT13DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT13DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT13DC_BuildProc);
var
  TempStoreBuff: TKDT13DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT13DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT13DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT13DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT13DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT13DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

function TKDT13DC.Search(const buff: TKDT13DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT13DC_Node;

var
  NearestNeighbour: PKDT13DC_Node;

  function FindParentNode(const buffPtr: PKDT13DC_Vec; NodePtr: PKDT13DC_Node): PKDT13DC_Node;
  var
    Next: PKDT13DC_Node;
    Depth, axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        axis := Depth mod KDT13DC_Axis;
        if buffPtr^[axis] > Next^.Vec^.buff[axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT13DC_Node; const buffPtr: PKDT13DC_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    Inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := Distance(buffPtr^, NodePtr^.Vec^.buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.Vec^.Index < NearestNeighbour^.Vec^.Index) then
        NearestNeighbour := NodePtr;

    axis := Depth mod KDT13DC_Axis;
    Dist := NodePtr^.Vec^.buff[axis] - buffPtr^[axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.Vec^.buff[axis] > buffPtr^[axis] then
            ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const buffPtr: PKDT13DC_Vec; const p1, p2: PKDT13DC_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := Distance(buffPtr^, p1^.Vec^.buff);
    d2 := Distance(buffPtr^, p2^.Vec^.buff);
    if d1 = d2 then
      begin
        if p1^.Vec^.Index = p2^.Vec^.Index then
            Result := 0
        else if p1^.Vec^.Index < p2^.Vec^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; L, R: NativeInt; const buffPtr: PKDT13DC_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT13DC_Node;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer[(L + R) shr 1];
      repeat
        while SortCompare(buffPtr, SortBuffer[i], p) < 0 do
            Inc(i);
        while SortCompare(buffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, buffPtr);
      L := i;
    until i >= R;
  end;

var
  Parent: PKDT13DC_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := Distance(buff, Parent^.Vec^.buff);

  ScanSubtree(RootNode, @buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT13DC_Node(NearestNodes[0]);
    end;
end;

function TKDT13DC.Search(const buff: TKDT13DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT13DC_Node;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT13DC.Search(const buff: TKDT13DC_Vec; var SearchedDistanceMin: Double): PKDT13DC_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT13DC.Search(const buff: TKDT13DC_Vec): PKDT13DC_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT13DC.SearchToken(const buff: TKDT13DC_Vec): TPascalString;
var
  p: PKDT13DC_Node;
begin
  p := Search(buff);
  if p <> nil then
      Result := p^.Vec^.Token
  else
      Result := '';
end;

procedure TKDT13DC.Search(const inBuff: TKDT13DC_DynamicVecBuffer; var OutBuff: TKDT13DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT13DC_DynamicVecBuffer;
  outBuffPtr: PKDT13DC_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT13DC_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outBuffPtr^[pass] := p^.Vec^.buff;
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT13DC_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outBuffPtr^[pass] := p^.Vec^.buff;
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT13DC_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.Vec^.buff;
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT13DC.Search(const inBuff: TKDT13DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT13DC_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT13DC_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT13DC_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT13DC_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT13DC.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  ID := KDT13DC_Axis;

  stream.write(st, 4);
  stream.write(ID, 4);

  stream.write(cnt, 8);

  i := 0;
  while i < cnt do
    begin
      stream.write(KDStoreBuff[i].buff[0], SizeOf(TKDT13DC_Vec));
      stream.write(KDStoreBuff[i].Index, 8);
      token_B := KDStoreBuff[i].Token.Bytes;
      token_L := length(token_B);
      stream.write(token_L, 4);
      if token_L > 0 then
        begin
          stream.write(token_B[0], token_L);
          SetLength(token_B, 0);
        end;
      Inc(i);
    end;
end;

procedure TKDT13DC.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  Clear;

  stream.read(st, 4);
  stream.read(ID, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if ID <> KDT13DC_Axis then
      RaiseInfo('kdtree axis error!');

  stream.read(cnt, 8);

  SetLength(KDStoreBuff, cnt);

  i := 0;
  try
    while i < cnt do
      begin
        if stream.read(KDStoreBuff[i].buff[0], SizeOf(TKDT13DC_Vec)) <> SizeOf(TKDT13DC_Vec) then
          begin
            Clear;
            Exit;
          end;
        if stream.read(KDStoreBuff[i].Index, 8) <> 8 then
          begin
            Clear;
            Exit;
          end;
        if stream.read(token_L, 4) <> 4 then
          begin
            Clear;
            Exit;
          end;
        if token_L > 0 then
          begin
            SetLength(token_B, token_L);
            if stream.read(token_B[0], token_L) <> token_L then
              begin
                Clear;
                Exit;
              end;
            KDStoreBuff[i].Token.Bytes := token_B;
            SetLength(token_B, 0);
          end
        else
            KDStoreBuff[i].Token := '';
        Inc(i);
      end;
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      Inc(i);
    end;

  if cnt > 0 then
      RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT13DC.SaveToFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(FileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT13DC.LoadFromFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT13DC.PrintNodeTree(const NodePtr: PKDT13DC_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT13DC_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.Vec^.Index, Vec(p^.Vec^.buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT13DC.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d - %d : %s ', [i, KDStoreBuff[i].Index, Vec(KDStoreBuff[i].buff)]);
end;

class function TKDT13DC.Vec(const s: SystemString): TKDT13DC_Vec;
var
  t: TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j: NativeInt;
begin
  for i := 0 to KDT13DC_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            Inc(j);
            if j >= KDT13DC_Axis then
                Break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT13DC.Vec(const v: TKDT13DC_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT13DC_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT13DC.Distance(const v1, v2: TKDT13DC_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT13DC_Axis - 1 do
      Result := Result + (v2[i] - v1[i]) * (v2[i] - v1[i]);
end;

procedure TKDT13DC.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT13DC_Source; const Data: Pointer);
begin
  Source.buff := TestBuff[IndexFor];
  Source.Token := umlIntToStr(IndexFor);
end;

class procedure TKDT13DC.Test;
var
  TKDT13DC_Test: TKDT13DC;
  t: TTimeTick;
  i, j: NativeInt;
  TestResultBuff: TKDT13DC_DynamicVecBuffer;
  TestResultIndex: TKMIntegerArray;
  KMeanOutIndex: TKMIntegerArray;
  errored: Boolean;
  m64: TMemoryStream64;
  p: PKDT13DC_Node;
  n: TPascalString;
begin
  errored := False;
  n := PFormat('test %s...', [ClassName]);
  t := GetTimeTick;

  n.Append('...build');
  TKDT13DC_Test := TKDT13DC.Create;

  n.Append('...');
  SetLength(TKDT13DC_Test.TestBuff, 1000);
  for i := 0 to length(TKDT13DC_Test.TestBuff) - 1 do
    for j := 0 to KDT13DC_Axis - 1 do
        TKDT13DC_Test.TestBuff[i][j] := i * KDT13DC_Axis + j;

{$IFDEF FPC}
  TKDT13DC_Test.BuildKDTreeM(length(TKDT13DC_Test.TestBuff), nil, @TKDT13DC_Test.Test_BuildM);
{$ELSE FPC}
  TKDT13DC_Test.BuildKDTreeM(length(TKDT13DC_Test.TestBuff), nil, TKDT13DC_Test.Test_BuildM);
{$ENDIF FPC}
  { save/load test }
  n.Append('...save/load');
  m64 := TMemoryStream64.CustomCreate(1024 * 1024);
  TKDT13DC_Test.SaveToStream(m64);
  m64.Position := 0;
  TKDT13DC_Test.LoadFromStream(m64);
  for i := 0 to length(TKDT13DC_Test.TestBuff) - 1 do
    begin
      p := TKDT13DC_Test.Search(TKDT13DC_Test.TestBuff[i]);
      if p^.Vec^.Index <> i then
          errored := True;
      if not p^.Vec^.Token.Same(umlIntToStr(i)) then
          errored := True;
      if errored then
          Break;
    end;
  DisposeObject(m64);

  if not errored then
    begin
      { parallel search test }
      n.Append('...parallel');
      SetLength(TestResultBuff, length(TKDT13DC_Test.TestBuff));
      SetLength(TestResultIndex, length(TKDT13DC_Test.TestBuff));
      TKDT13DC_Test.Search(TKDT13DC_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if Distance(TKDT13DC_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
            errored := True;
    end;

  if not errored then
    begin
      n.Append('...kMean');
      TKDT13DC_Test.Clear;
      { kMean test }
      TKDT13DC_Test.BuildKDTreeWithCluster(TKDT13DC_Test.TestBuff, 10, 1, KMeanOutIndex);
      { parallel search test }
      TKDT13DC_Test.Search(TKDT13DC_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if TestResultIndex[i] <> KMeanOutIndex[i] then
            errored := True;
    end;

  SetLength(TKDT13DC_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT13DC_Test.Clear;

  n.Append('...');
  if errored then
      n.Append('error!')
  else
      n.Append('passed ok %dms', [GetTimeTick - t]);
  DisposeObject(TKDT13DC_Test);
  DoStatus(n);
  n := '';
end;

function TKDT14DC.InternalBuildKdTree(const KDSourceBufferPtr: PKDT14DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT14DC_Node;
  function SortCompare(const p1, p2: PKDT14DC_Source; const axis: NativeInt): ShortInt;
  begin
    if p1^.buff[axis] = p2^.buff[axis] then
      begin
        if p1^.Index = p2^.Index then
            Result := 0
        else if p1^.Index < p2^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.buff[axis] < p2^.buff[axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT14DC_SourceBuffer; L, R: NativeInt; const axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT14DC_Source;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer^[(L + R) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, axis) < 0 do
            Inc(i);
        while SortCompare(SortBuffer^[j], p, axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, axis);
      L := i;
    until i >= R;
  end;

var
  M: NativeInt;
  axis: NativeInt;
  kdBuffPtr: PKDT14DC_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      new(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.Vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);
    end
  else
    begin
      axis := Depth mod KDT14DC_Axis;
      M := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr^[0], 0, PlanCount - 1, axis);

      new(Result);
      Result^.Parent := nil;
      Result^.Vec := kdBuffPtr^[M];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], M, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[M + 1], PlanCount - (M + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT14DC.GetData(const Index: NativeInt): PKDT14DC_Source;
begin
  Result := @KDStoreBuff[Index];
end;

constructor TKDT14DC.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT14DC.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT14DC.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT14DC_Node(KDNodes[i]));
      Inc(i);
    end;

  for i := 0 to length(KDStoreBuff) - 1 do
      KDStoreBuff[i].Token := '';

  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT14DC.StoreBuffPtr: PKDT14DC_DyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT14DC.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT14DC_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT14DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT14DC.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT14DC_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT14DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT14DC.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT14DC_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT14DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{ k-means++ clusterization }
procedure TKDT14DC.BuildKDTreeWithCluster(const inBuff: TKDT14DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  SetLength(Source, length(inBuff), KDT14DC_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT14DC_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT14DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT14DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT14DC.BuildKDTreeWithCluster(const inBuff: TKDT14DC_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TKMIntegerArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT14DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT14DC_BuildCall);
var
  TempStoreBuff: TKDT14DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT14DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT14DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT14DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT14DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT14DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT14DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT14DC_BuildMethod);
var
  TempStoreBuff: TKDT14DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT14DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT14DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT14DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT14DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT14DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT14DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT14DC_BuildProc);
var
  TempStoreBuff: TKDT14DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT14DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT14DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT14DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT14DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT14DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

function TKDT14DC.Search(const buff: TKDT14DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT14DC_Node;

var
  NearestNeighbour: PKDT14DC_Node;

  function FindParentNode(const buffPtr: PKDT14DC_Vec; NodePtr: PKDT14DC_Node): PKDT14DC_Node;
  var
    Next: PKDT14DC_Node;
    Depth, axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        axis := Depth mod KDT14DC_Axis;
        if buffPtr^[axis] > Next^.Vec^.buff[axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT14DC_Node; const buffPtr: PKDT14DC_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    Inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := Distance(buffPtr^, NodePtr^.Vec^.buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.Vec^.Index < NearestNeighbour^.Vec^.Index) then
        NearestNeighbour := NodePtr;

    axis := Depth mod KDT14DC_Axis;
    Dist := NodePtr^.Vec^.buff[axis] - buffPtr^[axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.Vec^.buff[axis] > buffPtr^[axis] then
            ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const buffPtr: PKDT14DC_Vec; const p1, p2: PKDT14DC_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := Distance(buffPtr^, p1^.Vec^.buff);
    d2 := Distance(buffPtr^, p2^.Vec^.buff);
    if d1 = d2 then
      begin
        if p1^.Vec^.Index = p2^.Vec^.Index then
            Result := 0
        else if p1^.Vec^.Index < p2^.Vec^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; L, R: NativeInt; const buffPtr: PKDT14DC_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT14DC_Node;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer[(L + R) shr 1];
      repeat
        while SortCompare(buffPtr, SortBuffer[i], p) < 0 do
            Inc(i);
        while SortCompare(buffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, buffPtr);
      L := i;
    until i >= R;
  end;

var
  Parent: PKDT14DC_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := Distance(buff, Parent^.Vec^.buff);

  ScanSubtree(RootNode, @buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT14DC_Node(NearestNodes[0]);
    end;
end;

function TKDT14DC.Search(const buff: TKDT14DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT14DC_Node;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT14DC.Search(const buff: TKDT14DC_Vec; var SearchedDistanceMin: Double): PKDT14DC_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT14DC.Search(const buff: TKDT14DC_Vec): PKDT14DC_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT14DC.SearchToken(const buff: TKDT14DC_Vec): TPascalString;
var
  p: PKDT14DC_Node;
begin
  p := Search(buff);
  if p <> nil then
      Result := p^.Vec^.Token
  else
      Result := '';
end;

procedure TKDT14DC.Search(const inBuff: TKDT14DC_DynamicVecBuffer; var OutBuff: TKDT14DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT14DC_DynamicVecBuffer;
  outBuffPtr: PKDT14DC_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT14DC_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outBuffPtr^[pass] := p^.Vec^.buff;
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT14DC_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outBuffPtr^[pass] := p^.Vec^.buff;
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT14DC_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.Vec^.buff;
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT14DC.Search(const inBuff: TKDT14DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT14DC_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT14DC_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT14DC_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT14DC_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT14DC.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  ID := KDT14DC_Axis;

  stream.write(st, 4);
  stream.write(ID, 4);

  stream.write(cnt, 8);

  i := 0;
  while i < cnt do
    begin
      stream.write(KDStoreBuff[i].buff[0], SizeOf(TKDT14DC_Vec));
      stream.write(KDStoreBuff[i].Index, 8);
      token_B := KDStoreBuff[i].Token.Bytes;
      token_L := length(token_B);
      stream.write(token_L, 4);
      if token_L > 0 then
        begin
          stream.write(token_B[0], token_L);
          SetLength(token_B, 0);
        end;
      Inc(i);
    end;
end;

procedure TKDT14DC.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  Clear;

  stream.read(st, 4);
  stream.read(ID, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if ID <> KDT14DC_Axis then
      RaiseInfo('kdtree axis error!');

  stream.read(cnt, 8);

  SetLength(KDStoreBuff, cnt);

  i := 0;
  try
    while i < cnt do
      begin
        if stream.read(KDStoreBuff[i].buff[0], SizeOf(TKDT14DC_Vec)) <> SizeOf(TKDT14DC_Vec) then
          begin
            Clear;
            Exit;
          end;
        if stream.read(KDStoreBuff[i].Index, 8) <> 8 then
          begin
            Clear;
            Exit;
          end;
        if stream.read(token_L, 4) <> 4 then
          begin
            Clear;
            Exit;
          end;
        if token_L > 0 then
          begin
            SetLength(token_B, token_L);
            if stream.read(token_B[0], token_L) <> token_L then
              begin
                Clear;
                Exit;
              end;
            KDStoreBuff[i].Token.Bytes := token_B;
            SetLength(token_B, 0);
          end
        else
            KDStoreBuff[i].Token := '';
        Inc(i);
      end;
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      Inc(i);
    end;

  if cnt > 0 then
      RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT14DC.SaveToFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(FileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT14DC.LoadFromFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT14DC.PrintNodeTree(const NodePtr: PKDT14DC_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT14DC_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.Vec^.Index, Vec(p^.Vec^.buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT14DC.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d - %d : %s ', [i, KDStoreBuff[i].Index, Vec(KDStoreBuff[i].buff)]);
end;

class function TKDT14DC.Vec(const s: SystemString): TKDT14DC_Vec;
var
  t: TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j: NativeInt;
begin
  for i := 0 to KDT14DC_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            Inc(j);
            if j >= KDT14DC_Axis then
                Break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT14DC.Vec(const v: TKDT14DC_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT14DC_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT14DC.Distance(const v1, v2: TKDT14DC_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT14DC_Axis - 1 do
      Result := Result + (v2[i] - v1[i]) * (v2[i] - v1[i]);
end;

procedure TKDT14DC.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT14DC_Source; const Data: Pointer);
begin
  Source.buff := TestBuff[IndexFor];
  Source.Token := umlIntToStr(IndexFor);
end;

class procedure TKDT14DC.Test;
var
  TKDT14DC_Test: TKDT14DC;
  t: TTimeTick;
  i, j: NativeInt;
  TestResultBuff: TKDT14DC_DynamicVecBuffer;
  TestResultIndex: TKMIntegerArray;
  KMeanOutIndex: TKMIntegerArray;
  errored: Boolean;
  m64: TMemoryStream64;
  p: PKDT14DC_Node;
  n: TPascalString;
begin
  errored := False;
  n := PFormat('test %s...', [ClassName]);
  t := GetTimeTick;

  n.Append('...build');
  TKDT14DC_Test := TKDT14DC.Create;

  n.Append('...');
  SetLength(TKDT14DC_Test.TestBuff, 1000);
  for i := 0 to length(TKDT14DC_Test.TestBuff) - 1 do
    for j := 0 to KDT14DC_Axis - 1 do
        TKDT14DC_Test.TestBuff[i][j] := i * KDT14DC_Axis + j;

{$IFDEF FPC}
  TKDT14DC_Test.BuildKDTreeM(length(TKDT14DC_Test.TestBuff), nil, @TKDT14DC_Test.Test_BuildM);
{$ELSE FPC}
  TKDT14DC_Test.BuildKDTreeM(length(TKDT14DC_Test.TestBuff), nil, TKDT14DC_Test.Test_BuildM);
{$ENDIF FPC}
  { save/load test }
  n.Append('...save/load');
  m64 := TMemoryStream64.CustomCreate(1024 * 1024);
  TKDT14DC_Test.SaveToStream(m64);
  m64.Position := 0;
  TKDT14DC_Test.LoadFromStream(m64);
  for i := 0 to length(TKDT14DC_Test.TestBuff) - 1 do
    begin
      p := TKDT14DC_Test.Search(TKDT14DC_Test.TestBuff[i]);
      if p^.Vec^.Index <> i then
          errored := True;
      if not p^.Vec^.Token.Same(umlIntToStr(i)) then
          errored := True;
      if errored then
          Break;
    end;
  DisposeObject(m64);

  if not errored then
    begin
      { parallel search test }
      n.Append('...parallel');
      SetLength(TestResultBuff, length(TKDT14DC_Test.TestBuff));
      SetLength(TestResultIndex, length(TKDT14DC_Test.TestBuff));
      TKDT14DC_Test.Search(TKDT14DC_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if Distance(TKDT14DC_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
            errored := True;
    end;

  if not errored then
    begin
      n.Append('...kMean');
      TKDT14DC_Test.Clear;
      { kMean test }
      TKDT14DC_Test.BuildKDTreeWithCluster(TKDT14DC_Test.TestBuff, 10, 1, KMeanOutIndex);
      { parallel search test }
      TKDT14DC_Test.Search(TKDT14DC_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if TestResultIndex[i] <> KMeanOutIndex[i] then
            errored := True;
    end;

  SetLength(TKDT14DC_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT14DC_Test.Clear;

  n.Append('...');
  if errored then
      n.Append('error!')
  else
      n.Append('passed ok %dms', [GetTimeTick - t]);
  DisposeObject(TKDT14DC_Test);
  DoStatus(n);
  n := '';
end;

function TKDT15DC.InternalBuildKdTree(const KDSourceBufferPtr: PKDT15DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT15DC_Node;
  function SortCompare(const p1, p2: PKDT15DC_Source; const axis: NativeInt): ShortInt;
  begin
    if p1^.buff[axis] = p2^.buff[axis] then
      begin
        if p1^.Index = p2^.Index then
            Result := 0
        else if p1^.Index < p2^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.buff[axis] < p2^.buff[axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT15DC_SourceBuffer; L, R: NativeInt; const axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT15DC_Source;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer^[(L + R) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, axis) < 0 do
            Inc(i);
        while SortCompare(SortBuffer^[j], p, axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, axis);
      L := i;
    until i >= R;
  end;

var
  M: NativeInt;
  axis: NativeInt;
  kdBuffPtr: PKDT15DC_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      new(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.Vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);
    end
  else
    begin
      axis := Depth mod KDT15DC_Axis;
      M := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr^[0], 0, PlanCount - 1, axis);

      new(Result);
      Result^.Parent := nil;
      Result^.Vec := kdBuffPtr^[M];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], M, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[M + 1], PlanCount - (M + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT15DC.GetData(const Index: NativeInt): PKDT15DC_Source;
begin
  Result := @KDStoreBuff[Index];
end;

constructor TKDT15DC.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT15DC.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT15DC.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT15DC_Node(KDNodes[i]));
      Inc(i);
    end;

  for i := 0 to length(KDStoreBuff) - 1 do
      KDStoreBuff[i].Token := '';

  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT15DC.StoreBuffPtr: PKDT15DC_DyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT15DC.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT15DC_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT15DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT15DC.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT15DC_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT15DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT15DC.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT15DC_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT15DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{ k-means++ clusterization }
procedure TKDT15DC.BuildKDTreeWithCluster(const inBuff: TKDT15DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  SetLength(Source, length(inBuff), KDT15DC_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT15DC_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT15DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT15DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT15DC.BuildKDTreeWithCluster(const inBuff: TKDT15DC_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TKMIntegerArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT15DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT15DC_BuildCall);
var
  TempStoreBuff: TKDT15DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT15DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT15DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT15DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT15DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT15DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT15DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT15DC_BuildMethod);
var
  TempStoreBuff: TKDT15DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT15DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT15DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT15DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT15DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT15DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT15DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT15DC_BuildProc);
var
  TempStoreBuff: TKDT15DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT15DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT15DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT15DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT15DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT15DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

function TKDT15DC.Search(const buff: TKDT15DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT15DC_Node;

var
  NearestNeighbour: PKDT15DC_Node;

  function FindParentNode(const buffPtr: PKDT15DC_Vec; NodePtr: PKDT15DC_Node): PKDT15DC_Node;
  var
    Next: PKDT15DC_Node;
    Depth, axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        axis := Depth mod KDT15DC_Axis;
        if buffPtr^[axis] > Next^.Vec^.buff[axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT15DC_Node; const buffPtr: PKDT15DC_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    Inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := Distance(buffPtr^, NodePtr^.Vec^.buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.Vec^.Index < NearestNeighbour^.Vec^.Index) then
        NearestNeighbour := NodePtr;

    axis := Depth mod KDT15DC_Axis;
    Dist := NodePtr^.Vec^.buff[axis] - buffPtr^[axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.Vec^.buff[axis] > buffPtr^[axis] then
            ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const buffPtr: PKDT15DC_Vec; const p1, p2: PKDT15DC_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := Distance(buffPtr^, p1^.Vec^.buff);
    d2 := Distance(buffPtr^, p2^.Vec^.buff);
    if d1 = d2 then
      begin
        if p1^.Vec^.Index = p2^.Vec^.Index then
            Result := 0
        else if p1^.Vec^.Index < p2^.Vec^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; L, R: NativeInt; const buffPtr: PKDT15DC_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT15DC_Node;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer[(L + R) shr 1];
      repeat
        while SortCompare(buffPtr, SortBuffer[i], p) < 0 do
            Inc(i);
        while SortCompare(buffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, buffPtr);
      L := i;
    until i >= R;
  end;

var
  Parent: PKDT15DC_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := Distance(buff, Parent^.Vec^.buff);

  ScanSubtree(RootNode, @buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT15DC_Node(NearestNodes[0]);
    end;
end;

function TKDT15DC.Search(const buff: TKDT15DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT15DC_Node;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT15DC.Search(const buff: TKDT15DC_Vec; var SearchedDistanceMin: Double): PKDT15DC_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT15DC.Search(const buff: TKDT15DC_Vec): PKDT15DC_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT15DC.SearchToken(const buff: TKDT15DC_Vec): TPascalString;
var
  p: PKDT15DC_Node;
begin
  p := Search(buff);
  if p <> nil then
      Result := p^.Vec^.Token
  else
      Result := '';
end;

procedure TKDT15DC.Search(const inBuff: TKDT15DC_DynamicVecBuffer; var OutBuff: TKDT15DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT15DC_DynamicVecBuffer;
  outBuffPtr: PKDT15DC_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT15DC_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outBuffPtr^[pass] := p^.Vec^.buff;
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT15DC_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outBuffPtr^[pass] := p^.Vec^.buff;
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT15DC_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.Vec^.buff;
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT15DC.Search(const inBuff: TKDT15DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT15DC_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT15DC_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT15DC_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT15DC_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT15DC.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  ID := KDT15DC_Axis;

  stream.write(st, 4);
  stream.write(ID, 4);

  stream.write(cnt, 8);

  i := 0;
  while i < cnt do
    begin
      stream.write(KDStoreBuff[i].buff[0], SizeOf(TKDT15DC_Vec));
      stream.write(KDStoreBuff[i].Index, 8);
      token_B := KDStoreBuff[i].Token.Bytes;
      token_L := length(token_B);
      stream.write(token_L, 4);
      if token_L > 0 then
        begin
          stream.write(token_B[0], token_L);
          SetLength(token_B, 0);
        end;
      Inc(i);
    end;
end;

procedure TKDT15DC.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  Clear;

  stream.read(st, 4);
  stream.read(ID, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if ID <> KDT15DC_Axis then
      RaiseInfo('kdtree axis error!');

  stream.read(cnt, 8);

  SetLength(KDStoreBuff, cnt);

  i := 0;
  try
    while i < cnt do
      begin
        if stream.read(KDStoreBuff[i].buff[0], SizeOf(TKDT15DC_Vec)) <> SizeOf(TKDT15DC_Vec) then
          begin
            Clear;
            Exit;
          end;
        if stream.read(KDStoreBuff[i].Index, 8) <> 8 then
          begin
            Clear;
            Exit;
          end;
        if stream.read(token_L, 4) <> 4 then
          begin
            Clear;
            Exit;
          end;
        if token_L > 0 then
          begin
            SetLength(token_B, token_L);
            if stream.read(token_B[0], token_L) <> token_L then
              begin
                Clear;
                Exit;
              end;
            KDStoreBuff[i].Token.Bytes := token_B;
            SetLength(token_B, 0);
          end
        else
            KDStoreBuff[i].Token := '';
        Inc(i);
      end;
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      Inc(i);
    end;

  if cnt > 0 then
      RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT15DC.SaveToFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(FileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT15DC.LoadFromFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT15DC.PrintNodeTree(const NodePtr: PKDT15DC_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT15DC_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.Vec^.Index, Vec(p^.Vec^.buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT15DC.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d - %d : %s ', [i, KDStoreBuff[i].Index, Vec(KDStoreBuff[i].buff)]);
end;

class function TKDT15DC.Vec(const s: SystemString): TKDT15DC_Vec;
var
  t: TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j: NativeInt;
begin
  for i := 0 to KDT15DC_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            Inc(j);
            if j >= KDT15DC_Axis then
                Break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT15DC.Vec(const v: TKDT15DC_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT15DC_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT15DC.Distance(const v1, v2: TKDT15DC_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT15DC_Axis - 1 do
      Result := Result + (v2[i] - v1[i]) * (v2[i] - v1[i]);
end;

procedure TKDT15DC.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT15DC_Source; const Data: Pointer);
begin
  Source.buff := TestBuff[IndexFor];
  Source.Token := umlIntToStr(IndexFor);
end;

class procedure TKDT15DC.Test;
var
  TKDT15DC_Test: TKDT15DC;
  t: TTimeTick;
  i, j: NativeInt;
  TestResultBuff: TKDT15DC_DynamicVecBuffer;
  TestResultIndex: TKMIntegerArray;
  KMeanOutIndex: TKMIntegerArray;
  errored: Boolean;
  m64: TMemoryStream64;
  p: PKDT15DC_Node;
  n: TPascalString;
begin
  errored := False;
  n := PFormat('test %s...', [ClassName]);
  t := GetTimeTick;

  n.Append('...build');
  TKDT15DC_Test := TKDT15DC.Create;

  n.Append('...');
  SetLength(TKDT15DC_Test.TestBuff, 1000);
  for i := 0 to length(TKDT15DC_Test.TestBuff) - 1 do
    for j := 0 to KDT15DC_Axis - 1 do
        TKDT15DC_Test.TestBuff[i][j] := i * KDT15DC_Axis + j;

{$IFDEF FPC}
  TKDT15DC_Test.BuildKDTreeM(length(TKDT15DC_Test.TestBuff), nil, @TKDT15DC_Test.Test_BuildM);
{$ELSE FPC}
  TKDT15DC_Test.BuildKDTreeM(length(TKDT15DC_Test.TestBuff), nil, TKDT15DC_Test.Test_BuildM);
{$ENDIF FPC}
  { save/load test }
  n.Append('...save/load');
  m64 := TMemoryStream64.CustomCreate(1024 * 1024);
  TKDT15DC_Test.SaveToStream(m64);
  m64.Position := 0;
  TKDT15DC_Test.LoadFromStream(m64);
  for i := 0 to length(TKDT15DC_Test.TestBuff) - 1 do
    begin
      p := TKDT15DC_Test.Search(TKDT15DC_Test.TestBuff[i]);
      if p^.Vec^.Index <> i then
          errored := True;
      if not p^.Vec^.Token.Same(umlIntToStr(i)) then
          errored := True;
      if errored then
          Break;
    end;
  DisposeObject(m64);

  if not errored then
    begin
      { parallel search test }
      n.Append('...parallel');
      SetLength(TestResultBuff, length(TKDT15DC_Test.TestBuff));
      SetLength(TestResultIndex, length(TKDT15DC_Test.TestBuff));
      TKDT15DC_Test.Search(TKDT15DC_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if Distance(TKDT15DC_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
            errored := True;
    end;

  if not errored then
    begin
      n.Append('...kMean');
      TKDT15DC_Test.Clear;
      { kMean test }
      TKDT15DC_Test.BuildKDTreeWithCluster(TKDT15DC_Test.TestBuff, 10, 1, KMeanOutIndex);
      { parallel search test }
      TKDT15DC_Test.Search(TKDT15DC_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if TestResultIndex[i] <> KMeanOutIndex[i] then
            errored := True;
    end;

  SetLength(TKDT15DC_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT15DC_Test.Clear;

  n.Append('...');
  if errored then
      n.Append('error!')
  else
      n.Append('passed ok %dms', [GetTimeTick - t]);
  DisposeObject(TKDT15DC_Test);
  DoStatus(n);
  n := '';
end;

function TKDT16DC.InternalBuildKdTree(const KDSourceBufferPtr: PKDT16DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT16DC_Node;
  function SortCompare(const p1, p2: PKDT16DC_Source; const axis: NativeInt): ShortInt;
  begin
    if p1^.buff[axis] = p2^.buff[axis] then
      begin
        if p1^.Index = p2^.Index then
            Result := 0
        else if p1^.Index < p2^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.buff[axis] < p2^.buff[axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT16DC_SourceBuffer; L, R: NativeInt; const axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT16DC_Source;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer^[(L + R) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, axis) < 0 do
            Inc(i);
        while SortCompare(SortBuffer^[j], p, axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, axis);
      L := i;
    until i >= R;
  end;

var
  M: NativeInt;
  axis: NativeInt;
  kdBuffPtr: PKDT16DC_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      new(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.Vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);
    end
  else
    begin
      axis := Depth mod KDT16DC_Axis;
      M := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr^[0], 0, PlanCount - 1, axis);

      new(Result);
      Result^.Parent := nil;
      Result^.Vec := kdBuffPtr^[M];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], M, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[M + 1], PlanCount - (M + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT16DC.GetData(const Index: NativeInt): PKDT16DC_Source;
begin
  Result := @KDStoreBuff[Index];
end;

constructor TKDT16DC.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT16DC.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT16DC.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT16DC_Node(KDNodes[i]));
      Inc(i);
    end;

  for i := 0 to length(KDStoreBuff) - 1 do
      KDStoreBuff[i].Token := '';

  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT16DC.StoreBuffPtr: PKDT16DC_DyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT16DC.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT16DC_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT16DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT16DC.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT16DC_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT16DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT16DC.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT16DC_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT16DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{ k-means++ clusterization }
procedure TKDT16DC.BuildKDTreeWithCluster(const inBuff: TKDT16DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  SetLength(Source, length(inBuff), KDT16DC_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT16DC_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT16DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT16DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT16DC.BuildKDTreeWithCluster(const inBuff: TKDT16DC_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TKMIntegerArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT16DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT16DC_BuildCall);
var
  TempStoreBuff: TKDT16DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT16DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT16DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT16DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT16DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT16DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT16DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT16DC_BuildMethod);
var
  TempStoreBuff: TKDT16DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT16DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT16DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT16DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT16DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT16DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT16DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT16DC_BuildProc);
var
  TempStoreBuff: TKDT16DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT16DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT16DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT16DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT16DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT16DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

function TKDT16DC.Search(const buff: TKDT16DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT16DC_Node;

var
  NearestNeighbour: PKDT16DC_Node;

  function FindParentNode(const buffPtr: PKDT16DC_Vec; NodePtr: PKDT16DC_Node): PKDT16DC_Node;
  var
    Next: PKDT16DC_Node;
    Depth, axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        axis := Depth mod KDT16DC_Axis;
        if buffPtr^[axis] > Next^.Vec^.buff[axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT16DC_Node; const buffPtr: PKDT16DC_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    Inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := Distance(buffPtr^, NodePtr^.Vec^.buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.Vec^.Index < NearestNeighbour^.Vec^.Index) then
        NearestNeighbour := NodePtr;

    axis := Depth mod KDT16DC_Axis;
    Dist := NodePtr^.Vec^.buff[axis] - buffPtr^[axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.Vec^.buff[axis] > buffPtr^[axis] then
            ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const buffPtr: PKDT16DC_Vec; const p1, p2: PKDT16DC_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := Distance(buffPtr^, p1^.Vec^.buff);
    d2 := Distance(buffPtr^, p2^.Vec^.buff);
    if d1 = d2 then
      begin
        if p1^.Vec^.Index = p2^.Vec^.Index then
            Result := 0
        else if p1^.Vec^.Index < p2^.Vec^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; L, R: NativeInt; const buffPtr: PKDT16DC_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT16DC_Node;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer[(L + R) shr 1];
      repeat
        while SortCompare(buffPtr, SortBuffer[i], p) < 0 do
            Inc(i);
        while SortCompare(buffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, buffPtr);
      L := i;
    until i >= R;
  end;

var
  Parent: PKDT16DC_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := Distance(buff, Parent^.Vec^.buff);

  ScanSubtree(RootNode, @buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT16DC_Node(NearestNodes[0]);
    end;
end;

function TKDT16DC.Search(const buff: TKDT16DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT16DC_Node;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT16DC.Search(const buff: TKDT16DC_Vec; var SearchedDistanceMin: Double): PKDT16DC_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT16DC.Search(const buff: TKDT16DC_Vec): PKDT16DC_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT16DC.SearchToken(const buff: TKDT16DC_Vec): TPascalString;
var
  p: PKDT16DC_Node;
begin
  p := Search(buff);
  if p <> nil then
      Result := p^.Vec^.Token
  else
      Result := '';
end;

procedure TKDT16DC.Search(const inBuff: TKDT16DC_DynamicVecBuffer; var OutBuff: TKDT16DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT16DC_DynamicVecBuffer;
  outBuffPtr: PKDT16DC_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT16DC_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outBuffPtr^[pass] := p^.Vec^.buff;
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT16DC_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outBuffPtr^[pass] := p^.Vec^.buff;
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT16DC_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.Vec^.buff;
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT16DC.Search(const inBuff: TKDT16DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT16DC_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT16DC_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT16DC_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT16DC_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT16DC.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  ID := KDT16DC_Axis;

  stream.write(st, 4);
  stream.write(ID, 4);

  stream.write(cnt, 8);

  i := 0;
  while i < cnt do
    begin
      stream.write(KDStoreBuff[i].buff[0], SizeOf(TKDT16DC_Vec));
      stream.write(KDStoreBuff[i].Index, 8);
      token_B := KDStoreBuff[i].Token.Bytes;
      token_L := length(token_B);
      stream.write(token_L, 4);
      if token_L > 0 then
        begin
          stream.write(token_B[0], token_L);
          SetLength(token_B, 0);
        end;
      Inc(i);
    end;
end;

procedure TKDT16DC.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  Clear;

  stream.read(st, 4);
  stream.read(ID, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if ID <> KDT16DC_Axis then
      RaiseInfo('kdtree axis error!');

  stream.read(cnt, 8);

  SetLength(KDStoreBuff, cnt);

  i := 0;
  try
    while i < cnt do
      begin
        if stream.read(KDStoreBuff[i].buff[0], SizeOf(TKDT16DC_Vec)) <> SizeOf(TKDT16DC_Vec) then
          begin
            Clear;
            Exit;
          end;
        if stream.read(KDStoreBuff[i].Index, 8) <> 8 then
          begin
            Clear;
            Exit;
          end;
        if stream.read(token_L, 4) <> 4 then
          begin
            Clear;
            Exit;
          end;
        if token_L > 0 then
          begin
            SetLength(token_B, token_L);
            if stream.read(token_B[0], token_L) <> token_L then
              begin
                Clear;
                Exit;
              end;
            KDStoreBuff[i].Token.Bytes := token_B;
            SetLength(token_B, 0);
          end
        else
            KDStoreBuff[i].Token := '';
        Inc(i);
      end;
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      Inc(i);
    end;

  if cnt > 0 then
      RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT16DC.SaveToFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(FileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT16DC.LoadFromFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT16DC.PrintNodeTree(const NodePtr: PKDT16DC_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT16DC_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.Vec^.Index, Vec(p^.Vec^.buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT16DC.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d - %d : %s ', [i, KDStoreBuff[i].Index, Vec(KDStoreBuff[i].buff)]);
end;

class function TKDT16DC.Vec(const s: SystemString): TKDT16DC_Vec;
var
  t: TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j: NativeInt;
begin
  for i := 0 to KDT16DC_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            Inc(j);
            if j >= KDT16DC_Axis then
                Break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT16DC.Vec(const v: TKDT16DC_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT16DC_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT16DC.Distance(const v1, v2: TKDT16DC_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT16DC_Axis - 1 do
      Result := Result + (v2[i] - v1[i]) * (v2[i] - v1[i]);
end;

procedure TKDT16DC.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT16DC_Source; const Data: Pointer);
begin
  Source.buff := TestBuff[IndexFor];
  Source.Token := umlIntToStr(IndexFor);
end;

class procedure TKDT16DC.Test;
var
  TKDT16DC_Test: TKDT16DC;
  t: TTimeTick;
  i, j: NativeInt;
  TestResultBuff: TKDT16DC_DynamicVecBuffer;
  TestResultIndex: TKMIntegerArray;
  KMeanOutIndex: TKMIntegerArray;
  errored: Boolean;
  m64: TMemoryStream64;
  p: PKDT16DC_Node;
  n: TPascalString;
begin
  errored := False;
  n := PFormat('test %s...', [ClassName]);
  t := GetTimeTick;

  n.Append('...build');
  TKDT16DC_Test := TKDT16DC.Create;

  n.Append('...');
  SetLength(TKDT16DC_Test.TestBuff, 1000);
  for i := 0 to length(TKDT16DC_Test.TestBuff) - 1 do
    for j := 0 to KDT16DC_Axis - 1 do
        TKDT16DC_Test.TestBuff[i][j] := i * KDT16DC_Axis + j;

{$IFDEF FPC}
  TKDT16DC_Test.BuildKDTreeM(length(TKDT16DC_Test.TestBuff), nil, @TKDT16DC_Test.Test_BuildM);
{$ELSE FPC}
  TKDT16DC_Test.BuildKDTreeM(length(TKDT16DC_Test.TestBuff), nil, TKDT16DC_Test.Test_BuildM);
{$ENDIF FPC}
  { save/load test }
  n.Append('...save/load');
  m64 := TMemoryStream64.CustomCreate(1024 * 1024);
  TKDT16DC_Test.SaveToStream(m64);
  m64.Position := 0;
  TKDT16DC_Test.LoadFromStream(m64);
  for i := 0 to length(TKDT16DC_Test.TestBuff) - 1 do
    begin
      p := TKDT16DC_Test.Search(TKDT16DC_Test.TestBuff[i]);
      if p^.Vec^.Index <> i then
          errored := True;
      if not p^.Vec^.Token.Same(umlIntToStr(i)) then
          errored := True;
      if errored then
          Break;
    end;
  DisposeObject(m64);

  if not errored then
    begin
      { parallel search test }
      n.Append('...parallel');
      SetLength(TestResultBuff, length(TKDT16DC_Test.TestBuff));
      SetLength(TestResultIndex, length(TKDT16DC_Test.TestBuff));
      TKDT16DC_Test.Search(TKDT16DC_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if Distance(TKDT16DC_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
            errored := True;
    end;

  if not errored then
    begin
      n.Append('...kMean');
      TKDT16DC_Test.Clear;
      { kMean test }
      TKDT16DC_Test.BuildKDTreeWithCluster(TKDT16DC_Test.TestBuff, 10, 1, KMeanOutIndex);
      { parallel search test }
      TKDT16DC_Test.Search(TKDT16DC_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if TestResultIndex[i] <> KMeanOutIndex[i] then
            errored := True;
    end;

  SetLength(TKDT16DC_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT16DC_Test.Clear;

  n.Append('...');
  if errored then
      n.Append('error!')
  else
      n.Append('passed ok %dms', [GetTimeTick - t]);
  DisposeObject(TKDT16DC_Test);
  DoStatus(n);
  n := '';
end;

function TKDT17DC.InternalBuildKdTree(const KDSourceBufferPtr: PKDT17DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT17DC_Node;
  function SortCompare(const p1, p2: PKDT17DC_Source; const axis: NativeInt): ShortInt;
  begin
    if p1^.buff[axis] = p2^.buff[axis] then
      begin
        if p1^.Index = p2^.Index then
            Result := 0
        else if p1^.Index < p2^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.buff[axis] < p2^.buff[axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT17DC_SourceBuffer; L, R: NativeInt; const axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT17DC_Source;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer^[(L + R) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, axis) < 0 do
            Inc(i);
        while SortCompare(SortBuffer^[j], p, axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, axis);
      L := i;
    until i >= R;
  end;

var
  M: NativeInt;
  axis: NativeInt;
  kdBuffPtr: PKDT17DC_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      new(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.Vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);
    end
  else
    begin
      axis := Depth mod KDT17DC_Axis;
      M := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr^[0], 0, PlanCount - 1, axis);

      new(Result);
      Result^.Parent := nil;
      Result^.Vec := kdBuffPtr^[M];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], M, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[M + 1], PlanCount - (M + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT17DC.GetData(const Index: NativeInt): PKDT17DC_Source;
begin
  Result := @KDStoreBuff[Index];
end;

constructor TKDT17DC.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT17DC.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT17DC.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT17DC_Node(KDNodes[i]));
      Inc(i);
    end;

  for i := 0 to length(KDStoreBuff) - 1 do
      KDStoreBuff[i].Token := '';

  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT17DC.StoreBuffPtr: PKDT17DC_DyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT17DC.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT17DC_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT17DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT17DC.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT17DC_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT17DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT17DC.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT17DC_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT17DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{ k-means++ clusterization }
procedure TKDT17DC.BuildKDTreeWithCluster(const inBuff: TKDT17DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  SetLength(Source, length(inBuff), KDT17DC_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT17DC_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT17DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT17DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT17DC.BuildKDTreeWithCluster(const inBuff: TKDT17DC_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TKMIntegerArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT17DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT17DC_BuildCall);
var
  TempStoreBuff: TKDT17DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT17DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT17DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT17DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT17DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT17DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT17DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT17DC_BuildMethod);
var
  TempStoreBuff: TKDT17DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT17DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT17DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT17DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT17DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT17DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT17DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT17DC_BuildProc);
var
  TempStoreBuff: TKDT17DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT17DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT17DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT17DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT17DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT17DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

function TKDT17DC.Search(const buff: TKDT17DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT17DC_Node;

var
  NearestNeighbour: PKDT17DC_Node;

  function FindParentNode(const buffPtr: PKDT17DC_Vec; NodePtr: PKDT17DC_Node): PKDT17DC_Node;
  var
    Next: PKDT17DC_Node;
    Depth, axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        axis := Depth mod KDT17DC_Axis;
        if buffPtr^[axis] > Next^.Vec^.buff[axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT17DC_Node; const buffPtr: PKDT17DC_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    Inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := Distance(buffPtr^, NodePtr^.Vec^.buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.Vec^.Index < NearestNeighbour^.Vec^.Index) then
        NearestNeighbour := NodePtr;

    axis := Depth mod KDT17DC_Axis;
    Dist := NodePtr^.Vec^.buff[axis] - buffPtr^[axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.Vec^.buff[axis] > buffPtr^[axis] then
            ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const buffPtr: PKDT17DC_Vec; const p1, p2: PKDT17DC_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := Distance(buffPtr^, p1^.Vec^.buff);
    d2 := Distance(buffPtr^, p2^.Vec^.buff);
    if d1 = d2 then
      begin
        if p1^.Vec^.Index = p2^.Vec^.Index then
            Result := 0
        else if p1^.Vec^.Index < p2^.Vec^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; L, R: NativeInt; const buffPtr: PKDT17DC_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT17DC_Node;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer[(L + R) shr 1];
      repeat
        while SortCompare(buffPtr, SortBuffer[i], p) < 0 do
            Inc(i);
        while SortCompare(buffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, buffPtr);
      L := i;
    until i >= R;
  end;

var
  Parent: PKDT17DC_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := Distance(buff, Parent^.Vec^.buff);

  ScanSubtree(RootNode, @buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT17DC_Node(NearestNodes[0]);
    end;
end;

function TKDT17DC.Search(const buff: TKDT17DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT17DC_Node;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT17DC.Search(const buff: TKDT17DC_Vec; var SearchedDistanceMin: Double): PKDT17DC_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT17DC.Search(const buff: TKDT17DC_Vec): PKDT17DC_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT17DC.SearchToken(const buff: TKDT17DC_Vec): TPascalString;
var
  p: PKDT17DC_Node;
begin
  p := Search(buff);
  if p <> nil then
      Result := p^.Vec^.Token
  else
      Result := '';
end;

procedure TKDT17DC.Search(const inBuff: TKDT17DC_DynamicVecBuffer; var OutBuff: TKDT17DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT17DC_DynamicVecBuffer;
  outBuffPtr: PKDT17DC_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT17DC_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outBuffPtr^[pass] := p^.Vec^.buff;
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT17DC_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outBuffPtr^[pass] := p^.Vec^.buff;
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT17DC_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.Vec^.buff;
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT17DC.Search(const inBuff: TKDT17DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT17DC_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT17DC_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT17DC_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT17DC_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT17DC.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  ID := KDT17DC_Axis;

  stream.write(st, 4);
  stream.write(ID, 4);

  stream.write(cnt, 8);

  i := 0;
  while i < cnt do
    begin
      stream.write(KDStoreBuff[i].buff[0], SizeOf(TKDT17DC_Vec));
      stream.write(KDStoreBuff[i].Index, 8);
      token_B := KDStoreBuff[i].Token.Bytes;
      token_L := length(token_B);
      stream.write(token_L, 4);
      if token_L > 0 then
        begin
          stream.write(token_B[0], token_L);
          SetLength(token_B, 0);
        end;
      Inc(i);
    end;
end;

procedure TKDT17DC.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  Clear;

  stream.read(st, 4);
  stream.read(ID, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if ID <> KDT17DC_Axis then
      RaiseInfo('kdtree axis error!');

  stream.read(cnt, 8);

  SetLength(KDStoreBuff, cnt);

  i := 0;
  try
    while i < cnt do
      begin
        if stream.read(KDStoreBuff[i].buff[0], SizeOf(TKDT17DC_Vec)) <> SizeOf(TKDT17DC_Vec) then
          begin
            Clear;
            Exit;
          end;
        if stream.read(KDStoreBuff[i].Index, 8) <> 8 then
          begin
            Clear;
            Exit;
          end;
        if stream.read(token_L, 4) <> 4 then
          begin
            Clear;
            Exit;
          end;
        if token_L > 0 then
          begin
            SetLength(token_B, token_L);
            if stream.read(token_B[0], token_L) <> token_L then
              begin
                Clear;
                Exit;
              end;
            KDStoreBuff[i].Token.Bytes := token_B;
            SetLength(token_B, 0);
          end
        else
            KDStoreBuff[i].Token := '';
        Inc(i);
      end;
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      Inc(i);
    end;

  if cnt > 0 then
      RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT17DC.SaveToFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(FileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT17DC.LoadFromFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT17DC.PrintNodeTree(const NodePtr: PKDT17DC_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT17DC_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.Vec^.Index, Vec(p^.Vec^.buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT17DC.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d - %d : %s ', [i, KDStoreBuff[i].Index, Vec(KDStoreBuff[i].buff)]);
end;

class function TKDT17DC.Vec(const s: SystemString): TKDT17DC_Vec;
var
  t: TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j: NativeInt;
begin
  for i := 0 to KDT17DC_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            Inc(j);
            if j >= KDT17DC_Axis then
                Break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT17DC.Vec(const v: TKDT17DC_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT17DC_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT17DC.Distance(const v1, v2: TKDT17DC_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT17DC_Axis - 1 do
      Result := Result + (v2[i] - v1[i]) * (v2[i] - v1[i]);
end;

procedure TKDT17DC.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT17DC_Source; const Data: Pointer);
begin
  Source.buff := TestBuff[IndexFor];
  Source.Token := umlIntToStr(IndexFor);
end;

class procedure TKDT17DC.Test;
var
  TKDT17DC_Test: TKDT17DC;
  t: TTimeTick;
  i, j: NativeInt;
  TestResultBuff: TKDT17DC_DynamicVecBuffer;
  TestResultIndex: TKMIntegerArray;
  KMeanOutIndex: TKMIntegerArray;
  errored: Boolean;
  m64: TMemoryStream64;
  p: PKDT17DC_Node;
  n: TPascalString;
begin
  errored := False;
  n := PFormat('test %s...', [ClassName]);
  t := GetTimeTick;

  n.Append('...build');
  TKDT17DC_Test := TKDT17DC.Create;

  n.Append('...');
  SetLength(TKDT17DC_Test.TestBuff, 1000);
  for i := 0 to length(TKDT17DC_Test.TestBuff) - 1 do
    for j := 0 to KDT17DC_Axis - 1 do
        TKDT17DC_Test.TestBuff[i][j] := i * KDT17DC_Axis + j;

{$IFDEF FPC}
  TKDT17DC_Test.BuildKDTreeM(length(TKDT17DC_Test.TestBuff), nil, @TKDT17DC_Test.Test_BuildM);
{$ELSE FPC}
  TKDT17DC_Test.BuildKDTreeM(length(TKDT17DC_Test.TestBuff), nil, TKDT17DC_Test.Test_BuildM);
{$ENDIF FPC}
  { save/load test }
  n.Append('...save/load');
  m64 := TMemoryStream64.CustomCreate(1024 * 1024);
  TKDT17DC_Test.SaveToStream(m64);
  m64.Position := 0;
  TKDT17DC_Test.LoadFromStream(m64);
  for i := 0 to length(TKDT17DC_Test.TestBuff) - 1 do
    begin
      p := TKDT17DC_Test.Search(TKDT17DC_Test.TestBuff[i]);
      if p^.Vec^.Index <> i then
          errored := True;
      if not p^.Vec^.Token.Same(umlIntToStr(i)) then
          errored := True;
      if errored then
          Break;
    end;
  DisposeObject(m64);

  if not errored then
    begin
      { parallel search test }
      n.Append('...parallel');
      SetLength(TestResultBuff, length(TKDT17DC_Test.TestBuff));
      SetLength(TestResultIndex, length(TKDT17DC_Test.TestBuff));
      TKDT17DC_Test.Search(TKDT17DC_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if Distance(TKDT17DC_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
            errored := True;
    end;

  if not errored then
    begin
      n.Append('...kMean');
      TKDT17DC_Test.Clear;
      { kMean test }
      TKDT17DC_Test.BuildKDTreeWithCluster(TKDT17DC_Test.TestBuff, 10, 1, KMeanOutIndex);
      { parallel search test }
      TKDT17DC_Test.Search(TKDT17DC_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if TestResultIndex[i] <> KMeanOutIndex[i] then
            errored := True;
    end;

  SetLength(TKDT17DC_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT17DC_Test.Clear;

  n.Append('...');
  if errored then
      n.Append('error!')
  else
      n.Append('passed ok %dms', [GetTimeTick - t]);
  DisposeObject(TKDT17DC_Test);
  DoStatus(n);
  n := '';
end;

function TKDT18DC.InternalBuildKdTree(const KDSourceBufferPtr: PKDT18DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT18DC_Node;
  function SortCompare(const p1, p2: PKDT18DC_Source; const axis: NativeInt): ShortInt;
  begin
    if p1^.buff[axis] = p2^.buff[axis] then
      begin
        if p1^.Index = p2^.Index then
            Result := 0
        else if p1^.Index < p2^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.buff[axis] < p2^.buff[axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT18DC_SourceBuffer; L, R: NativeInt; const axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT18DC_Source;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer^[(L + R) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, axis) < 0 do
            Inc(i);
        while SortCompare(SortBuffer^[j], p, axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, axis);
      L := i;
    until i >= R;
  end;

var
  M: NativeInt;
  axis: NativeInt;
  kdBuffPtr: PKDT18DC_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      new(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.Vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);
    end
  else
    begin
      axis := Depth mod KDT18DC_Axis;
      M := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr^[0], 0, PlanCount - 1, axis);

      new(Result);
      Result^.Parent := nil;
      Result^.Vec := kdBuffPtr^[M];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], M, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[M + 1], PlanCount - (M + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT18DC.GetData(const Index: NativeInt): PKDT18DC_Source;
begin
  Result := @KDStoreBuff[Index];
end;

constructor TKDT18DC.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT18DC.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT18DC.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT18DC_Node(KDNodes[i]));
      Inc(i);
    end;

  for i := 0 to length(KDStoreBuff) - 1 do
      KDStoreBuff[i].Token := '';

  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT18DC.StoreBuffPtr: PKDT18DC_DyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT18DC.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT18DC_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT18DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT18DC.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT18DC_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT18DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT18DC.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT18DC_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT18DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{ k-means++ clusterization }
procedure TKDT18DC.BuildKDTreeWithCluster(const inBuff: TKDT18DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  SetLength(Source, length(inBuff), KDT18DC_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT18DC_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT18DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT18DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT18DC.BuildKDTreeWithCluster(const inBuff: TKDT18DC_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TKMIntegerArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT18DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT18DC_BuildCall);
var
  TempStoreBuff: TKDT18DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT18DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT18DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT18DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT18DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT18DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT18DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT18DC_BuildMethod);
var
  TempStoreBuff: TKDT18DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT18DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT18DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT18DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT18DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT18DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT18DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT18DC_BuildProc);
var
  TempStoreBuff: TKDT18DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT18DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT18DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT18DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT18DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT18DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

function TKDT18DC.Search(const buff: TKDT18DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT18DC_Node;

var
  NearestNeighbour: PKDT18DC_Node;

  function FindParentNode(const buffPtr: PKDT18DC_Vec; NodePtr: PKDT18DC_Node): PKDT18DC_Node;
  var
    Next: PKDT18DC_Node;
    Depth, axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        axis := Depth mod KDT18DC_Axis;
        if buffPtr^[axis] > Next^.Vec^.buff[axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT18DC_Node; const buffPtr: PKDT18DC_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    Inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := Distance(buffPtr^, NodePtr^.Vec^.buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.Vec^.Index < NearestNeighbour^.Vec^.Index) then
        NearestNeighbour := NodePtr;

    axis := Depth mod KDT18DC_Axis;
    Dist := NodePtr^.Vec^.buff[axis] - buffPtr^[axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.Vec^.buff[axis] > buffPtr^[axis] then
            ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const buffPtr: PKDT18DC_Vec; const p1, p2: PKDT18DC_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := Distance(buffPtr^, p1^.Vec^.buff);
    d2 := Distance(buffPtr^, p2^.Vec^.buff);
    if d1 = d2 then
      begin
        if p1^.Vec^.Index = p2^.Vec^.Index then
            Result := 0
        else if p1^.Vec^.Index < p2^.Vec^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; L, R: NativeInt; const buffPtr: PKDT18DC_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT18DC_Node;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer[(L + R) shr 1];
      repeat
        while SortCompare(buffPtr, SortBuffer[i], p) < 0 do
            Inc(i);
        while SortCompare(buffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, buffPtr);
      L := i;
    until i >= R;
  end;

var
  Parent: PKDT18DC_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := Distance(buff, Parent^.Vec^.buff);

  ScanSubtree(RootNode, @buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT18DC_Node(NearestNodes[0]);
    end;
end;

function TKDT18DC.Search(const buff: TKDT18DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT18DC_Node;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT18DC.Search(const buff: TKDT18DC_Vec; var SearchedDistanceMin: Double): PKDT18DC_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT18DC.Search(const buff: TKDT18DC_Vec): PKDT18DC_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT18DC.SearchToken(const buff: TKDT18DC_Vec): TPascalString;
var
  p: PKDT18DC_Node;
begin
  p := Search(buff);
  if p <> nil then
      Result := p^.Vec^.Token
  else
      Result := '';
end;

procedure TKDT18DC.Search(const inBuff: TKDT18DC_DynamicVecBuffer; var OutBuff: TKDT18DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT18DC_DynamicVecBuffer;
  outBuffPtr: PKDT18DC_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT18DC_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outBuffPtr^[pass] := p^.Vec^.buff;
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT18DC_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outBuffPtr^[pass] := p^.Vec^.buff;
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT18DC_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.Vec^.buff;
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT18DC.Search(const inBuff: TKDT18DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT18DC_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT18DC_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT18DC_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT18DC_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT18DC.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  ID := KDT18DC_Axis;

  stream.write(st, 4);
  stream.write(ID, 4);

  stream.write(cnt, 8);

  i := 0;
  while i < cnt do
    begin
      stream.write(KDStoreBuff[i].buff[0], SizeOf(TKDT18DC_Vec));
      stream.write(KDStoreBuff[i].Index, 8);
      token_B := KDStoreBuff[i].Token.Bytes;
      token_L := length(token_B);
      stream.write(token_L, 4);
      if token_L > 0 then
        begin
          stream.write(token_B[0], token_L);
          SetLength(token_B, 0);
        end;
      Inc(i);
    end;
end;

procedure TKDT18DC.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  Clear;

  stream.read(st, 4);
  stream.read(ID, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if ID <> KDT18DC_Axis then
      RaiseInfo('kdtree axis error!');

  stream.read(cnt, 8);

  SetLength(KDStoreBuff, cnt);

  i := 0;
  try
    while i < cnt do
      begin
        if stream.read(KDStoreBuff[i].buff[0], SizeOf(TKDT18DC_Vec)) <> SizeOf(TKDT18DC_Vec) then
          begin
            Clear;
            Exit;
          end;
        if stream.read(KDStoreBuff[i].Index, 8) <> 8 then
          begin
            Clear;
            Exit;
          end;
        if stream.read(token_L, 4) <> 4 then
          begin
            Clear;
            Exit;
          end;
        if token_L > 0 then
          begin
            SetLength(token_B, token_L);
            if stream.read(token_B[0], token_L) <> token_L then
              begin
                Clear;
                Exit;
              end;
            KDStoreBuff[i].Token.Bytes := token_B;
            SetLength(token_B, 0);
          end
        else
            KDStoreBuff[i].Token := '';
        Inc(i);
      end;
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      Inc(i);
    end;

  if cnt > 0 then
      RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT18DC.SaveToFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(FileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT18DC.LoadFromFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT18DC.PrintNodeTree(const NodePtr: PKDT18DC_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT18DC_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.Vec^.Index, Vec(p^.Vec^.buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT18DC.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d - %d : %s ', [i, KDStoreBuff[i].Index, Vec(KDStoreBuff[i].buff)]);
end;

class function TKDT18DC.Vec(const s: SystemString): TKDT18DC_Vec;
var
  t: TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j: NativeInt;
begin
  for i := 0 to KDT18DC_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            Inc(j);
            if j >= KDT18DC_Axis then
                Break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT18DC.Vec(const v: TKDT18DC_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT18DC_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT18DC.Distance(const v1, v2: TKDT18DC_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT18DC_Axis - 1 do
      Result := Result + (v2[i] - v1[i]) * (v2[i] - v1[i]);
end;

procedure TKDT18DC.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT18DC_Source; const Data: Pointer);
begin
  Source.buff := TestBuff[IndexFor];
  Source.Token := umlIntToStr(IndexFor);
end;

class procedure TKDT18DC.Test;
var
  TKDT18DC_Test: TKDT18DC;
  t: TTimeTick;
  i, j: NativeInt;
  TestResultBuff: TKDT18DC_DynamicVecBuffer;
  TestResultIndex: TKMIntegerArray;
  KMeanOutIndex: TKMIntegerArray;
  errored: Boolean;
  m64: TMemoryStream64;
  p: PKDT18DC_Node;
  n: TPascalString;
begin
  errored := False;
  n := PFormat('test %s...', [ClassName]);
  t := GetTimeTick;

  n.Append('...build');
  TKDT18DC_Test := TKDT18DC.Create;

  n.Append('...');
  SetLength(TKDT18DC_Test.TestBuff, 1000);
  for i := 0 to length(TKDT18DC_Test.TestBuff) - 1 do
    for j := 0 to KDT18DC_Axis - 1 do
        TKDT18DC_Test.TestBuff[i][j] := i * KDT18DC_Axis + j;

{$IFDEF FPC}
  TKDT18DC_Test.BuildKDTreeM(length(TKDT18DC_Test.TestBuff), nil, @TKDT18DC_Test.Test_BuildM);
{$ELSE FPC}
  TKDT18DC_Test.BuildKDTreeM(length(TKDT18DC_Test.TestBuff), nil, TKDT18DC_Test.Test_BuildM);
{$ENDIF FPC}
  { save/load test }
  n.Append('...save/load');
  m64 := TMemoryStream64.CustomCreate(1024 * 1024);
  TKDT18DC_Test.SaveToStream(m64);
  m64.Position := 0;
  TKDT18DC_Test.LoadFromStream(m64);
  for i := 0 to length(TKDT18DC_Test.TestBuff) - 1 do
    begin
      p := TKDT18DC_Test.Search(TKDT18DC_Test.TestBuff[i]);
      if p^.Vec^.Index <> i then
          errored := True;
      if not p^.Vec^.Token.Same(umlIntToStr(i)) then
          errored := True;
      if errored then
          Break;
    end;
  DisposeObject(m64);

  if not errored then
    begin
      { parallel search test }
      n.Append('...parallel');
      SetLength(TestResultBuff, length(TKDT18DC_Test.TestBuff));
      SetLength(TestResultIndex, length(TKDT18DC_Test.TestBuff));
      TKDT18DC_Test.Search(TKDT18DC_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if Distance(TKDT18DC_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
            errored := True;
    end;

  if not errored then
    begin
      n.Append('...kMean');
      TKDT18DC_Test.Clear;
      { kMean test }
      TKDT18DC_Test.BuildKDTreeWithCluster(TKDT18DC_Test.TestBuff, 10, 1, KMeanOutIndex);
      { parallel search test }
      TKDT18DC_Test.Search(TKDT18DC_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if TestResultIndex[i] <> KMeanOutIndex[i] then
            errored := True;
    end;

  SetLength(TKDT18DC_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT18DC_Test.Clear;

  n.Append('...');
  if errored then
      n.Append('error!')
  else
      n.Append('passed ok %dms', [GetTimeTick - t]);
  DisposeObject(TKDT18DC_Test);
  DoStatus(n);
  n := '';
end;

function TKDT19DC.InternalBuildKdTree(const KDSourceBufferPtr: PKDT19DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT19DC_Node;
  function SortCompare(const p1, p2: PKDT19DC_Source; const axis: NativeInt): ShortInt;
  begin
    if p1^.buff[axis] = p2^.buff[axis] then
      begin
        if p1^.Index = p2^.Index then
            Result := 0
        else if p1^.Index < p2^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.buff[axis] < p2^.buff[axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT19DC_SourceBuffer; L, R: NativeInt; const axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT19DC_Source;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer^[(L + R) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, axis) < 0 do
            Inc(i);
        while SortCompare(SortBuffer^[j], p, axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, axis);
      L := i;
    until i >= R;
  end;

var
  M: NativeInt;
  axis: NativeInt;
  kdBuffPtr: PKDT19DC_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      new(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.Vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);
    end
  else
    begin
      axis := Depth mod KDT19DC_Axis;
      M := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr^[0], 0, PlanCount - 1, axis);

      new(Result);
      Result^.Parent := nil;
      Result^.Vec := kdBuffPtr^[M];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], M, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[M + 1], PlanCount - (M + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT19DC.GetData(const Index: NativeInt): PKDT19DC_Source;
begin
  Result := @KDStoreBuff[Index];
end;

constructor TKDT19DC.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT19DC.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT19DC.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT19DC_Node(KDNodes[i]));
      Inc(i);
    end;

  for i := 0 to length(KDStoreBuff) - 1 do
      KDStoreBuff[i].Token := '';

  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT19DC.StoreBuffPtr: PKDT19DC_DyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT19DC.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT19DC_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT19DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT19DC.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT19DC_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT19DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT19DC.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT19DC_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT19DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{ k-means++ clusterization }
procedure TKDT19DC.BuildKDTreeWithCluster(const inBuff: TKDT19DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  SetLength(Source, length(inBuff), KDT19DC_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT19DC_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT19DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT19DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT19DC.BuildKDTreeWithCluster(const inBuff: TKDT19DC_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TKMIntegerArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT19DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT19DC_BuildCall);
var
  TempStoreBuff: TKDT19DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT19DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT19DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT19DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT19DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT19DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT19DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT19DC_BuildMethod);
var
  TempStoreBuff: TKDT19DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT19DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT19DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT19DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT19DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT19DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT19DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT19DC_BuildProc);
var
  TempStoreBuff: TKDT19DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT19DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT19DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT19DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT19DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT19DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

function TKDT19DC.Search(const buff: TKDT19DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT19DC_Node;

var
  NearestNeighbour: PKDT19DC_Node;

  function FindParentNode(const buffPtr: PKDT19DC_Vec; NodePtr: PKDT19DC_Node): PKDT19DC_Node;
  var
    Next: PKDT19DC_Node;
    Depth, axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        axis := Depth mod KDT19DC_Axis;
        if buffPtr^[axis] > Next^.Vec^.buff[axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT19DC_Node; const buffPtr: PKDT19DC_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    Inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := Distance(buffPtr^, NodePtr^.Vec^.buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.Vec^.Index < NearestNeighbour^.Vec^.Index) then
        NearestNeighbour := NodePtr;

    axis := Depth mod KDT19DC_Axis;
    Dist := NodePtr^.Vec^.buff[axis] - buffPtr^[axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.Vec^.buff[axis] > buffPtr^[axis] then
            ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const buffPtr: PKDT19DC_Vec; const p1, p2: PKDT19DC_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := Distance(buffPtr^, p1^.Vec^.buff);
    d2 := Distance(buffPtr^, p2^.Vec^.buff);
    if d1 = d2 then
      begin
        if p1^.Vec^.Index = p2^.Vec^.Index then
            Result := 0
        else if p1^.Vec^.Index < p2^.Vec^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; L, R: NativeInt; const buffPtr: PKDT19DC_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT19DC_Node;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer[(L + R) shr 1];
      repeat
        while SortCompare(buffPtr, SortBuffer[i], p) < 0 do
            Inc(i);
        while SortCompare(buffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, buffPtr);
      L := i;
    until i >= R;
  end;

var
  Parent: PKDT19DC_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := Distance(buff, Parent^.Vec^.buff);

  ScanSubtree(RootNode, @buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT19DC_Node(NearestNodes[0]);
    end;
end;

function TKDT19DC.Search(const buff: TKDT19DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT19DC_Node;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT19DC.Search(const buff: TKDT19DC_Vec; var SearchedDistanceMin: Double): PKDT19DC_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT19DC.Search(const buff: TKDT19DC_Vec): PKDT19DC_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT19DC.SearchToken(const buff: TKDT19DC_Vec): TPascalString;
var
  p: PKDT19DC_Node;
begin
  p := Search(buff);
  if p <> nil then
      Result := p^.Vec^.Token
  else
      Result := '';
end;

procedure TKDT19DC.Search(const inBuff: TKDT19DC_DynamicVecBuffer; var OutBuff: TKDT19DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT19DC_DynamicVecBuffer;
  outBuffPtr: PKDT19DC_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT19DC_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outBuffPtr^[pass] := p^.Vec^.buff;
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT19DC_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outBuffPtr^[pass] := p^.Vec^.buff;
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT19DC_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.Vec^.buff;
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT19DC.Search(const inBuff: TKDT19DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT19DC_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT19DC_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT19DC_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT19DC_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT19DC.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  ID := KDT19DC_Axis;

  stream.write(st, 4);
  stream.write(ID, 4);

  stream.write(cnt, 8);

  i := 0;
  while i < cnt do
    begin
      stream.write(KDStoreBuff[i].buff[0], SizeOf(TKDT19DC_Vec));
      stream.write(KDStoreBuff[i].Index, 8);
      token_B := KDStoreBuff[i].Token.Bytes;
      token_L := length(token_B);
      stream.write(token_L, 4);
      if token_L > 0 then
        begin
          stream.write(token_B[0], token_L);
          SetLength(token_B, 0);
        end;
      Inc(i);
    end;
end;

procedure TKDT19DC.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  Clear;

  stream.read(st, 4);
  stream.read(ID, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if ID <> KDT19DC_Axis then
      RaiseInfo('kdtree axis error!');

  stream.read(cnt, 8);

  SetLength(KDStoreBuff, cnt);

  i := 0;
  try
    while i < cnt do
      begin
        if stream.read(KDStoreBuff[i].buff[0], SizeOf(TKDT19DC_Vec)) <> SizeOf(TKDT19DC_Vec) then
          begin
            Clear;
            Exit;
          end;
        if stream.read(KDStoreBuff[i].Index, 8) <> 8 then
          begin
            Clear;
            Exit;
          end;
        if stream.read(token_L, 4) <> 4 then
          begin
            Clear;
            Exit;
          end;
        if token_L > 0 then
          begin
            SetLength(token_B, token_L);
            if stream.read(token_B[0], token_L) <> token_L then
              begin
                Clear;
                Exit;
              end;
            KDStoreBuff[i].Token.Bytes := token_B;
            SetLength(token_B, 0);
          end
        else
            KDStoreBuff[i].Token := '';
        Inc(i);
      end;
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      Inc(i);
    end;

  if cnt > 0 then
      RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT19DC.SaveToFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(FileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT19DC.LoadFromFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT19DC.PrintNodeTree(const NodePtr: PKDT19DC_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT19DC_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.Vec^.Index, Vec(p^.Vec^.buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT19DC.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d - %d : %s ', [i, KDStoreBuff[i].Index, Vec(KDStoreBuff[i].buff)]);
end;

class function TKDT19DC.Vec(const s: SystemString): TKDT19DC_Vec;
var
  t: TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j: NativeInt;
begin
  for i := 0 to KDT19DC_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            Inc(j);
            if j >= KDT19DC_Axis then
                Break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT19DC.Vec(const v: TKDT19DC_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT19DC_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT19DC.Distance(const v1, v2: TKDT19DC_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT19DC_Axis - 1 do
      Result := Result + (v2[i] - v1[i]) * (v2[i] - v1[i]);
end;

procedure TKDT19DC.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT19DC_Source; const Data: Pointer);
begin
  Source.buff := TestBuff[IndexFor];
  Source.Token := umlIntToStr(IndexFor);
end;

class procedure TKDT19DC.Test;
var
  TKDT19DC_Test: TKDT19DC;
  t: TTimeTick;
  i, j: NativeInt;
  TestResultBuff: TKDT19DC_DynamicVecBuffer;
  TestResultIndex: TKMIntegerArray;
  KMeanOutIndex: TKMIntegerArray;
  errored: Boolean;
  m64: TMemoryStream64;
  p: PKDT19DC_Node;
  n: TPascalString;
begin
  errored := False;
  n := PFormat('test %s...', [ClassName]);
  t := GetTimeTick;

  n.Append('...build');
  TKDT19DC_Test := TKDT19DC.Create;

  n.Append('...');
  SetLength(TKDT19DC_Test.TestBuff, 1000);
  for i := 0 to length(TKDT19DC_Test.TestBuff) - 1 do
    for j := 0 to KDT19DC_Axis - 1 do
        TKDT19DC_Test.TestBuff[i][j] := i * KDT19DC_Axis + j;

{$IFDEF FPC}
  TKDT19DC_Test.BuildKDTreeM(length(TKDT19DC_Test.TestBuff), nil, @TKDT19DC_Test.Test_BuildM);
{$ELSE FPC}
  TKDT19DC_Test.BuildKDTreeM(length(TKDT19DC_Test.TestBuff), nil, TKDT19DC_Test.Test_BuildM);
{$ENDIF FPC}
  { save/load test }
  n.Append('...save/load');
  m64 := TMemoryStream64.CustomCreate(1024 * 1024);
  TKDT19DC_Test.SaveToStream(m64);
  m64.Position := 0;
  TKDT19DC_Test.LoadFromStream(m64);
  for i := 0 to length(TKDT19DC_Test.TestBuff) - 1 do
    begin
      p := TKDT19DC_Test.Search(TKDT19DC_Test.TestBuff[i]);
      if p^.Vec^.Index <> i then
          errored := True;
      if not p^.Vec^.Token.Same(umlIntToStr(i)) then
          errored := True;
      if errored then
          Break;
    end;
  DisposeObject(m64);

  if not errored then
    begin
      { parallel search test }
      n.Append('...parallel');
      SetLength(TestResultBuff, length(TKDT19DC_Test.TestBuff));
      SetLength(TestResultIndex, length(TKDT19DC_Test.TestBuff));
      TKDT19DC_Test.Search(TKDT19DC_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if Distance(TKDT19DC_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
            errored := True;
    end;

  if not errored then
    begin
      n.Append('...kMean');
      TKDT19DC_Test.Clear;
      { kMean test }
      TKDT19DC_Test.BuildKDTreeWithCluster(TKDT19DC_Test.TestBuff, 10, 1, KMeanOutIndex);
      { parallel search test }
      TKDT19DC_Test.Search(TKDT19DC_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if TestResultIndex[i] <> KMeanOutIndex[i] then
            errored := True;
    end;

  SetLength(TKDT19DC_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT19DC_Test.Clear;

  n.Append('...');
  if errored then
      n.Append('error!')
  else
      n.Append('passed ok %dms', [GetTimeTick - t]);
  DisposeObject(TKDT19DC_Test);
  DoStatus(n);
  n := '';
end;

function TKDT20DC.InternalBuildKdTree(const KDSourceBufferPtr: PKDT20DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT20DC_Node;
  function SortCompare(const p1, p2: PKDT20DC_Source; const axis: NativeInt): ShortInt;
  begin
    if p1^.buff[axis] = p2^.buff[axis] then
      begin
        if p1^.Index = p2^.Index then
            Result := 0
        else if p1^.Index < p2^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.buff[axis] < p2^.buff[axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT20DC_SourceBuffer; L, R: NativeInt; const axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT20DC_Source;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer^[(L + R) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, axis) < 0 do
            Inc(i);
        while SortCompare(SortBuffer^[j], p, axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, axis);
      L := i;
    until i >= R;
  end;

var
  M: NativeInt;
  axis: NativeInt;
  kdBuffPtr: PKDT20DC_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      new(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.Vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);
    end
  else
    begin
      axis := Depth mod KDT20DC_Axis;
      M := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr^[0], 0, PlanCount - 1, axis);

      new(Result);
      Result^.Parent := nil;
      Result^.Vec := kdBuffPtr^[M];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], M, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[M + 1], PlanCount - (M + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT20DC.GetData(const Index: NativeInt): PKDT20DC_Source;
begin
  Result := @KDStoreBuff[Index];
end;

constructor TKDT20DC.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT20DC.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT20DC.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT20DC_Node(KDNodes[i]));
      Inc(i);
    end;

  for i := 0 to length(KDStoreBuff) - 1 do
      KDStoreBuff[i].Token := '';

  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT20DC.StoreBuffPtr: PKDT20DC_DyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT20DC.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT20DC_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT20DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT20DC.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT20DC_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT20DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT20DC.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT20DC_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT20DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{ k-means++ clusterization }
procedure TKDT20DC.BuildKDTreeWithCluster(const inBuff: TKDT20DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  SetLength(Source, length(inBuff), KDT20DC_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT20DC_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT20DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT20DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT20DC.BuildKDTreeWithCluster(const inBuff: TKDT20DC_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TKMIntegerArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT20DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT20DC_BuildCall);
var
  TempStoreBuff: TKDT20DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT20DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT20DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT20DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT20DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT20DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT20DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT20DC_BuildMethod);
var
  TempStoreBuff: TKDT20DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT20DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT20DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT20DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT20DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT20DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT20DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT20DC_BuildProc);
var
  TempStoreBuff: TKDT20DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT20DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT20DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT20DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT20DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT20DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

function TKDT20DC.Search(const buff: TKDT20DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT20DC_Node;

var
  NearestNeighbour: PKDT20DC_Node;

  function FindParentNode(const buffPtr: PKDT20DC_Vec; NodePtr: PKDT20DC_Node): PKDT20DC_Node;
  var
    Next: PKDT20DC_Node;
    Depth, axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        axis := Depth mod KDT20DC_Axis;
        if buffPtr^[axis] > Next^.Vec^.buff[axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT20DC_Node; const buffPtr: PKDT20DC_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    Inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := Distance(buffPtr^, NodePtr^.Vec^.buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.Vec^.Index < NearestNeighbour^.Vec^.Index) then
        NearestNeighbour := NodePtr;

    axis := Depth mod KDT20DC_Axis;
    Dist := NodePtr^.Vec^.buff[axis] - buffPtr^[axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.Vec^.buff[axis] > buffPtr^[axis] then
            ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const buffPtr: PKDT20DC_Vec; const p1, p2: PKDT20DC_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := Distance(buffPtr^, p1^.Vec^.buff);
    d2 := Distance(buffPtr^, p2^.Vec^.buff);
    if d1 = d2 then
      begin
        if p1^.Vec^.Index = p2^.Vec^.Index then
            Result := 0
        else if p1^.Vec^.Index < p2^.Vec^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; L, R: NativeInt; const buffPtr: PKDT20DC_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT20DC_Node;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer[(L + R) shr 1];
      repeat
        while SortCompare(buffPtr, SortBuffer[i], p) < 0 do
            Inc(i);
        while SortCompare(buffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, buffPtr);
      L := i;
    until i >= R;
  end;

var
  Parent: PKDT20DC_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := Distance(buff, Parent^.Vec^.buff);

  ScanSubtree(RootNode, @buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT20DC_Node(NearestNodes[0]);
    end;
end;

function TKDT20DC.Search(const buff: TKDT20DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT20DC_Node;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT20DC.Search(const buff: TKDT20DC_Vec; var SearchedDistanceMin: Double): PKDT20DC_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT20DC.Search(const buff: TKDT20DC_Vec): PKDT20DC_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT20DC.SearchToken(const buff: TKDT20DC_Vec): TPascalString;
var
  p: PKDT20DC_Node;
begin
  p := Search(buff);
  if p <> nil then
      Result := p^.Vec^.Token
  else
      Result := '';
end;

procedure TKDT20DC.Search(const inBuff: TKDT20DC_DynamicVecBuffer; var OutBuff: TKDT20DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT20DC_DynamicVecBuffer;
  outBuffPtr: PKDT20DC_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT20DC_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outBuffPtr^[pass] := p^.Vec^.buff;
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT20DC_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outBuffPtr^[pass] := p^.Vec^.buff;
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT20DC_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.Vec^.buff;
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT20DC.Search(const inBuff: TKDT20DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT20DC_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT20DC_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT20DC_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT20DC_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT20DC.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  ID := KDT20DC_Axis;

  stream.write(st, 4);
  stream.write(ID, 4);

  stream.write(cnt, 8);

  i := 0;
  while i < cnt do
    begin
      stream.write(KDStoreBuff[i].buff[0], SizeOf(TKDT20DC_Vec));
      stream.write(KDStoreBuff[i].Index, 8);
      token_B := KDStoreBuff[i].Token.Bytes;
      token_L := length(token_B);
      stream.write(token_L, 4);
      if token_L > 0 then
        begin
          stream.write(token_B[0], token_L);
          SetLength(token_B, 0);
        end;
      Inc(i);
    end;
end;

procedure TKDT20DC.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  Clear;

  stream.read(st, 4);
  stream.read(ID, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if ID <> KDT20DC_Axis then
      RaiseInfo('kdtree axis error!');

  stream.read(cnt, 8);

  SetLength(KDStoreBuff, cnt);

  i := 0;
  try
    while i < cnt do
      begin
        if stream.read(KDStoreBuff[i].buff[0], SizeOf(TKDT20DC_Vec)) <> SizeOf(TKDT20DC_Vec) then
          begin
            Clear;
            Exit;
          end;
        if stream.read(KDStoreBuff[i].Index, 8) <> 8 then
          begin
            Clear;
            Exit;
          end;
        if stream.read(token_L, 4) <> 4 then
          begin
            Clear;
            Exit;
          end;
        if token_L > 0 then
          begin
            SetLength(token_B, token_L);
            if stream.read(token_B[0], token_L) <> token_L then
              begin
                Clear;
                Exit;
              end;
            KDStoreBuff[i].Token.Bytes := token_B;
            SetLength(token_B, 0);
          end
        else
            KDStoreBuff[i].Token := '';
        Inc(i);
      end;
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      Inc(i);
    end;

  if cnt > 0 then
      RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT20DC.SaveToFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(FileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT20DC.LoadFromFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT20DC.PrintNodeTree(const NodePtr: PKDT20DC_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT20DC_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.Vec^.Index, Vec(p^.Vec^.buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT20DC.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d - %d : %s ', [i, KDStoreBuff[i].Index, Vec(KDStoreBuff[i].buff)]);
end;

class function TKDT20DC.Vec(const s: SystemString): TKDT20DC_Vec;
var
  t: TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j: NativeInt;
begin
  for i := 0 to KDT20DC_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            Inc(j);
            if j >= KDT20DC_Axis then
                Break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT20DC.Vec(const v: TKDT20DC_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT20DC_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT20DC.Distance(const v1, v2: TKDT20DC_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT20DC_Axis - 1 do
      Result := Result + (v2[i] - v1[i]) * (v2[i] - v1[i]);
end;

procedure TKDT20DC.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT20DC_Source; const Data: Pointer);
begin
  Source.buff := TestBuff[IndexFor];
  Source.Token := umlIntToStr(IndexFor);
end;

class procedure TKDT20DC.Test;
var
  TKDT20DC_Test: TKDT20DC;
  t: TTimeTick;
  i, j: NativeInt;
  TestResultBuff: TKDT20DC_DynamicVecBuffer;
  TestResultIndex: TKMIntegerArray;
  KMeanOutIndex: TKMIntegerArray;
  errored: Boolean;
  m64: TMemoryStream64;
  p: PKDT20DC_Node;
  n: TPascalString;
begin
  errored := False;
  n := PFormat('test %s...', [ClassName]);
  t := GetTimeTick;

  n.Append('...build');
  TKDT20DC_Test := TKDT20DC.Create;

  n.Append('...');
  SetLength(TKDT20DC_Test.TestBuff, 1000);
  for i := 0 to length(TKDT20DC_Test.TestBuff) - 1 do
    for j := 0 to KDT20DC_Axis - 1 do
        TKDT20DC_Test.TestBuff[i][j] := i * KDT20DC_Axis + j;

{$IFDEF FPC}
  TKDT20DC_Test.BuildKDTreeM(length(TKDT20DC_Test.TestBuff), nil, @TKDT20DC_Test.Test_BuildM);
{$ELSE FPC}
  TKDT20DC_Test.BuildKDTreeM(length(TKDT20DC_Test.TestBuff), nil, TKDT20DC_Test.Test_BuildM);
{$ENDIF FPC}
  { save/load test }
  n.Append('...save/load');
  m64 := TMemoryStream64.CustomCreate(1024 * 1024);
  TKDT20DC_Test.SaveToStream(m64);
  m64.Position := 0;
  TKDT20DC_Test.LoadFromStream(m64);
  for i := 0 to length(TKDT20DC_Test.TestBuff) - 1 do
    begin
      p := TKDT20DC_Test.Search(TKDT20DC_Test.TestBuff[i]);
      if p^.Vec^.Index <> i then
          errored := True;
      if not p^.Vec^.Token.Same(umlIntToStr(i)) then
          errored := True;
      if errored then
          Break;
    end;
  DisposeObject(m64);

  if not errored then
    begin
      { parallel search test }
      n.Append('...parallel');
      SetLength(TestResultBuff, length(TKDT20DC_Test.TestBuff));
      SetLength(TestResultIndex, length(TKDT20DC_Test.TestBuff));
      TKDT20DC_Test.Search(TKDT20DC_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if Distance(TKDT20DC_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
            errored := True;
    end;

  if not errored then
    begin
      n.Append('...kMean');
      TKDT20DC_Test.Clear;
      { kMean test }
      TKDT20DC_Test.BuildKDTreeWithCluster(TKDT20DC_Test.TestBuff, 10, 1, KMeanOutIndex);
      { parallel search test }
      TKDT20DC_Test.Search(TKDT20DC_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if TestResultIndex[i] <> KMeanOutIndex[i] then
            errored := True;
    end;

  SetLength(TKDT20DC_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT20DC_Test.Clear;

  n.Append('...');
  if errored then
      n.Append('error!')
  else
      n.Append('passed ok %dms', [GetTimeTick - t]);
  DisposeObject(TKDT20DC_Test);
  DoStatus(n);
  n := '';
end;

function TKDT21DC.InternalBuildKdTree(const KDSourceBufferPtr: PKDT21DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT21DC_Node;
  function SortCompare(const p1, p2: PKDT21DC_Source; const axis: NativeInt): ShortInt;
  begin
    if p1^.buff[axis] = p2^.buff[axis] then
      begin
        if p1^.Index = p2^.Index then
            Result := 0
        else if p1^.Index < p2^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.buff[axis] < p2^.buff[axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT21DC_SourceBuffer; L, R: NativeInt; const axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT21DC_Source;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer^[(L + R) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, axis) < 0 do
            Inc(i);
        while SortCompare(SortBuffer^[j], p, axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, axis);
      L := i;
    until i >= R;
  end;

var
  M: NativeInt;
  axis: NativeInt;
  kdBuffPtr: PKDT21DC_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      new(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.Vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);
    end
  else
    begin
      axis := Depth mod KDT21DC_Axis;
      M := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr^[0], 0, PlanCount - 1, axis);

      new(Result);
      Result^.Parent := nil;
      Result^.Vec := kdBuffPtr^[M];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], M, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[M + 1], PlanCount - (M + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT21DC.GetData(const Index: NativeInt): PKDT21DC_Source;
begin
  Result := @KDStoreBuff[Index];
end;

constructor TKDT21DC.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT21DC.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT21DC.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT21DC_Node(KDNodes[i]));
      Inc(i);
    end;

  for i := 0 to length(KDStoreBuff) - 1 do
      KDStoreBuff[i].Token := '';

  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT21DC.StoreBuffPtr: PKDT21DC_DyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT21DC.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT21DC_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT21DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT21DC.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT21DC_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT21DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT21DC.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT21DC_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT21DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{ k-means++ clusterization }
procedure TKDT21DC.BuildKDTreeWithCluster(const inBuff: TKDT21DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  SetLength(Source, length(inBuff), KDT21DC_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT21DC_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT21DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT21DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT21DC.BuildKDTreeWithCluster(const inBuff: TKDT21DC_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TKMIntegerArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT21DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT21DC_BuildCall);
var
  TempStoreBuff: TKDT21DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT21DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT21DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT21DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT21DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT21DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT21DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT21DC_BuildMethod);
var
  TempStoreBuff: TKDT21DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT21DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT21DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT21DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT21DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT21DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT21DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT21DC_BuildProc);
var
  TempStoreBuff: TKDT21DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT21DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT21DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT21DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT21DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT21DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

function TKDT21DC.Search(const buff: TKDT21DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT21DC_Node;

var
  NearestNeighbour: PKDT21DC_Node;

  function FindParentNode(const buffPtr: PKDT21DC_Vec; NodePtr: PKDT21DC_Node): PKDT21DC_Node;
  var
    Next: PKDT21DC_Node;
    Depth, axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        axis := Depth mod KDT21DC_Axis;
        if buffPtr^[axis] > Next^.Vec^.buff[axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT21DC_Node; const buffPtr: PKDT21DC_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    Inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := Distance(buffPtr^, NodePtr^.Vec^.buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.Vec^.Index < NearestNeighbour^.Vec^.Index) then
        NearestNeighbour := NodePtr;

    axis := Depth mod KDT21DC_Axis;
    Dist := NodePtr^.Vec^.buff[axis] - buffPtr^[axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.Vec^.buff[axis] > buffPtr^[axis] then
            ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const buffPtr: PKDT21DC_Vec; const p1, p2: PKDT21DC_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := Distance(buffPtr^, p1^.Vec^.buff);
    d2 := Distance(buffPtr^, p2^.Vec^.buff);
    if d1 = d2 then
      begin
        if p1^.Vec^.Index = p2^.Vec^.Index then
            Result := 0
        else if p1^.Vec^.Index < p2^.Vec^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; L, R: NativeInt; const buffPtr: PKDT21DC_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT21DC_Node;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer[(L + R) shr 1];
      repeat
        while SortCompare(buffPtr, SortBuffer[i], p) < 0 do
            Inc(i);
        while SortCompare(buffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, buffPtr);
      L := i;
    until i >= R;
  end;

var
  Parent: PKDT21DC_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := Distance(buff, Parent^.Vec^.buff);

  ScanSubtree(RootNode, @buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT21DC_Node(NearestNodes[0]);
    end;
end;

function TKDT21DC.Search(const buff: TKDT21DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT21DC_Node;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT21DC.Search(const buff: TKDT21DC_Vec; var SearchedDistanceMin: Double): PKDT21DC_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT21DC.Search(const buff: TKDT21DC_Vec): PKDT21DC_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT21DC.SearchToken(const buff: TKDT21DC_Vec): TPascalString;
var
  p: PKDT21DC_Node;
begin
  p := Search(buff);
  if p <> nil then
      Result := p^.Vec^.Token
  else
      Result := '';
end;

procedure TKDT21DC.Search(const inBuff: TKDT21DC_DynamicVecBuffer; var OutBuff: TKDT21DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT21DC_DynamicVecBuffer;
  outBuffPtr: PKDT21DC_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT21DC_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outBuffPtr^[pass] := p^.Vec^.buff;
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT21DC_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outBuffPtr^[pass] := p^.Vec^.buff;
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT21DC_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.Vec^.buff;
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT21DC.Search(const inBuff: TKDT21DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT21DC_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT21DC_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT21DC_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT21DC_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT21DC.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  ID := KDT21DC_Axis;

  stream.write(st, 4);
  stream.write(ID, 4);

  stream.write(cnt, 8);

  i := 0;
  while i < cnt do
    begin
      stream.write(KDStoreBuff[i].buff[0], SizeOf(TKDT21DC_Vec));
      stream.write(KDStoreBuff[i].Index, 8);
      token_B := KDStoreBuff[i].Token.Bytes;
      token_L := length(token_B);
      stream.write(token_L, 4);
      if token_L > 0 then
        begin
          stream.write(token_B[0], token_L);
          SetLength(token_B, 0);
        end;
      Inc(i);
    end;
end;

procedure TKDT21DC.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  Clear;

  stream.read(st, 4);
  stream.read(ID, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if ID <> KDT21DC_Axis then
      RaiseInfo('kdtree axis error!');

  stream.read(cnt, 8);

  SetLength(KDStoreBuff, cnt);

  i := 0;
  try
    while i < cnt do
      begin
        if stream.read(KDStoreBuff[i].buff[0], SizeOf(TKDT21DC_Vec)) <> SizeOf(TKDT21DC_Vec) then
          begin
            Clear;
            Exit;
          end;
        if stream.read(KDStoreBuff[i].Index, 8) <> 8 then
          begin
            Clear;
            Exit;
          end;
        if stream.read(token_L, 4) <> 4 then
          begin
            Clear;
            Exit;
          end;
        if token_L > 0 then
          begin
            SetLength(token_B, token_L);
            if stream.read(token_B[0], token_L) <> token_L then
              begin
                Clear;
                Exit;
              end;
            KDStoreBuff[i].Token.Bytes := token_B;
            SetLength(token_B, 0);
          end
        else
            KDStoreBuff[i].Token := '';
        Inc(i);
      end;
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      Inc(i);
    end;

  if cnt > 0 then
      RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT21DC.SaveToFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(FileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT21DC.LoadFromFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT21DC.PrintNodeTree(const NodePtr: PKDT21DC_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT21DC_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.Vec^.Index, Vec(p^.Vec^.buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT21DC.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d - %d : %s ', [i, KDStoreBuff[i].Index, Vec(KDStoreBuff[i].buff)]);
end;

class function TKDT21DC.Vec(const s: SystemString): TKDT21DC_Vec;
var
  t: TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j: NativeInt;
begin
  for i := 0 to KDT21DC_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            Inc(j);
            if j >= KDT21DC_Axis then
                Break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT21DC.Vec(const v: TKDT21DC_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT21DC_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT21DC.Distance(const v1, v2: TKDT21DC_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT21DC_Axis - 1 do
      Result := Result + (v2[i] - v1[i]) * (v2[i] - v1[i]);
end;

procedure TKDT21DC.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT21DC_Source; const Data: Pointer);
begin
  Source.buff := TestBuff[IndexFor];
  Source.Token := umlIntToStr(IndexFor);
end;

class procedure TKDT21DC.Test;
var
  TKDT21DC_Test: TKDT21DC;
  t: TTimeTick;
  i, j: NativeInt;
  TestResultBuff: TKDT21DC_DynamicVecBuffer;
  TestResultIndex: TKMIntegerArray;
  KMeanOutIndex: TKMIntegerArray;
  errored: Boolean;
  m64: TMemoryStream64;
  p: PKDT21DC_Node;
  n: TPascalString;
begin
  errored := False;
  n := PFormat('test %s...', [ClassName]);
  t := GetTimeTick;

  n.Append('...build');
  TKDT21DC_Test := TKDT21DC.Create;

  n.Append('...');
  SetLength(TKDT21DC_Test.TestBuff, 1000);
  for i := 0 to length(TKDT21DC_Test.TestBuff) - 1 do
    for j := 0 to KDT21DC_Axis - 1 do
        TKDT21DC_Test.TestBuff[i][j] := i * KDT21DC_Axis + j;

{$IFDEF FPC}
  TKDT21DC_Test.BuildKDTreeM(length(TKDT21DC_Test.TestBuff), nil, @TKDT21DC_Test.Test_BuildM);
{$ELSE FPC}
  TKDT21DC_Test.BuildKDTreeM(length(TKDT21DC_Test.TestBuff), nil, TKDT21DC_Test.Test_BuildM);
{$ENDIF FPC}
  { save/load test }
  n.Append('...save/load');
  m64 := TMemoryStream64.CustomCreate(1024 * 1024);
  TKDT21DC_Test.SaveToStream(m64);
  m64.Position := 0;
  TKDT21DC_Test.LoadFromStream(m64);
  for i := 0 to length(TKDT21DC_Test.TestBuff) - 1 do
    begin
      p := TKDT21DC_Test.Search(TKDT21DC_Test.TestBuff[i]);
      if p^.Vec^.Index <> i then
          errored := True;
      if not p^.Vec^.Token.Same(umlIntToStr(i)) then
          errored := True;
      if errored then
          Break;
    end;
  DisposeObject(m64);

  if not errored then
    begin
      { parallel search test }
      n.Append('...parallel');
      SetLength(TestResultBuff, length(TKDT21DC_Test.TestBuff));
      SetLength(TestResultIndex, length(TKDT21DC_Test.TestBuff));
      TKDT21DC_Test.Search(TKDT21DC_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if Distance(TKDT21DC_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
            errored := True;
    end;

  if not errored then
    begin
      n.Append('...kMean');
      TKDT21DC_Test.Clear;
      { kMean test }
      TKDT21DC_Test.BuildKDTreeWithCluster(TKDT21DC_Test.TestBuff, 10, 1, KMeanOutIndex);
      { parallel search test }
      TKDT21DC_Test.Search(TKDT21DC_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if TestResultIndex[i] <> KMeanOutIndex[i] then
            errored := True;
    end;

  SetLength(TKDT21DC_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT21DC_Test.Clear;

  n.Append('...');
  if errored then
      n.Append('error!')
  else
      n.Append('passed ok %dms', [GetTimeTick - t]);
  DisposeObject(TKDT21DC_Test);
  DoStatus(n);
  n := '';
end;

function TKDT22DC.InternalBuildKdTree(const KDSourceBufferPtr: PKDT22DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT22DC_Node;
  function SortCompare(const p1, p2: PKDT22DC_Source; const axis: NativeInt): ShortInt;
  begin
    if p1^.buff[axis] = p2^.buff[axis] then
      begin
        if p1^.Index = p2^.Index then
            Result := 0
        else if p1^.Index < p2^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.buff[axis] < p2^.buff[axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT22DC_SourceBuffer; L, R: NativeInt; const axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT22DC_Source;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer^[(L + R) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, axis) < 0 do
            Inc(i);
        while SortCompare(SortBuffer^[j], p, axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, axis);
      L := i;
    until i >= R;
  end;

var
  M: NativeInt;
  axis: NativeInt;
  kdBuffPtr: PKDT22DC_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      new(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.Vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);
    end
  else
    begin
      axis := Depth mod KDT22DC_Axis;
      M := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr^[0], 0, PlanCount - 1, axis);

      new(Result);
      Result^.Parent := nil;
      Result^.Vec := kdBuffPtr^[M];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], M, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[M + 1], PlanCount - (M + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT22DC.GetData(const Index: NativeInt): PKDT22DC_Source;
begin
  Result := @KDStoreBuff[Index];
end;

constructor TKDT22DC.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT22DC.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT22DC.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT22DC_Node(KDNodes[i]));
      Inc(i);
    end;

  for i := 0 to length(KDStoreBuff) - 1 do
      KDStoreBuff[i].Token := '';

  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT22DC.StoreBuffPtr: PKDT22DC_DyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT22DC.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT22DC_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT22DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT22DC.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT22DC_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT22DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT22DC.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT22DC_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT22DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{ k-means++ clusterization }
procedure TKDT22DC.BuildKDTreeWithCluster(const inBuff: TKDT22DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  SetLength(Source, length(inBuff), KDT22DC_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT22DC_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT22DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT22DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT22DC.BuildKDTreeWithCluster(const inBuff: TKDT22DC_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TKMIntegerArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT22DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT22DC_BuildCall);
var
  TempStoreBuff: TKDT22DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT22DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT22DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT22DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT22DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT22DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT22DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT22DC_BuildMethod);
var
  TempStoreBuff: TKDT22DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT22DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT22DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT22DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT22DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT22DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT22DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT22DC_BuildProc);
var
  TempStoreBuff: TKDT22DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT22DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT22DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT22DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT22DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT22DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

function TKDT22DC.Search(const buff: TKDT22DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT22DC_Node;

var
  NearestNeighbour: PKDT22DC_Node;

  function FindParentNode(const buffPtr: PKDT22DC_Vec; NodePtr: PKDT22DC_Node): PKDT22DC_Node;
  var
    Next: PKDT22DC_Node;
    Depth, axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        axis := Depth mod KDT22DC_Axis;
        if buffPtr^[axis] > Next^.Vec^.buff[axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT22DC_Node; const buffPtr: PKDT22DC_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    Inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := Distance(buffPtr^, NodePtr^.Vec^.buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.Vec^.Index < NearestNeighbour^.Vec^.Index) then
        NearestNeighbour := NodePtr;

    axis := Depth mod KDT22DC_Axis;
    Dist := NodePtr^.Vec^.buff[axis] - buffPtr^[axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.Vec^.buff[axis] > buffPtr^[axis] then
            ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const buffPtr: PKDT22DC_Vec; const p1, p2: PKDT22DC_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := Distance(buffPtr^, p1^.Vec^.buff);
    d2 := Distance(buffPtr^, p2^.Vec^.buff);
    if d1 = d2 then
      begin
        if p1^.Vec^.Index = p2^.Vec^.Index then
            Result := 0
        else if p1^.Vec^.Index < p2^.Vec^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; L, R: NativeInt; const buffPtr: PKDT22DC_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT22DC_Node;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer[(L + R) shr 1];
      repeat
        while SortCompare(buffPtr, SortBuffer[i], p) < 0 do
            Inc(i);
        while SortCompare(buffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, buffPtr);
      L := i;
    until i >= R;
  end;

var
  Parent: PKDT22DC_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := Distance(buff, Parent^.Vec^.buff);

  ScanSubtree(RootNode, @buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT22DC_Node(NearestNodes[0]);
    end;
end;

function TKDT22DC.Search(const buff: TKDT22DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT22DC_Node;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT22DC.Search(const buff: TKDT22DC_Vec; var SearchedDistanceMin: Double): PKDT22DC_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT22DC.Search(const buff: TKDT22DC_Vec): PKDT22DC_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT22DC.SearchToken(const buff: TKDT22DC_Vec): TPascalString;
var
  p: PKDT22DC_Node;
begin
  p := Search(buff);
  if p <> nil then
      Result := p^.Vec^.Token
  else
      Result := '';
end;

procedure TKDT22DC.Search(const inBuff: TKDT22DC_DynamicVecBuffer; var OutBuff: TKDT22DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT22DC_DynamicVecBuffer;
  outBuffPtr: PKDT22DC_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT22DC_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outBuffPtr^[pass] := p^.Vec^.buff;
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT22DC_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outBuffPtr^[pass] := p^.Vec^.buff;
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT22DC_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.Vec^.buff;
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT22DC.Search(const inBuff: TKDT22DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT22DC_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT22DC_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT22DC_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT22DC_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT22DC.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  ID := KDT22DC_Axis;

  stream.write(st, 4);
  stream.write(ID, 4);

  stream.write(cnt, 8);

  i := 0;
  while i < cnt do
    begin
      stream.write(KDStoreBuff[i].buff[0], SizeOf(TKDT22DC_Vec));
      stream.write(KDStoreBuff[i].Index, 8);
      token_B := KDStoreBuff[i].Token.Bytes;
      token_L := length(token_B);
      stream.write(token_L, 4);
      if token_L > 0 then
        begin
          stream.write(token_B[0], token_L);
          SetLength(token_B, 0);
        end;
      Inc(i);
    end;
end;

procedure TKDT22DC.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  Clear;

  stream.read(st, 4);
  stream.read(ID, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if ID <> KDT22DC_Axis then
      RaiseInfo('kdtree axis error!');

  stream.read(cnt, 8);

  SetLength(KDStoreBuff, cnt);

  i := 0;
  try
    while i < cnt do
      begin
        if stream.read(KDStoreBuff[i].buff[0], SizeOf(TKDT22DC_Vec)) <> SizeOf(TKDT22DC_Vec) then
          begin
            Clear;
            Exit;
          end;
        if stream.read(KDStoreBuff[i].Index, 8) <> 8 then
          begin
            Clear;
            Exit;
          end;
        if stream.read(token_L, 4) <> 4 then
          begin
            Clear;
            Exit;
          end;
        if token_L > 0 then
          begin
            SetLength(token_B, token_L);
            if stream.read(token_B[0], token_L) <> token_L then
              begin
                Clear;
                Exit;
              end;
            KDStoreBuff[i].Token.Bytes := token_B;
            SetLength(token_B, 0);
          end
        else
            KDStoreBuff[i].Token := '';
        Inc(i);
      end;
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      Inc(i);
    end;

  if cnt > 0 then
      RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT22DC.SaveToFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(FileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT22DC.LoadFromFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT22DC.PrintNodeTree(const NodePtr: PKDT22DC_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT22DC_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.Vec^.Index, Vec(p^.Vec^.buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT22DC.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d - %d : %s ', [i, KDStoreBuff[i].Index, Vec(KDStoreBuff[i].buff)]);
end;

class function TKDT22DC.Vec(const s: SystemString): TKDT22DC_Vec;
var
  t: TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j: NativeInt;
begin
  for i := 0 to KDT22DC_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            Inc(j);
            if j >= KDT22DC_Axis then
                Break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT22DC.Vec(const v: TKDT22DC_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT22DC_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT22DC.Distance(const v1, v2: TKDT22DC_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT22DC_Axis - 1 do
      Result := Result + (v2[i] - v1[i]) * (v2[i] - v1[i]);
end;

procedure TKDT22DC.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT22DC_Source; const Data: Pointer);
begin
  Source.buff := TestBuff[IndexFor];
  Source.Token := umlIntToStr(IndexFor);
end;

class procedure TKDT22DC.Test;
var
  TKDT22DC_Test: TKDT22DC;
  t: TTimeTick;
  i, j: NativeInt;
  TestResultBuff: TKDT22DC_DynamicVecBuffer;
  TestResultIndex: TKMIntegerArray;
  KMeanOutIndex: TKMIntegerArray;
  errored: Boolean;
  m64: TMemoryStream64;
  p: PKDT22DC_Node;
  n: TPascalString;
begin
  errored := False;
  n := PFormat('test %s...', [ClassName]);
  t := GetTimeTick;

  n.Append('...build');
  TKDT22DC_Test := TKDT22DC.Create;

  n.Append('...');
  SetLength(TKDT22DC_Test.TestBuff, 1000);
  for i := 0 to length(TKDT22DC_Test.TestBuff) - 1 do
    for j := 0 to KDT22DC_Axis - 1 do
        TKDT22DC_Test.TestBuff[i][j] := i * KDT22DC_Axis + j;

{$IFDEF FPC}
  TKDT22DC_Test.BuildKDTreeM(length(TKDT22DC_Test.TestBuff), nil, @TKDT22DC_Test.Test_BuildM);
{$ELSE FPC}
  TKDT22DC_Test.BuildKDTreeM(length(TKDT22DC_Test.TestBuff), nil, TKDT22DC_Test.Test_BuildM);
{$ENDIF FPC}
  { save/load test }
  n.Append('...save/load');
  m64 := TMemoryStream64.CustomCreate(1024 * 1024);
  TKDT22DC_Test.SaveToStream(m64);
  m64.Position := 0;
  TKDT22DC_Test.LoadFromStream(m64);
  for i := 0 to length(TKDT22DC_Test.TestBuff) - 1 do
    begin
      p := TKDT22DC_Test.Search(TKDT22DC_Test.TestBuff[i]);
      if p^.Vec^.Index <> i then
          errored := True;
      if not p^.Vec^.Token.Same(umlIntToStr(i)) then
          errored := True;
      if errored then
          Break;
    end;
  DisposeObject(m64);

  if not errored then
    begin
      { parallel search test }
      n.Append('...parallel');
      SetLength(TestResultBuff, length(TKDT22DC_Test.TestBuff));
      SetLength(TestResultIndex, length(TKDT22DC_Test.TestBuff));
      TKDT22DC_Test.Search(TKDT22DC_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if Distance(TKDT22DC_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
            errored := True;
    end;

  if not errored then
    begin
      n.Append('...kMean');
      TKDT22DC_Test.Clear;
      { kMean test }
      TKDT22DC_Test.BuildKDTreeWithCluster(TKDT22DC_Test.TestBuff, 10, 1, KMeanOutIndex);
      { parallel search test }
      TKDT22DC_Test.Search(TKDT22DC_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if TestResultIndex[i] <> KMeanOutIndex[i] then
            errored := True;
    end;

  SetLength(TKDT22DC_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT22DC_Test.Clear;

  n.Append('...');
  if errored then
      n.Append('error!')
  else
      n.Append('passed ok %dms', [GetTimeTick - t]);
  DisposeObject(TKDT22DC_Test);
  DoStatus(n);
  n := '';
end;

function TKDT23DC.InternalBuildKdTree(const KDSourceBufferPtr: PKDT23DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT23DC_Node;
  function SortCompare(const p1, p2: PKDT23DC_Source; const axis: NativeInt): ShortInt;
  begin
    if p1^.buff[axis] = p2^.buff[axis] then
      begin
        if p1^.Index = p2^.Index then
            Result := 0
        else if p1^.Index < p2^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.buff[axis] < p2^.buff[axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT23DC_SourceBuffer; L, R: NativeInt; const axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT23DC_Source;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer^[(L + R) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, axis) < 0 do
            Inc(i);
        while SortCompare(SortBuffer^[j], p, axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, axis);
      L := i;
    until i >= R;
  end;

var
  M: NativeInt;
  axis: NativeInt;
  kdBuffPtr: PKDT23DC_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      new(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.Vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);
    end
  else
    begin
      axis := Depth mod KDT23DC_Axis;
      M := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr^[0], 0, PlanCount - 1, axis);

      new(Result);
      Result^.Parent := nil;
      Result^.Vec := kdBuffPtr^[M];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], M, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[M + 1], PlanCount - (M + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT23DC.GetData(const Index: NativeInt): PKDT23DC_Source;
begin
  Result := @KDStoreBuff[Index];
end;

constructor TKDT23DC.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT23DC.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT23DC.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT23DC_Node(KDNodes[i]));
      Inc(i);
    end;

  for i := 0 to length(KDStoreBuff) - 1 do
      KDStoreBuff[i].Token := '';

  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT23DC.StoreBuffPtr: PKDT23DC_DyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT23DC.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT23DC_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT23DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT23DC.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT23DC_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT23DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT23DC.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT23DC_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT23DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{ k-means++ clusterization }
procedure TKDT23DC.BuildKDTreeWithCluster(const inBuff: TKDT23DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  SetLength(Source, length(inBuff), KDT23DC_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT23DC_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT23DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT23DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT23DC.BuildKDTreeWithCluster(const inBuff: TKDT23DC_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TKMIntegerArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT23DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT23DC_BuildCall);
var
  TempStoreBuff: TKDT23DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT23DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT23DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT23DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT23DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT23DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT23DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT23DC_BuildMethod);
var
  TempStoreBuff: TKDT23DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT23DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT23DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT23DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT23DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT23DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT23DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT23DC_BuildProc);
var
  TempStoreBuff: TKDT23DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT23DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT23DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT23DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT23DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT23DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

function TKDT23DC.Search(const buff: TKDT23DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT23DC_Node;

var
  NearestNeighbour: PKDT23DC_Node;

  function FindParentNode(const buffPtr: PKDT23DC_Vec; NodePtr: PKDT23DC_Node): PKDT23DC_Node;
  var
    Next: PKDT23DC_Node;
    Depth, axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        axis := Depth mod KDT23DC_Axis;
        if buffPtr^[axis] > Next^.Vec^.buff[axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT23DC_Node; const buffPtr: PKDT23DC_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    Inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := Distance(buffPtr^, NodePtr^.Vec^.buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.Vec^.Index < NearestNeighbour^.Vec^.Index) then
        NearestNeighbour := NodePtr;

    axis := Depth mod KDT23DC_Axis;
    Dist := NodePtr^.Vec^.buff[axis] - buffPtr^[axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.Vec^.buff[axis] > buffPtr^[axis] then
            ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const buffPtr: PKDT23DC_Vec; const p1, p2: PKDT23DC_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := Distance(buffPtr^, p1^.Vec^.buff);
    d2 := Distance(buffPtr^, p2^.Vec^.buff);
    if d1 = d2 then
      begin
        if p1^.Vec^.Index = p2^.Vec^.Index then
            Result := 0
        else if p1^.Vec^.Index < p2^.Vec^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; L, R: NativeInt; const buffPtr: PKDT23DC_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT23DC_Node;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer[(L + R) shr 1];
      repeat
        while SortCompare(buffPtr, SortBuffer[i], p) < 0 do
            Inc(i);
        while SortCompare(buffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, buffPtr);
      L := i;
    until i >= R;
  end;

var
  Parent: PKDT23DC_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := Distance(buff, Parent^.Vec^.buff);

  ScanSubtree(RootNode, @buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT23DC_Node(NearestNodes[0]);
    end;
end;

function TKDT23DC.Search(const buff: TKDT23DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT23DC_Node;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT23DC.Search(const buff: TKDT23DC_Vec; var SearchedDistanceMin: Double): PKDT23DC_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT23DC.Search(const buff: TKDT23DC_Vec): PKDT23DC_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT23DC.SearchToken(const buff: TKDT23DC_Vec): TPascalString;
var
  p: PKDT23DC_Node;
begin
  p := Search(buff);
  if p <> nil then
      Result := p^.Vec^.Token
  else
      Result := '';
end;

procedure TKDT23DC.Search(const inBuff: TKDT23DC_DynamicVecBuffer; var OutBuff: TKDT23DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT23DC_DynamicVecBuffer;
  outBuffPtr: PKDT23DC_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT23DC_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outBuffPtr^[pass] := p^.Vec^.buff;
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT23DC_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outBuffPtr^[pass] := p^.Vec^.buff;
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT23DC_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.Vec^.buff;
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT23DC.Search(const inBuff: TKDT23DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT23DC_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT23DC_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT23DC_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT23DC_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT23DC.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  ID := KDT23DC_Axis;

  stream.write(st, 4);
  stream.write(ID, 4);

  stream.write(cnt, 8);

  i := 0;
  while i < cnt do
    begin
      stream.write(KDStoreBuff[i].buff[0], SizeOf(TKDT23DC_Vec));
      stream.write(KDStoreBuff[i].Index, 8);
      token_B := KDStoreBuff[i].Token.Bytes;
      token_L := length(token_B);
      stream.write(token_L, 4);
      if token_L > 0 then
        begin
          stream.write(token_B[0], token_L);
          SetLength(token_B, 0);
        end;
      Inc(i);
    end;
end;

procedure TKDT23DC.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  Clear;

  stream.read(st, 4);
  stream.read(ID, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if ID <> KDT23DC_Axis then
      RaiseInfo('kdtree axis error!');

  stream.read(cnt, 8);

  SetLength(KDStoreBuff, cnt);

  i := 0;
  try
    while i < cnt do
      begin
        if stream.read(KDStoreBuff[i].buff[0], SizeOf(TKDT23DC_Vec)) <> SizeOf(TKDT23DC_Vec) then
          begin
            Clear;
            Exit;
          end;
        if stream.read(KDStoreBuff[i].Index, 8) <> 8 then
          begin
            Clear;
            Exit;
          end;
        if stream.read(token_L, 4) <> 4 then
          begin
            Clear;
            Exit;
          end;
        if token_L > 0 then
          begin
            SetLength(token_B, token_L);
            if stream.read(token_B[0], token_L) <> token_L then
              begin
                Clear;
                Exit;
              end;
            KDStoreBuff[i].Token.Bytes := token_B;
            SetLength(token_B, 0);
          end
        else
            KDStoreBuff[i].Token := '';
        Inc(i);
      end;
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      Inc(i);
    end;

  if cnt > 0 then
      RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT23DC.SaveToFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(FileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT23DC.LoadFromFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT23DC.PrintNodeTree(const NodePtr: PKDT23DC_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT23DC_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.Vec^.Index, Vec(p^.Vec^.buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT23DC.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d - %d : %s ', [i, KDStoreBuff[i].Index, Vec(KDStoreBuff[i].buff)]);
end;

class function TKDT23DC.Vec(const s: SystemString): TKDT23DC_Vec;
var
  t: TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j: NativeInt;
begin
  for i := 0 to KDT23DC_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            Inc(j);
            if j >= KDT23DC_Axis then
                Break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT23DC.Vec(const v: TKDT23DC_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT23DC_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT23DC.Distance(const v1, v2: TKDT23DC_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT23DC_Axis - 1 do
      Result := Result + (v2[i] - v1[i]) * (v2[i] - v1[i]);
end;

procedure TKDT23DC.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT23DC_Source; const Data: Pointer);
begin
  Source.buff := TestBuff[IndexFor];
  Source.Token := umlIntToStr(IndexFor);
end;

class procedure TKDT23DC.Test;
var
  TKDT23DC_Test: TKDT23DC;
  t: TTimeTick;
  i, j: NativeInt;
  TestResultBuff: TKDT23DC_DynamicVecBuffer;
  TestResultIndex: TKMIntegerArray;
  KMeanOutIndex: TKMIntegerArray;
  errored: Boolean;
  m64: TMemoryStream64;
  p: PKDT23DC_Node;
  n: TPascalString;
begin
  errored := False;
  n := PFormat('test %s...', [ClassName]);
  t := GetTimeTick;

  n.Append('...build');
  TKDT23DC_Test := TKDT23DC.Create;

  n.Append('...');
  SetLength(TKDT23DC_Test.TestBuff, 1000);
  for i := 0 to length(TKDT23DC_Test.TestBuff) - 1 do
    for j := 0 to KDT23DC_Axis - 1 do
        TKDT23DC_Test.TestBuff[i][j] := i * KDT23DC_Axis + j;

{$IFDEF FPC}
  TKDT23DC_Test.BuildKDTreeM(length(TKDT23DC_Test.TestBuff), nil, @TKDT23DC_Test.Test_BuildM);
{$ELSE FPC}
  TKDT23DC_Test.BuildKDTreeM(length(TKDT23DC_Test.TestBuff), nil, TKDT23DC_Test.Test_BuildM);
{$ENDIF FPC}
  { save/load test }
  n.Append('...save/load');
  m64 := TMemoryStream64.CustomCreate(1024 * 1024);
  TKDT23DC_Test.SaveToStream(m64);
  m64.Position := 0;
  TKDT23DC_Test.LoadFromStream(m64);
  for i := 0 to length(TKDT23DC_Test.TestBuff) - 1 do
    begin
      p := TKDT23DC_Test.Search(TKDT23DC_Test.TestBuff[i]);
      if p^.Vec^.Index <> i then
          errored := True;
      if not p^.Vec^.Token.Same(umlIntToStr(i)) then
          errored := True;
      if errored then
          Break;
    end;
  DisposeObject(m64);

  if not errored then
    begin
      { parallel search test }
      n.Append('...parallel');
      SetLength(TestResultBuff, length(TKDT23DC_Test.TestBuff));
      SetLength(TestResultIndex, length(TKDT23DC_Test.TestBuff));
      TKDT23DC_Test.Search(TKDT23DC_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if Distance(TKDT23DC_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
            errored := True;
    end;

  if not errored then
    begin
      n.Append('...kMean');
      TKDT23DC_Test.Clear;
      { kMean test }
      TKDT23DC_Test.BuildKDTreeWithCluster(TKDT23DC_Test.TestBuff, 10, 1, KMeanOutIndex);
      { parallel search test }
      TKDT23DC_Test.Search(TKDT23DC_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if TestResultIndex[i] <> KMeanOutIndex[i] then
            errored := True;
    end;

  SetLength(TKDT23DC_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT23DC_Test.Clear;

  n.Append('...');
  if errored then
      n.Append('error!')
  else
      n.Append('passed ok %dms', [GetTimeTick - t]);
  DisposeObject(TKDT23DC_Test);
  DoStatus(n);
  n := '';
end;

function TKDT24DC.InternalBuildKdTree(const KDSourceBufferPtr: PKDT24DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT24DC_Node;
  function SortCompare(const p1, p2: PKDT24DC_Source; const axis: NativeInt): ShortInt;
  begin
    if p1^.buff[axis] = p2^.buff[axis] then
      begin
        if p1^.Index = p2^.Index then
            Result := 0
        else if p1^.Index < p2^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.buff[axis] < p2^.buff[axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT24DC_SourceBuffer; L, R: NativeInt; const axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT24DC_Source;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer^[(L + R) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, axis) < 0 do
            Inc(i);
        while SortCompare(SortBuffer^[j], p, axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, axis);
      L := i;
    until i >= R;
  end;

var
  M: NativeInt;
  axis: NativeInt;
  kdBuffPtr: PKDT24DC_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      new(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.Vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);
    end
  else
    begin
      axis := Depth mod KDT24DC_Axis;
      M := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr^[0], 0, PlanCount - 1, axis);

      new(Result);
      Result^.Parent := nil;
      Result^.Vec := kdBuffPtr^[M];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], M, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[M + 1], PlanCount - (M + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT24DC.GetData(const Index: NativeInt): PKDT24DC_Source;
begin
  Result := @KDStoreBuff[Index];
end;

constructor TKDT24DC.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT24DC.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT24DC.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT24DC_Node(KDNodes[i]));
      Inc(i);
    end;

  for i := 0 to length(KDStoreBuff) - 1 do
      KDStoreBuff[i].Token := '';

  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT24DC.StoreBuffPtr: PKDT24DC_DyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT24DC.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT24DC_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT24DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT24DC.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT24DC_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT24DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT24DC.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT24DC_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT24DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{ k-means++ clusterization }
procedure TKDT24DC.BuildKDTreeWithCluster(const inBuff: TKDT24DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  SetLength(Source, length(inBuff), KDT24DC_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT24DC_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT24DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT24DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT24DC.BuildKDTreeWithCluster(const inBuff: TKDT24DC_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TKMIntegerArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT24DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT24DC_BuildCall);
var
  TempStoreBuff: TKDT24DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT24DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT24DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT24DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT24DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT24DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT24DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT24DC_BuildMethod);
var
  TempStoreBuff: TKDT24DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT24DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT24DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT24DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT24DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT24DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT24DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT24DC_BuildProc);
var
  TempStoreBuff: TKDT24DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT24DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT24DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT24DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT24DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT24DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

function TKDT24DC.Search(const buff: TKDT24DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT24DC_Node;

var
  NearestNeighbour: PKDT24DC_Node;

  function FindParentNode(const buffPtr: PKDT24DC_Vec; NodePtr: PKDT24DC_Node): PKDT24DC_Node;
  var
    Next: PKDT24DC_Node;
    Depth, axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        axis := Depth mod KDT24DC_Axis;
        if buffPtr^[axis] > Next^.Vec^.buff[axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT24DC_Node; const buffPtr: PKDT24DC_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    Inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := Distance(buffPtr^, NodePtr^.Vec^.buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.Vec^.Index < NearestNeighbour^.Vec^.Index) then
        NearestNeighbour := NodePtr;

    axis := Depth mod KDT24DC_Axis;
    Dist := NodePtr^.Vec^.buff[axis] - buffPtr^[axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.Vec^.buff[axis] > buffPtr^[axis] then
            ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const buffPtr: PKDT24DC_Vec; const p1, p2: PKDT24DC_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := Distance(buffPtr^, p1^.Vec^.buff);
    d2 := Distance(buffPtr^, p2^.Vec^.buff);
    if d1 = d2 then
      begin
        if p1^.Vec^.Index = p2^.Vec^.Index then
            Result := 0
        else if p1^.Vec^.Index < p2^.Vec^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; L, R: NativeInt; const buffPtr: PKDT24DC_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT24DC_Node;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer[(L + R) shr 1];
      repeat
        while SortCompare(buffPtr, SortBuffer[i], p) < 0 do
            Inc(i);
        while SortCompare(buffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, buffPtr);
      L := i;
    until i >= R;
  end;

var
  Parent: PKDT24DC_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := Distance(buff, Parent^.Vec^.buff);

  ScanSubtree(RootNode, @buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT24DC_Node(NearestNodes[0]);
    end;
end;

function TKDT24DC.Search(const buff: TKDT24DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT24DC_Node;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT24DC.Search(const buff: TKDT24DC_Vec; var SearchedDistanceMin: Double): PKDT24DC_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT24DC.Search(const buff: TKDT24DC_Vec): PKDT24DC_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT24DC.SearchToken(const buff: TKDT24DC_Vec): TPascalString;
var
  p: PKDT24DC_Node;
begin
  p := Search(buff);
  if p <> nil then
      Result := p^.Vec^.Token
  else
      Result := '';
end;

procedure TKDT24DC.Search(const inBuff: TKDT24DC_DynamicVecBuffer; var OutBuff: TKDT24DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT24DC_DynamicVecBuffer;
  outBuffPtr: PKDT24DC_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT24DC_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outBuffPtr^[pass] := p^.Vec^.buff;
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT24DC_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outBuffPtr^[pass] := p^.Vec^.buff;
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT24DC_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.Vec^.buff;
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT24DC.Search(const inBuff: TKDT24DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT24DC_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT24DC_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT24DC_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT24DC_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT24DC.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  ID := KDT24DC_Axis;

  stream.write(st, 4);
  stream.write(ID, 4);

  stream.write(cnt, 8);

  i := 0;
  while i < cnt do
    begin
      stream.write(KDStoreBuff[i].buff[0], SizeOf(TKDT24DC_Vec));
      stream.write(KDStoreBuff[i].Index, 8);
      token_B := KDStoreBuff[i].Token.Bytes;
      token_L := length(token_B);
      stream.write(token_L, 4);
      if token_L > 0 then
        begin
          stream.write(token_B[0], token_L);
          SetLength(token_B, 0);
        end;
      Inc(i);
    end;
end;

procedure TKDT24DC.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  Clear;

  stream.read(st, 4);
  stream.read(ID, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if ID <> KDT24DC_Axis then
      RaiseInfo('kdtree axis error!');

  stream.read(cnt, 8);

  SetLength(KDStoreBuff, cnt);

  i := 0;
  try
    while i < cnt do
      begin
        if stream.read(KDStoreBuff[i].buff[0], SizeOf(TKDT24DC_Vec)) <> SizeOf(TKDT24DC_Vec) then
          begin
            Clear;
            Exit;
          end;
        if stream.read(KDStoreBuff[i].Index, 8) <> 8 then
          begin
            Clear;
            Exit;
          end;
        if stream.read(token_L, 4) <> 4 then
          begin
            Clear;
            Exit;
          end;
        if token_L > 0 then
          begin
            SetLength(token_B, token_L);
            if stream.read(token_B[0], token_L) <> token_L then
              begin
                Clear;
                Exit;
              end;
            KDStoreBuff[i].Token.Bytes := token_B;
            SetLength(token_B, 0);
          end
        else
            KDStoreBuff[i].Token := '';
        Inc(i);
      end;
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      Inc(i);
    end;

  if cnt > 0 then
      RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT24DC.SaveToFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(FileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT24DC.LoadFromFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT24DC.PrintNodeTree(const NodePtr: PKDT24DC_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT24DC_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.Vec^.Index, Vec(p^.Vec^.buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT24DC.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d - %d : %s ', [i, KDStoreBuff[i].Index, Vec(KDStoreBuff[i].buff)]);
end;

class function TKDT24DC.Vec(const s: SystemString): TKDT24DC_Vec;
var
  t: TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j: NativeInt;
begin
  for i := 0 to KDT24DC_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            Inc(j);
            if j >= KDT24DC_Axis then
                Break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT24DC.Vec(const v: TKDT24DC_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT24DC_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT24DC.Distance(const v1, v2: TKDT24DC_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT24DC_Axis - 1 do
      Result := Result + (v2[i] - v1[i]) * (v2[i] - v1[i]);
end;

procedure TKDT24DC.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT24DC_Source; const Data: Pointer);
begin
  Source.buff := TestBuff[IndexFor];
  Source.Token := umlIntToStr(IndexFor);
end;

class procedure TKDT24DC.Test;
var
  TKDT24DC_Test: TKDT24DC;
  t: TTimeTick;
  i, j: NativeInt;
  TestResultBuff: TKDT24DC_DynamicVecBuffer;
  TestResultIndex: TKMIntegerArray;
  KMeanOutIndex: TKMIntegerArray;
  errored: Boolean;
  m64: TMemoryStream64;
  p: PKDT24DC_Node;
  n: TPascalString;
begin
  errored := False;
  n := PFormat('test %s...', [ClassName]);
  t := GetTimeTick;

  n.Append('...build');
  TKDT24DC_Test := TKDT24DC.Create;

  n.Append('...');
  SetLength(TKDT24DC_Test.TestBuff, 1000);
  for i := 0 to length(TKDT24DC_Test.TestBuff) - 1 do
    for j := 0 to KDT24DC_Axis - 1 do
        TKDT24DC_Test.TestBuff[i][j] := i * KDT24DC_Axis + j;

{$IFDEF FPC}
  TKDT24DC_Test.BuildKDTreeM(length(TKDT24DC_Test.TestBuff), nil, @TKDT24DC_Test.Test_BuildM);
{$ELSE FPC}
  TKDT24DC_Test.BuildKDTreeM(length(TKDT24DC_Test.TestBuff), nil, TKDT24DC_Test.Test_BuildM);
{$ENDIF FPC}
  { save/load test }
  n.Append('...save/load');
  m64 := TMemoryStream64.CustomCreate(1024 * 1024);
  TKDT24DC_Test.SaveToStream(m64);
  m64.Position := 0;
  TKDT24DC_Test.LoadFromStream(m64);
  for i := 0 to length(TKDT24DC_Test.TestBuff) - 1 do
    begin
      p := TKDT24DC_Test.Search(TKDT24DC_Test.TestBuff[i]);
      if p^.Vec^.Index <> i then
          errored := True;
      if not p^.Vec^.Token.Same(umlIntToStr(i)) then
          errored := True;
      if errored then
          Break;
    end;
  DisposeObject(m64);

  if not errored then
    begin
      { parallel search test }
      n.Append('...parallel');
      SetLength(TestResultBuff, length(TKDT24DC_Test.TestBuff));
      SetLength(TestResultIndex, length(TKDT24DC_Test.TestBuff));
      TKDT24DC_Test.Search(TKDT24DC_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if Distance(TKDT24DC_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
            errored := True;
    end;

  if not errored then
    begin
      n.Append('...kMean');
      TKDT24DC_Test.Clear;
      { kMean test }
      TKDT24DC_Test.BuildKDTreeWithCluster(TKDT24DC_Test.TestBuff, 10, 1, KMeanOutIndex);
      { parallel search test }
      TKDT24DC_Test.Search(TKDT24DC_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if TestResultIndex[i] <> KMeanOutIndex[i] then
            errored := True;
    end;

  SetLength(TKDT24DC_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT24DC_Test.Clear;

  n.Append('...');
  if errored then
      n.Append('error!')
  else
      n.Append('passed ok %dms', [GetTimeTick - t]);
  DisposeObject(TKDT24DC_Test);
  DoStatus(n);
  n := '';
end;

function TKDT48DC.InternalBuildKdTree(const KDSourceBufferPtr: PKDT48DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT48DC_Node;
  function SortCompare(const p1, p2: PKDT48DC_Source; const axis: NativeInt): ShortInt;
  begin
    if p1^.buff[axis] = p2^.buff[axis] then
      begin
        if p1^.Index = p2^.Index then
            Result := 0
        else if p1^.Index < p2^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.buff[axis] < p2^.buff[axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT48DC_SourceBuffer; L, R: NativeInt; const axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT48DC_Source;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer^[(L + R) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, axis) < 0 do
            Inc(i);
        while SortCompare(SortBuffer^[j], p, axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, axis);
      L := i;
    until i >= R;
  end;

var
  M: NativeInt;
  axis: NativeInt;
  kdBuffPtr: PKDT48DC_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      new(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.Vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);
    end
  else
    begin
      axis := Depth mod KDT48DC_Axis;
      M := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr^[0], 0, PlanCount - 1, axis);

      new(Result);
      Result^.Parent := nil;
      Result^.Vec := kdBuffPtr^[M];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], M, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[M + 1], PlanCount - (M + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT48DC.GetData(const Index: NativeInt): PKDT48DC_Source;
begin
  Result := @KDStoreBuff[Index];
end;

constructor TKDT48DC.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT48DC.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT48DC.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT48DC_Node(KDNodes[i]));
      Inc(i);
    end;

  for i := 0 to length(KDStoreBuff) - 1 do
      KDStoreBuff[i].Token := '';

  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT48DC.StoreBuffPtr: PKDT48DC_DyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT48DC.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT48DC_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT48DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT48DC.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT48DC_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT48DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT48DC.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT48DC_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT48DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{ k-means++ clusterization }
procedure TKDT48DC.BuildKDTreeWithCluster(const inBuff: TKDT48DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  SetLength(Source, length(inBuff), KDT48DC_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT48DC_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT48DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT48DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT48DC.BuildKDTreeWithCluster(const inBuff: TKDT48DC_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TKMIntegerArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT48DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT48DC_BuildCall);
var
  TempStoreBuff: TKDT48DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT48DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT48DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT48DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT48DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT48DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT48DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT48DC_BuildMethod);
var
  TempStoreBuff: TKDT48DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT48DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT48DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT48DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT48DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT48DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT48DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT48DC_BuildProc);
var
  TempStoreBuff: TKDT48DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT48DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT48DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT48DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT48DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT48DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

function TKDT48DC.Search(const buff: TKDT48DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT48DC_Node;

var
  NearestNeighbour: PKDT48DC_Node;

  function FindParentNode(const buffPtr: PKDT48DC_Vec; NodePtr: PKDT48DC_Node): PKDT48DC_Node;
  var
    Next: PKDT48DC_Node;
    Depth, axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        axis := Depth mod KDT48DC_Axis;
        if buffPtr^[axis] > Next^.Vec^.buff[axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT48DC_Node; const buffPtr: PKDT48DC_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    Inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := Distance(buffPtr^, NodePtr^.Vec^.buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.Vec^.Index < NearestNeighbour^.Vec^.Index) then
        NearestNeighbour := NodePtr;

    axis := Depth mod KDT48DC_Axis;
    Dist := NodePtr^.Vec^.buff[axis] - buffPtr^[axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.Vec^.buff[axis] > buffPtr^[axis] then
            ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const buffPtr: PKDT48DC_Vec; const p1, p2: PKDT48DC_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := Distance(buffPtr^, p1^.Vec^.buff);
    d2 := Distance(buffPtr^, p2^.Vec^.buff);
    if d1 = d2 then
      begin
        if p1^.Vec^.Index = p2^.Vec^.Index then
            Result := 0
        else if p1^.Vec^.Index < p2^.Vec^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; L, R: NativeInt; const buffPtr: PKDT48DC_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT48DC_Node;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer[(L + R) shr 1];
      repeat
        while SortCompare(buffPtr, SortBuffer[i], p) < 0 do
            Inc(i);
        while SortCompare(buffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, buffPtr);
      L := i;
    until i >= R;
  end;

var
  Parent: PKDT48DC_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := Distance(buff, Parent^.Vec^.buff);

  ScanSubtree(RootNode, @buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT48DC_Node(NearestNodes[0]);
    end;
end;

function TKDT48DC.Search(const buff: TKDT48DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT48DC_Node;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT48DC.Search(const buff: TKDT48DC_Vec; var SearchedDistanceMin: Double): PKDT48DC_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT48DC.Search(const buff: TKDT48DC_Vec): PKDT48DC_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT48DC.SearchToken(const buff: TKDT48DC_Vec): TPascalString;
var
  p: PKDT48DC_Node;
begin
  p := Search(buff);
  if p <> nil then
      Result := p^.Vec^.Token
  else
      Result := '';
end;

procedure TKDT48DC.Search(const inBuff: TKDT48DC_DynamicVecBuffer; var OutBuff: TKDT48DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT48DC_DynamicVecBuffer;
  outBuffPtr: PKDT48DC_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT48DC_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outBuffPtr^[pass] := p^.Vec^.buff;
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT48DC_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outBuffPtr^[pass] := p^.Vec^.buff;
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT48DC_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.Vec^.buff;
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT48DC.Search(const inBuff: TKDT48DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT48DC_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT48DC_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT48DC_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT48DC_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT48DC.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  ID := KDT48DC_Axis;

  stream.write(st, 4);
  stream.write(ID, 4);

  stream.write(cnt, 8);

  i := 0;
  while i < cnt do
    begin
      stream.write(KDStoreBuff[i].buff[0], SizeOf(TKDT48DC_Vec));
      stream.write(KDStoreBuff[i].Index, 8);
      token_B := KDStoreBuff[i].Token.Bytes;
      token_L := length(token_B);
      stream.write(token_L, 4);
      if token_L > 0 then
        begin
          stream.write(token_B[0], token_L);
          SetLength(token_B, 0);
        end;
      Inc(i);
    end;
end;

procedure TKDT48DC.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  Clear;

  stream.read(st, 4);
  stream.read(ID, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if ID <> KDT48DC_Axis then
      RaiseInfo('kdtree axis error!');

  stream.read(cnt, 8);

  SetLength(KDStoreBuff, cnt);

  i := 0;
  try
    while i < cnt do
      begin
        if stream.read(KDStoreBuff[i].buff[0], SizeOf(TKDT48DC_Vec)) <> SizeOf(TKDT48DC_Vec) then
          begin
            Clear;
            Exit;
          end;
        if stream.read(KDStoreBuff[i].Index, 8) <> 8 then
          begin
            Clear;
            Exit;
          end;
        if stream.read(token_L, 4) <> 4 then
          begin
            Clear;
            Exit;
          end;
        if token_L > 0 then
          begin
            SetLength(token_B, token_L);
            if stream.read(token_B[0], token_L) <> token_L then
              begin
                Clear;
                Exit;
              end;
            KDStoreBuff[i].Token.Bytes := token_B;
            SetLength(token_B, 0);
          end
        else
            KDStoreBuff[i].Token := '';
        Inc(i);
      end;
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      Inc(i);
    end;

  if cnt > 0 then
      RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT48DC.SaveToFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(FileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT48DC.LoadFromFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT48DC.PrintNodeTree(const NodePtr: PKDT48DC_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT48DC_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.Vec^.Index, Vec(p^.Vec^.buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT48DC.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d - %d : %s ', [i, KDStoreBuff[i].Index, Vec(KDStoreBuff[i].buff)]);
end;

class function TKDT48DC.Vec(const s: SystemString): TKDT48DC_Vec;
var
  t: TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j: NativeInt;
begin
  for i := 0 to KDT48DC_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            Inc(j);
            if j >= KDT48DC_Axis then
                Break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT48DC.Vec(const v: TKDT48DC_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT48DC_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT48DC.Distance(const v1, v2: TKDT48DC_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT48DC_Axis - 1 do
      Result := Result + (v2[i] - v1[i]) * (v2[i] - v1[i]);
end;

procedure TKDT48DC.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT48DC_Source; const Data: Pointer);
begin
  Source.buff := TestBuff[IndexFor];
  Source.Token := umlIntToStr(IndexFor);
end;

class procedure TKDT48DC.Test;
var
  TKDT48DC_Test: TKDT48DC;
  t: TTimeTick;
  i, j: NativeInt;
  TestResultBuff: TKDT48DC_DynamicVecBuffer;
  TestResultIndex: TKMIntegerArray;
  KMeanOutIndex: TKMIntegerArray;
  errored: Boolean;
  m64: TMemoryStream64;
  p: PKDT48DC_Node;
  n: TPascalString;
begin
  errored := False;
  n := PFormat('test %s...', [ClassName]);
  t := GetTimeTick;

  n.Append('...build');
  TKDT48DC_Test := TKDT48DC.Create;

  n.Append('...');
  SetLength(TKDT48DC_Test.TestBuff, 1000);
  for i := 0 to length(TKDT48DC_Test.TestBuff) - 1 do
    for j := 0 to KDT48DC_Axis - 1 do
        TKDT48DC_Test.TestBuff[i][j] := i * KDT48DC_Axis + j;

{$IFDEF FPC}
  TKDT48DC_Test.BuildKDTreeM(length(TKDT48DC_Test.TestBuff), nil, @TKDT48DC_Test.Test_BuildM);
{$ELSE FPC}
  TKDT48DC_Test.BuildKDTreeM(length(TKDT48DC_Test.TestBuff), nil, TKDT48DC_Test.Test_BuildM);
{$ENDIF FPC}
  { save/load test }
  n.Append('...save/load');
  m64 := TMemoryStream64.CustomCreate(1024 * 1024);
  TKDT48DC_Test.SaveToStream(m64);
  m64.Position := 0;
  TKDT48DC_Test.LoadFromStream(m64);
  for i := 0 to length(TKDT48DC_Test.TestBuff) - 1 do
    begin
      p := TKDT48DC_Test.Search(TKDT48DC_Test.TestBuff[i]);
      if p^.Vec^.Index <> i then
          errored := True;
      if not p^.Vec^.Token.Same(umlIntToStr(i)) then
          errored := True;
      if errored then
          Break;
    end;
  DisposeObject(m64);

  if not errored then
    begin
      { parallel search test }
      n.Append('...parallel');
      SetLength(TestResultBuff, length(TKDT48DC_Test.TestBuff));
      SetLength(TestResultIndex, length(TKDT48DC_Test.TestBuff));
      TKDT48DC_Test.Search(TKDT48DC_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if Distance(TKDT48DC_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
            errored := True;
    end;

  if not errored then
    begin
      n.Append('...kMean');
      TKDT48DC_Test.Clear;
      { kMean test }
      TKDT48DC_Test.BuildKDTreeWithCluster(TKDT48DC_Test.TestBuff, 10, 1, KMeanOutIndex);
      { parallel search test }
      TKDT48DC_Test.Search(TKDT48DC_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if TestResultIndex[i] <> KMeanOutIndex[i] then
            errored := True;
    end;

  SetLength(TKDT48DC_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT48DC_Test.Clear;

  n.Append('...');
  if errored then
      n.Append('error!')
  else
      n.Append('passed ok %dms', [GetTimeTick - t]);
  DisposeObject(TKDT48DC_Test);
  DoStatus(n);
  n := '';
end;

function TKDT52DC.InternalBuildKdTree(const KDSourceBufferPtr: PKDT52DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT52DC_Node;
  function SortCompare(const p1, p2: PKDT52DC_Source; const axis: NativeInt): ShortInt;
  begin
    if p1^.buff[axis] = p2^.buff[axis] then
      begin
        if p1^.Index = p2^.Index then
            Result := 0
        else if p1^.Index < p2^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.buff[axis] < p2^.buff[axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT52DC_SourceBuffer; L, R: NativeInt; const axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT52DC_Source;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer^[(L + R) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, axis) < 0 do
            Inc(i);
        while SortCompare(SortBuffer^[j], p, axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, axis);
      L := i;
    until i >= R;
  end;

var
  M: NativeInt;
  axis: NativeInt;
  kdBuffPtr: PKDT52DC_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      new(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.Vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);
    end
  else
    begin
      axis := Depth mod KDT52DC_Axis;
      M := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr^[0], 0, PlanCount - 1, axis);

      new(Result);
      Result^.Parent := nil;
      Result^.Vec := kdBuffPtr^[M];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], M, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[M + 1], PlanCount - (M + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT52DC.GetData(const Index: NativeInt): PKDT52DC_Source;
begin
  Result := @KDStoreBuff[Index];
end;

constructor TKDT52DC.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT52DC.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT52DC.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT52DC_Node(KDNodes[i]));
      Inc(i);
    end;

  for i := 0 to length(KDStoreBuff) - 1 do
      KDStoreBuff[i].Token := '';

  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT52DC.StoreBuffPtr: PKDT52DC_DyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT52DC.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT52DC_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT52DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT52DC.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT52DC_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT52DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT52DC.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT52DC_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT52DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{ k-means++ clusterization }
procedure TKDT52DC.BuildKDTreeWithCluster(const inBuff: TKDT52DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  SetLength(Source, length(inBuff), KDT52DC_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT52DC_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT52DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT52DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT52DC.BuildKDTreeWithCluster(const inBuff: TKDT52DC_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TKMIntegerArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT52DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT52DC_BuildCall);
var
  TempStoreBuff: TKDT52DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT52DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT52DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT52DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT52DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT52DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT52DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT52DC_BuildMethod);
var
  TempStoreBuff: TKDT52DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT52DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT52DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT52DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT52DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT52DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT52DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT52DC_BuildProc);
var
  TempStoreBuff: TKDT52DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT52DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT52DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT52DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT52DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT52DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

function TKDT52DC.Search(const buff: TKDT52DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT52DC_Node;

var
  NearestNeighbour: PKDT52DC_Node;

  function FindParentNode(const buffPtr: PKDT52DC_Vec; NodePtr: PKDT52DC_Node): PKDT52DC_Node;
  var
    Next: PKDT52DC_Node;
    Depth, axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        axis := Depth mod KDT52DC_Axis;
        if buffPtr^[axis] > Next^.Vec^.buff[axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT52DC_Node; const buffPtr: PKDT52DC_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    Inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := Distance(buffPtr^, NodePtr^.Vec^.buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.Vec^.Index < NearestNeighbour^.Vec^.Index) then
        NearestNeighbour := NodePtr;

    axis := Depth mod KDT52DC_Axis;
    Dist := NodePtr^.Vec^.buff[axis] - buffPtr^[axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.Vec^.buff[axis] > buffPtr^[axis] then
            ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const buffPtr: PKDT52DC_Vec; const p1, p2: PKDT52DC_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := Distance(buffPtr^, p1^.Vec^.buff);
    d2 := Distance(buffPtr^, p2^.Vec^.buff);
    if d1 = d2 then
      begin
        if p1^.Vec^.Index = p2^.Vec^.Index then
            Result := 0
        else if p1^.Vec^.Index < p2^.Vec^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; L, R: NativeInt; const buffPtr: PKDT52DC_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT52DC_Node;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer[(L + R) shr 1];
      repeat
        while SortCompare(buffPtr, SortBuffer[i], p) < 0 do
            Inc(i);
        while SortCompare(buffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, buffPtr);
      L := i;
    until i >= R;
  end;

var
  Parent: PKDT52DC_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := Distance(buff, Parent^.Vec^.buff);

  ScanSubtree(RootNode, @buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT52DC_Node(NearestNodes[0]);
    end;
end;

function TKDT52DC.Search(const buff: TKDT52DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT52DC_Node;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT52DC.Search(const buff: TKDT52DC_Vec; var SearchedDistanceMin: Double): PKDT52DC_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT52DC.Search(const buff: TKDT52DC_Vec): PKDT52DC_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT52DC.SearchToken(const buff: TKDT52DC_Vec): TPascalString;
var
  p: PKDT52DC_Node;
begin
  p := Search(buff);
  if p <> nil then
      Result := p^.Vec^.Token
  else
      Result := '';
end;

procedure TKDT52DC.Search(const inBuff: TKDT52DC_DynamicVecBuffer; var OutBuff: TKDT52DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT52DC_DynamicVecBuffer;
  outBuffPtr: PKDT52DC_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT52DC_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outBuffPtr^[pass] := p^.Vec^.buff;
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT52DC_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outBuffPtr^[pass] := p^.Vec^.buff;
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT52DC_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.Vec^.buff;
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT52DC.Search(const inBuff: TKDT52DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT52DC_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT52DC_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT52DC_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT52DC_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT52DC.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  ID := KDT52DC_Axis;

  stream.write(st, 4);
  stream.write(ID, 4);

  stream.write(cnt, 8);

  i := 0;
  while i < cnt do
    begin
      stream.write(KDStoreBuff[i].buff[0], SizeOf(TKDT52DC_Vec));
      stream.write(KDStoreBuff[i].Index, 8);
      token_B := KDStoreBuff[i].Token.Bytes;
      token_L := length(token_B);
      stream.write(token_L, 4);
      if token_L > 0 then
        begin
          stream.write(token_B[0], token_L);
          SetLength(token_B, 0);
        end;
      Inc(i);
    end;
end;

procedure TKDT52DC.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  Clear;

  stream.read(st, 4);
  stream.read(ID, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if ID <> KDT52DC_Axis then
      RaiseInfo('kdtree axis error!');

  stream.read(cnt, 8);

  SetLength(KDStoreBuff, cnt);

  i := 0;
  try
    while i < cnt do
      begin
        if stream.read(KDStoreBuff[i].buff[0], SizeOf(TKDT52DC_Vec)) <> SizeOf(TKDT52DC_Vec) then
          begin
            Clear;
            Exit;
          end;
        if stream.read(KDStoreBuff[i].Index, 8) <> 8 then
          begin
            Clear;
            Exit;
          end;
        if stream.read(token_L, 4) <> 4 then
          begin
            Clear;
            Exit;
          end;
        if token_L > 0 then
          begin
            SetLength(token_B, token_L);
            if stream.read(token_B[0], token_L) <> token_L then
              begin
                Clear;
                Exit;
              end;
            KDStoreBuff[i].Token.Bytes := token_B;
            SetLength(token_B, 0);
          end
        else
            KDStoreBuff[i].Token := '';
        Inc(i);
      end;
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      Inc(i);
    end;

  if cnt > 0 then
      RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT52DC.SaveToFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(FileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT52DC.LoadFromFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT52DC.PrintNodeTree(const NodePtr: PKDT52DC_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT52DC_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.Vec^.Index, Vec(p^.Vec^.buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT52DC.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d - %d : %s ', [i, KDStoreBuff[i].Index, Vec(KDStoreBuff[i].buff)]);
end;

class function TKDT52DC.Vec(const s: SystemString): TKDT52DC_Vec;
var
  t: TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j: NativeInt;
begin
  for i := 0 to KDT52DC_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            Inc(j);
            if j >= KDT52DC_Axis then
                Break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT52DC.Vec(const v: TKDT52DC_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT52DC_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT52DC.Distance(const v1, v2: TKDT52DC_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT52DC_Axis - 1 do
      Result := Result + (v2[i] - v1[i]) * (v2[i] - v1[i]);
end;

procedure TKDT52DC.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT52DC_Source; const Data: Pointer);
begin
  Source.buff := TestBuff[IndexFor];
  Source.Token := umlIntToStr(IndexFor);
end;

class procedure TKDT52DC.Test;
var
  TKDT52DC_Test: TKDT52DC;
  t: TTimeTick;
  i, j: NativeInt;
  TestResultBuff: TKDT52DC_DynamicVecBuffer;
  TestResultIndex: TKMIntegerArray;
  KMeanOutIndex: TKMIntegerArray;
  errored: Boolean;
  m64: TMemoryStream64;
  p: PKDT52DC_Node;
  n: TPascalString;
begin
  errored := False;
  n := PFormat('test %s...', [ClassName]);
  t := GetTimeTick;

  n.Append('...build');
  TKDT52DC_Test := TKDT52DC.Create;

  n.Append('...');
  SetLength(TKDT52DC_Test.TestBuff, 1000);
  for i := 0 to length(TKDT52DC_Test.TestBuff) - 1 do
    for j := 0 to KDT52DC_Axis - 1 do
        TKDT52DC_Test.TestBuff[i][j] := i * KDT52DC_Axis + j;

{$IFDEF FPC}
  TKDT52DC_Test.BuildKDTreeM(length(TKDT52DC_Test.TestBuff), nil, @TKDT52DC_Test.Test_BuildM);
{$ELSE FPC}
  TKDT52DC_Test.BuildKDTreeM(length(TKDT52DC_Test.TestBuff), nil, TKDT52DC_Test.Test_BuildM);
{$ENDIF FPC}
  { save/load test }
  n.Append('...save/load');
  m64 := TMemoryStream64.CustomCreate(1024 * 1024);
  TKDT52DC_Test.SaveToStream(m64);
  m64.Position := 0;
  TKDT52DC_Test.LoadFromStream(m64);
  for i := 0 to length(TKDT52DC_Test.TestBuff) - 1 do
    begin
      p := TKDT52DC_Test.Search(TKDT52DC_Test.TestBuff[i]);
      if p^.Vec^.Index <> i then
          errored := True;
      if not p^.Vec^.Token.Same(umlIntToStr(i)) then
          errored := True;
      if errored then
          Break;
    end;
  DisposeObject(m64);

  if not errored then
    begin
      { parallel search test }
      n.Append('...parallel');
      SetLength(TestResultBuff, length(TKDT52DC_Test.TestBuff));
      SetLength(TestResultIndex, length(TKDT52DC_Test.TestBuff));
      TKDT52DC_Test.Search(TKDT52DC_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if Distance(TKDT52DC_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
            errored := True;
    end;

  if not errored then
    begin
      n.Append('...kMean');
      TKDT52DC_Test.Clear;
      { kMean test }
      TKDT52DC_Test.BuildKDTreeWithCluster(TKDT52DC_Test.TestBuff, 10, 1, KMeanOutIndex);
      { parallel search test }
      TKDT52DC_Test.Search(TKDT52DC_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if TestResultIndex[i] <> KMeanOutIndex[i] then
            errored := True;
    end;

  SetLength(TKDT52DC_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT52DC_Test.Clear;

  n.Append('...');
  if errored then
      n.Append('error!')
  else
      n.Append('passed ok %dms', [GetTimeTick - t]);
  DisposeObject(TKDT52DC_Test);
  DoStatus(n);
  n := '';
end;

function TKDT64DC.InternalBuildKdTree(const KDSourceBufferPtr: PKDT64DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT64DC_Node;
  function SortCompare(const p1, p2: PKDT64DC_Source; const axis: NativeInt): ShortInt;
  begin
    if p1^.buff[axis] = p2^.buff[axis] then
      begin
        if p1^.Index = p2^.Index then
            Result := 0
        else if p1^.Index < p2^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.buff[axis] < p2^.buff[axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT64DC_SourceBuffer; L, R: NativeInt; const axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT64DC_Source;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer^[(L + R) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, axis) < 0 do
            Inc(i);
        while SortCompare(SortBuffer^[j], p, axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, axis);
      L := i;
    until i >= R;
  end;

var
  M: NativeInt;
  axis: NativeInt;
  kdBuffPtr: PKDT64DC_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      new(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.Vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);
    end
  else
    begin
      axis := Depth mod KDT64DC_Axis;
      M := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr^[0], 0, PlanCount - 1, axis);

      new(Result);
      Result^.Parent := nil;
      Result^.Vec := kdBuffPtr^[M];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], M, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[M + 1], PlanCount - (M + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT64DC.GetData(const Index: NativeInt): PKDT64DC_Source;
begin
  Result := @KDStoreBuff[Index];
end;

constructor TKDT64DC.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT64DC.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT64DC.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT64DC_Node(KDNodes[i]));
      Inc(i);
    end;

  for i := 0 to length(KDStoreBuff) - 1 do
      KDStoreBuff[i].Token := '';

  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT64DC.StoreBuffPtr: PKDT64DC_DyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT64DC.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT64DC_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT64DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT64DC.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT64DC_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT64DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT64DC.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT64DC_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT64DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{ k-means++ clusterization }
procedure TKDT64DC.BuildKDTreeWithCluster(const inBuff: TKDT64DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  SetLength(Source, length(inBuff), KDT64DC_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT64DC_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT64DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT64DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT64DC.BuildKDTreeWithCluster(const inBuff: TKDT64DC_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TKMIntegerArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT64DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT64DC_BuildCall);
var
  TempStoreBuff: TKDT64DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT64DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT64DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT64DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT64DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT64DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT64DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT64DC_BuildMethod);
var
  TempStoreBuff: TKDT64DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT64DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT64DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT64DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT64DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT64DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT64DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT64DC_BuildProc);
var
  TempStoreBuff: TKDT64DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT64DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT64DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT64DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT64DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT64DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

function TKDT64DC.Search(const buff: TKDT64DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT64DC_Node;

var
  NearestNeighbour: PKDT64DC_Node;

  function FindParentNode(const buffPtr: PKDT64DC_Vec; NodePtr: PKDT64DC_Node): PKDT64DC_Node;
  var
    Next: PKDT64DC_Node;
    Depth, axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        axis := Depth mod KDT64DC_Axis;
        if buffPtr^[axis] > Next^.Vec^.buff[axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT64DC_Node; const buffPtr: PKDT64DC_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    Inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := Distance(buffPtr^, NodePtr^.Vec^.buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.Vec^.Index < NearestNeighbour^.Vec^.Index) then
        NearestNeighbour := NodePtr;

    axis := Depth mod KDT64DC_Axis;
    Dist := NodePtr^.Vec^.buff[axis] - buffPtr^[axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.Vec^.buff[axis] > buffPtr^[axis] then
            ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const buffPtr: PKDT64DC_Vec; const p1, p2: PKDT64DC_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := Distance(buffPtr^, p1^.Vec^.buff);
    d2 := Distance(buffPtr^, p2^.Vec^.buff);
    if d1 = d2 then
      begin
        if p1^.Vec^.Index = p2^.Vec^.Index then
            Result := 0
        else if p1^.Vec^.Index < p2^.Vec^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; L, R: NativeInt; const buffPtr: PKDT64DC_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT64DC_Node;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer[(L + R) shr 1];
      repeat
        while SortCompare(buffPtr, SortBuffer[i], p) < 0 do
            Inc(i);
        while SortCompare(buffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, buffPtr);
      L := i;
    until i >= R;
  end;

var
  Parent: PKDT64DC_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := Distance(buff, Parent^.Vec^.buff);

  ScanSubtree(RootNode, @buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT64DC_Node(NearestNodes[0]);
    end;
end;

function TKDT64DC.Search(const buff: TKDT64DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT64DC_Node;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT64DC.Search(const buff: TKDT64DC_Vec; var SearchedDistanceMin: Double): PKDT64DC_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT64DC.Search(const buff: TKDT64DC_Vec): PKDT64DC_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT64DC.SearchToken(const buff: TKDT64DC_Vec): TPascalString;
var
  p: PKDT64DC_Node;
begin
  p := Search(buff);
  if p <> nil then
      Result := p^.Vec^.Token
  else
      Result := '';
end;

procedure TKDT64DC.Search(const inBuff: TKDT64DC_DynamicVecBuffer; var OutBuff: TKDT64DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT64DC_DynamicVecBuffer;
  outBuffPtr: PKDT64DC_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT64DC_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outBuffPtr^[pass] := p^.Vec^.buff;
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT64DC_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outBuffPtr^[pass] := p^.Vec^.buff;
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT64DC_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.Vec^.buff;
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT64DC.Search(const inBuff: TKDT64DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT64DC_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT64DC_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT64DC_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT64DC_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT64DC.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  ID := KDT64DC_Axis;

  stream.write(st, 4);
  stream.write(ID, 4);

  stream.write(cnt, 8);

  i := 0;
  while i < cnt do
    begin
      stream.write(KDStoreBuff[i].buff[0], SizeOf(TKDT64DC_Vec));
      stream.write(KDStoreBuff[i].Index, 8);
      token_B := KDStoreBuff[i].Token.Bytes;
      token_L := length(token_B);
      stream.write(token_L, 4);
      if token_L > 0 then
        begin
          stream.write(token_B[0], token_L);
          SetLength(token_B, 0);
        end;
      Inc(i);
    end;
end;

procedure TKDT64DC.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  Clear;

  stream.read(st, 4);
  stream.read(ID, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if ID <> KDT64DC_Axis then
      RaiseInfo('kdtree axis error!');

  stream.read(cnt, 8);

  SetLength(KDStoreBuff, cnt);

  i := 0;
  try
    while i < cnt do
      begin
        if stream.read(KDStoreBuff[i].buff[0], SizeOf(TKDT64DC_Vec)) <> SizeOf(TKDT64DC_Vec) then
          begin
            Clear;
            Exit;
          end;
        if stream.read(KDStoreBuff[i].Index, 8) <> 8 then
          begin
            Clear;
            Exit;
          end;
        if stream.read(token_L, 4) <> 4 then
          begin
            Clear;
            Exit;
          end;
        if token_L > 0 then
          begin
            SetLength(token_B, token_L);
            if stream.read(token_B[0], token_L) <> token_L then
              begin
                Clear;
                Exit;
              end;
            KDStoreBuff[i].Token.Bytes := token_B;
            SetLength(token_B, 0);
          end
        else
            KDStoreBuff[i].Token := '';
        Inc(i);
      end;
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      Inc(i);
    end;

  if cnt > 0 then
      RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT64DC.SaveToFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(FileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT64DC.LoadFromFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT64DC.PrintNodeTree(const NodePtr: PKDT64DC_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT64DC_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.Vec^.Index, Vec(p^.Vec^.buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT64DC.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d - %d : %s ', [i, KDStoreBuff[i].Index, Vec(KDStoreBuff[i].buff)]);
end;

class function TKDT64DC.Vec(const s: SystemString): TKDT64DC_Vec;
var
  t: TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j: NativeInt;
begin
  for i := 0 to KDT64DC_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            Inc(j);
            if j >= KDT64DC_Axis then
                Break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT64DC.Vec(const v: TKDT64DC_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT64DC_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT64DC.Distance(const v1, v2: TKDT64DC_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT64DC_Axis - 1 do
      Result := Result + (v2[i] - v1[i]) * (v2[i] - v1[i]);
end;

procedure TKDT64DC.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT64DC_Source; const Data: Pointer);
begin
  Source.buff := TestBuff[IndexFor];
  Source.Token := umlIntToStr(IndexFor);
end;

class procedure TKDT64DC.Test;
var
  TKDT64DC_Test: TKDT64DC;
  t: TTimeTick;
  i, j: NativeInt;
  TestResultBuff: TKDT64DC_DynamicVecBuffer;
  TestResultIndex: TKMIntegerArray;
  KMeanOutIndex: TKMIntegerArray;
  errored: Boolean;
  m64: TMemoryStream64;
  p: PKDT64DC_Node;
  n: TPascalString;
begin
  errored := False;
  n := PFormat('test %s...', [ClassName]);
  t := GetTimeTick;

  n.Append('...build');
  TKDT64DC_Test := TKDT64DC.Create;

  n.Append('...');
  SetLength(TKDT64DC_Test.TestBuff, 1000);
  for i := 0 to length(TKDT64DC_Test.TestBuff) - 1 do
    for j := 0 to KDT64DC_Axis - 1 do
        TKDT64DC_Test.TestBuff[i][j] := i * KDT64DC_Axis + j;

{$IFDEF FPC}
  TKDT64DC_Test.BuildKDTreeM(length(TKDT64DC_Test.TestBuff), nil, @TKDT64DC_Test.Test_BuildM);
{$ELSE FPC}
  TKDT64DC_Test.BuildKDTreeM(length(TKDT64DC_Test.TestBuff), nil, TKDT64DC_Test.Test_BuildM);
{$ENDIF FPC}
  { save/load test }
  n.Append('...save/load');
  m64 := TMemoryStream64.CustomCreate(1024 * 1024);
  TKDT64DC_Test.SaveToStream(m64);
  m64.Position := 0;
  TKDT64DC_Test.LoadFromStream(m64);
  for i := 0 to length(TKDT64DC_Test.TestBuff) - 1 do
    begin
      p := TKDT64DC_Test.Search(TKDT64DC_Test.TestBuff[i]);
      if p^.Vec^.Index <> i then
          errored := True;
      if not p^.Vec^.Token.Same(umlIntToStr(i)) then
          errored := True;
      if errored then
          Break;
    end;
  DisposeObject(m64);

  if not errored then
    begin
      { parallel search test }
      n.Append('...parallel');
      SetLength(TestResultBuff, length(TKDT64DC_Test.TestBuff));
      SetLength(TestResultIndex, length(TKDT64DC_Test.TestBuff));
      TKDT64DC_Test.Search(TKDT64DC_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if Distance(TKDT64DC_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
            errored := True;
    end;

  if not errored then
    begin
      n.Append('...kMean');
      TKDT64DC_Test.Clear;
      { kMean test }
      TKDT64DC_Test.BuildKDTreeWithCluster(TKDT64DC_Test.TestBuff, 10, 1, KMeanOutIndex);
      { parallel search test }
      TKDT64DC_Test.Search(TKDT64DC_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if TestResultIndex[i] <> KMeanOutIndex[i] then
            errored := True;
    end;

  SetLength(TKDT64DC_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT64DC_Test.Clear;

  n.Append('...');
  if errored then
      n.Append('error!')
  else
      n.Append('passed ok %dms', [GetTimeTick - t]);
  DisposeObject(TKDT64DC_Test);
  DoStatus(n);
  n := '';
end;

function TKDT96DC.InternalBuildKdTree(const KDSourceBufferPtr: PKDT96DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT96DC_Node;
  function SortCompare(const p1, p2: PKDT96DC_Source; const axis: NativeInt): ShortInt;
  begin
    if p1^.buff[axis] = p2^.buff[axis] then
      begin
        if p1^.Index = p2^.Index then
            Result := 0
        else if p1^.Index < p2^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.buff[axis] < p2^.buff[axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT96DC_SourceBuffer; L, R: NativeInt; const axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT96DC_Source;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer^[(L + R) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, axis) < 0 do
            Inc(i);
        while SortCompare(SortBuffer^[j], p, axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, axis);
      L := i;
    until i >= R;
  end;

var
  M: NativeInt;
  axis: NativeInt;
  kdBuffPtr: PKDT96DC_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      new(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.Vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);
    end
  else
    begin
      axis := Depth mod KDT96DC_Axis;
      M := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr^[0], 0, PlanCount - 1, axis);

      new(Result);
      Result^.Parent := nil;
      Result^.Vec := kdBuffPtr^[M];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], M, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[M + 1], PlanCount - (M + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT96DC.GetData(const Index: NativeInt): PKDT96DC_Source;
begin
  Result := @KDStoreBuff[Index];
end;

constructor TKDT96DC.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT96DC.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT96DC.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT96DC_Node(KDNodes[i]));
      Inc(i);
    end;

  for i := 0 to length(KDStoreBuff) - 1 do
      KDStoreBuff[i].Token := '';

  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT96DC.StoreBuffPtr: PKDT96DC_DyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT96DC.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT96DC_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT96DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT96DC.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT96DC_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT96DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT96DC.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT96DC_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT96DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{ k-means++ clusterization }
procedure TKDT96DC.BuildKDTreeWithCluster(const inBuff: TKDT96DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  SetLength(Source, length(inBuff), KDT96DC_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT96DC_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT96DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT96DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT96DC.BuildKDTreeWithCluster(const inBuff: TKDT96DC_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TKMIntegerArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT96DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT96DC_BuildCall);
var
  TempStoreBuff: TKDT96DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT96DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT96DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT96DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT96DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT96DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT96DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT96DC_BuildMethod);
var
  TempStoreBuff: TKDT96DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT96DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT96DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT96DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT96DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT96DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT96DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT96DC_BuildProc);
var
  TempStoreBuff: TKDT96DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT96DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT96DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT96DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT96DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT96DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

function TKDT96DC.Search(const buff: TKDT96DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT96DC_Node;

var
  NearestNeighbour: PKDT96DC_Node;

  function FindParentNode(const buffPtr: PKDT96DC_Vec; NodePtr: PKDT96DC_Node): PKDT96DC_Node;
  var
    Next: PKDT96DC_Node;
    Depth, axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        axis := Depth mod KDT96DC_Axis;
        if buffPtr^[axis] > Next^.Vec^.buff[axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT96DC_Node; const buffPtr: PKDT96DC_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    Inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := Distance(buffPtr^, NodePtr^.Vec^.buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.Vec^.Index < NearestNeighbour^.Vec^.Index) then
        NearestNeighbour := NodePtr;

    axis := Depth mod KDT96DC_Axis;
    Dist := NodePtr^.Vec^.buff[axis] - buffPtr^[axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.Vec^.buff[axis] > buffPtr^[axis] then
            ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const buffPtr: PKDT96DC_Vec; const p1, p2: PKDT96DC_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := Distance(buffPtr^, p1^.Vec^.buff);
    d2 := Distance(buffPtr^, p2^.Vec^.buff);
    if d1 = d2 then
      begin
        if p1^.Vec^.Index = p2^.Vec^.Index then
            Result := 0
        else if p1^.Vec^.Index < p2^.Vec^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; L, R: NativeInt; const buffPtr: PKDT96DC_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT96DC_Node;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer[(L + R) shr 1];
      repeat
        while SortCompare(buffPtr, SortBuffer[i], p) < 0 do
            Inc(i);
        while SortCompare(buffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, buffPtr);
      L := i;
    until i >= R;
  end;

var
  Parent: PKDT96DC_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := Distance(buff, Parent^.Vec^.buff);

  ScanSubtree(RootNode, @buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT96DC_Node(NearestNodes[0]);
    end;
end;

function TKDT96DC.Search(const buff: TKDT96DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT96DC_Node;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT96DC.Search(const buff: TKDT96DC_Vec; var SearchedDistanceMin: Double): PKDT96DC_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT96DC.Search(const buff: TKDT96DC_Vec): PKDT96DC_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT96DC.SearchToken(const buff: TKDT96DC_Vec): TPascalString;
var
  p: PKDT96DC_Node;
begin
  p := Search(buff);
  if p <> nil then
      Result := p^.Vec^.Token
  else
      Result := '';
end;

procedure TKDT96DC.Search(const inBuff: TKDT96DC_DynamicVecBuffer; var OutBuff: TKDT96DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT96DC_DynamicVecBuffer;
  outBuffPtr: PKDT96DC_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT96DC_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outBuffPtr^[pass] := p^.Vec^.buff;
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT96DC_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outBuffPtr^[pass] := p^.Vec^.buff;
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT96DC_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.Vec^.buff;
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT96DC.Search(const inBuff: TKDT96DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT96DC_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT96DC_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT96DC_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT96DC_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT96DC.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  ID := KDT96DC_Axis;

  stream.write(st, 4);
  stream.write(ID, 4);

  stream.write(cnt, 8);

  i := 0;
  while i < cnt do
    begin
      stream.write(KDStoreBuff[i].buff[0], SizeOf(TKDT96DC_Vec));
      stream.write(KDStoreBuff[i].Index, 8);
      token_B := KDStoreBuff[i].Token.Bytes;
      token_L := length(token_B);
      stream.write(token_L, 4);
      if token_L > 0 then
        begin
          stream.write(token_B[0], token_L);
          SetLength(token_B, 0);
        end;
      Inc(i);
    end;
end;

procedure TKDT96DC.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  Clear;

  stream.read(st, 4);
  stream.read(ID, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if ID <> KDT96DC_Axis then
      RaiseInfo('kdtree axis error!');

  stream.read(cnt, 8);

  SetLength(KDStoreBuff, cnt);

  i := 0;
  try
    while i < cnt do
      begin
        if stream.read(KDStoreBuff[i].buff[0], SizeOf(TKDT96DC_Vec)) <> SizeOf(TKDT96DC_Vec) then
          begin
            Clear;
            Exit;
          end;
        if stream.read(KDStoreBuff[i].Index, 8) <> 8 then
          begin
            Clear;
            Exit;
          end;
        if stream.read(token_L, 4) <> 4 then
          begin
            Clear;
            Exit;
          end;
        if token_L > 0 then
          begin
            SetLength(token_B, token_L);
            if stream.read(token_B[0], token_L) <> token_L then
              begin
                Clear;
                Exit;
              end;
            KDStoreBuff[i].Token.Bytes := token_B;
            SetLength(token_B, 0);
          end
        else
            KDStoreBuff[i].Token := '';
        Inc(i);
      end;
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      Inc(i);
    end;

  if cnt > 0 then
      RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT96DC.SaveToFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(FileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT96DC.LoadFromFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT96DC.PrintNodeTree(const NodePtr: PKDT96DC_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT96DC_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.Vec^.Index, Vec(p^.Vec^.buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT96DC.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d - %d : %s ', [i, KDStoreBuff[i].Index, Vec(KDStoreBuff[i].buff)]);
end;

class function TKDT96DC.Vec(const s: SystemString): TKDT96DC_Vec;
var
  t: TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j: NativeInt;
begin
  for i := 0 to KDT96DC_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            Inc(j);
            if j >= KDT96DC_Axis then
                Break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT96DC.Vec(const v: TKDT96DC_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT96DC_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT96DC.Distance(const v1, v2: TKDT96DC_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT96DC_Axis - 1 do
      Result := Result + (v2[i] - v1[i]) * (v2[i] - v1[i]);
end;

procedure TKDT96DC.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT96DC_Source; const Data: Pointer);
begin
  Source.buff := TestBuff[IndexFor];
  Source.Token := umlIntToStr(IndexFor);
end;

class procedure TKDT96DC.Test;
var
  TKDT96DC_Test: TKDT96DC;
  t: TTimeTick;
  i, j: NativeInt;
  TestResultBuff: TKDT96DC_DynamicVecBuffer;
  TestResultIndex: TKMIntegerArray;
  KMeanOutIndex: TKMIntegerArray;
  errored: Boolean;
  m64: TMemoryStream64;
  p: PKDT96DC_Node;
  n: TPascalString;
begin
  errored := False;
  n := PFormat('test %s...', [ClassName]);
  t := GetTimeTick;

  n.Append('...build');
  TKDT96DC_Test := TKDT96DC.Create;

  n.Append('...');
  SetLength(TKDT96DC_Test.TestBuff, 1000);
  for i := 0 to length(TKDT96DC_Test.TestBuff) - 1 do
    for j := 0 to KDT96DC_Axis - 1 do
        TKDT96DC_Test.TestBuff[i][j] := i * KDT96DC_Axis + j;

{$IFDEF FPC}
  TKDT96DC_Test.BuildKDTreeM(length(TKDT96DC_Test.TestBuff), nil, @TKDT96DC_Test.Test_BuildM);
{$ELSE FPC}
  TKDT96DC_Test.BuildKDTreeM(length(TKDT96DC_Test.TestBuff), nil, TKDT96DC_Test.Test_BuildM);
{$ENDIF FPC}
  { save/load test }
  n.Append('...save/load');
  m64 := TMemoryStream64.CustomCreate(1024 * 1024);
  TKDT96DC_Test.SaveToStream(m64);
  m64.Position := 0;
  TKDT96DC_Test.LoadFromStream(m64);
  for i := 0 to length(TKDT96DC_Test.TestBuff) - 1 do
    begin
      p := TKDT96DC_Test.Search(TKDT96DC_Test.TestBuff[i]);
      if p^.Vec^.Index <> i then
          errored := True;
      if not p^.Vec^.Token.Same(umlIntToStr(i)) then
          errored := True;
      if errored then
          Break;
    end;
  DisposeObject(m64);

  if not errored then
    begin
      { parallel search test }
      n.Append('...parallel');
      SetLength(TestResultBuff, length(TKDT96DC_Test.TestBuff));
      SetLength(TestResultIndex, length(TKDT96DC_Test.TestBuff));
      TKDT96DC_Test.Search(TKDT96DC_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if Distance(TKDT96DC_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
            errored := True;
    end;

  if not errored then
    begin
      n.Append('...kMean');
      TKDT96DC_Test.Clear;
      { kMean test }
      TKDT96DC_Test.BuildKDTreeWithCluster(TKDT96DC_Test.TestBuff, 10, 1, KMeanOutIndex);
      { parallel search test }
      TKDT96DC_Test.Search(TKDT96DC_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if TestResultIndex[i] <> KMeanOutIndex[i] then
            errored := True;
    end;

  SetLength(TKDT96DC_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT96DC_Test.Clear;

  n.Append('...');
  if errored then
      n.Append('error!')
  else
      n.Append('passed ok %dms', [GetTimeTick - t]);
  DisposeObject(TKDT96DC_Test);
  DoStatus(n);
  n := '';
end;

function TKDT128DC.InternalBuildKdTree(const KDSourceBufferPtr: PKDT128DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT128DC_Node;
  function SortCompare(const p1, p2: PKDT128DC_Source; const axis: NativeInt): ShortInt;
  begin
    if p1^.buff[axis] = p2^.buff[axis] then
      begin
        if p1^.Index = p2^.Index then
            Result := 0
        else if p1^.Index < p2^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.buff[axis] < p2^.buff[axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT128DC_SourceBuffer; L, R: NativeInt; const axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT128DC_Source;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer^[(L + R) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, axis) < 0 do
            Inc(i);
        while SortCompare(SortBuffer^[j], p, axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, axis);
      L := i;
    until i >= R;
  end;

var
  M: NativeInt;
  axis: NativeInt;
  kdBuffPtr: PKDT128DC_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      new(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.Vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);
    end
  else
    begin
      axis := Depth mod KDT128DC_Axis;
      M := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr^[0], 0, PlanCount - 1, axis);

      new(Result);
      Result^.Parent := nil;
      Result^.Vec := kdBuffPtr^[M];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], M, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[M + 1], PlanCount - (M + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT128DC.GetData(const Index: NativeInt): PKDT128DC_Source;
begin
  Result := @KDStoreBuff[Index];
end;

constructor TKDT128DC.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT128DC.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT128DC.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT128DC_Node(KDNodes[i]));
      Inc(i);
    end;

  for i := 0 to length(KDStoreBuff) - 1 do
      KDStoreBuff[i].Token := '';

  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT128DC.StoreBuffPtr: PKDT128DC_DyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT128DC.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT128DC_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT128DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT128DC.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT128DC_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT128DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT128DC.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT128DC_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT128DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{ k-means++ clusterization }
procedure TKDT128DC.BuildKDTreeWithCluster(const inBuff: TKDT128DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  SetLength(Source, length(inBuff), KDT128DC_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT128DC_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT128DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT128DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT128DC.BuildKDTreeWithCluster(const inBuff: TKDT128DC_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TKMIntegerArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT128DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT128DC_BuildCall);
var
  TempStoreBuff: TKDT128DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT128DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT128DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT128DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT128DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT128DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT128DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT128DC_BuildMethod);
var
  TempStoreBuff: TKDT128DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT128DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT128DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT128DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT128DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT128DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT128DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT128DC_BuildProc);
var
  TempStoreBuff: TKDT128DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT128DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT128DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT128DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT128DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT128DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

function TKDT128DC.Search(const buff: TKDT128DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT128DC_Node;

var
  NearestNeighbour: PKDT128DC_Node;

  function FindParentNode(const buffPtr: PKDT128DC_Vec; NodePtr: PKDT128DC_Node): PKDT128DC_Node;
  var
    Next: PKDT128DC_Node;
    Depth, axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        axis := Depth mod KDT128DC_Axis;
        if buffPtr^[axis] > Next^.Vec^.buff[axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT128DC_Node; const buffPtr: PKDT128DC_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    Inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := Distance(buffPtr^, NodePtr^.Vec^.buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.Vec^.Index < NearestNeighbour^.Vec^.Index) then
        NearestNeighbour := NodePtr;

    axis := Depth mod KDT128DC_Axis;
    Dist := NodePtr^.Vec^.buff[axis] - buffPtr^[axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.Vec^.buff[axis] > buffPtr^[axis] then
            ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const buffPtr: PKDT128DC_Vec; const p1, p2: PKDT128DC_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := Distance(buffPtr^, p1^.Vec^.buff);
    d2 := Distance(buffPtr^, p2^.Vec^.buff);
    if d1 = d2 then
      begin
        if p1^.Vec^.Index = p2^.Vec^.Index then
            Result := 0
        else if p1^.Vec^.Index < p2^.Vec^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; L, R: NativeInt; const buffPtr: PKDT128DC_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT128DC_Node;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer[(L + R) shr 1];
      repeat
        while SortCompare(buffPtr, SortBuffer[i], p) < 0 do
            Inc(i);
        while SortCompare(buffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, buffPtr);
      L := i;
    until i >= R;
  end;

var
  Parent: PKDT128DC_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := Distance(buff, Parent^.Vec^.buff);

  ScanSubtree(RootNode, @buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT128DC_Node(NearestNodes[0]);
    end;
end;

function TKDT128DC.Search(const buff: TKDT128DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT128DC_Node;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT128DC.Search(const buff: TKDT128DC_Vec; var SearchedDistanceMin: Double): PKDT128DC_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT128DC.Search(const buff: TKDT128DC_Vec): PKDT128DC_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT128DC.SearchToken(const buff: TKDT128DC_Vec): TPascalString;
var
  p: PKDT128DC_Node;
begin
  p := Search(buff);
  if p <> nil then
      Result := p^.Vec^.Token
  else
      Result := '';
end;

procedure TKDT128DC.Search(const inBuff: TKDT128DC_DynamicVecBuffer; var OutBuff: TKDT128DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT128DC_DynamicVecBuffer;
  outBuffPtr: PKDT128DC_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT128DC_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outBuffPtr^[pass] := p^.Vec^.buff;
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT128DC_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outBuffPtr^[pass] := p^.Vec^.buff;
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT128DC_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.Vec^.buff;
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT128DC.Search(const inBuff: TKDT128DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT128DC_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT128DC_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT128DC_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT128DC_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT128DC.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  ID := KDT128DC_Axis;

  stream.write(st, 4);
  stream.write(ID, 4);

  stream.write(cnt, 8);

  i := 0;
  while i < cnt do
    begin
      stream.write(KDStoreBuff[i].buff[0], SizeOf(TKDT128DC_Vec));
      stream.write(KDStoreBuff[i].Index, 8);
      token_B := KDStoreBuff[i].Token.Bytes;
      token_L := length(token_B);
      stream.write(token_L, 4);
      if token_L > 0 then
        begin
          stream.write(token_B[0], token_L);
          SetLength(token_B, 0);
        end;
      Inc(i);
    end;
end;

procedure TKDT128DC.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  Clear;

  stream.read(st, 4);
  stream.read(ID, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if ID <> KDT128DC_Axis then
      RaiseInfo('kdtree axis error!');

  stream.read(cnt, 8);

  SetLength(KDStoreBuff, cnt);

  i := 0;
  try
    while i < cnt do
      begin
        if stream.read(KDStoreBuff[i].buff[0], SizeOf(TKDT128DC_Vec)) <> SizeOf(TKDT128DC_Vec) then
          begin
            Clear;
            Exit;
          end;
        if stream.read(KDStoreBuff[i].Index, 8) <> 8 then
          begin
            Clear;
            Exit;
          end;
        if stream.read(token_L, 4) <> 4 then
          begin
            Clear;
            Exit;
          end;
        if token_L > 0 then
          begin
            SetLength(token_B, token_L);
            if stream.read(token_B[0], token_L) <> token_L then
              begin
                Clear;
                Exit;
              end;
            KDStoreBuff[i].Token.Bytes := token_B;
            SetLength(token_B, 0);
          end
        else
            KDStoreBuff[i].Token := '';
        Inc(i);
      end;
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      Inc(i);
    end;

  if cnt > 0 then
      RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT128DC.SaveToFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(FileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT128DC.LoadFromFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT128DC.PrintNodeTree(const NodePtr: PKDT128DC_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT128DC_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.Vec^.Index, Vec(p^.Vec^.buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT128DC.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d - %d : %s ', [i, KDStoreBuff[i].Index, Vec(KDStoreBuff[i].buff)]);
end;

class function TKDT128DC.Vec(const s: SystemString): TKDT128DC_Vec;
var
  t: TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j: NativeInt;
begin
  for i := 0 to KDT128DC_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            Inc(j);
            if j >= KDT128DC_Axis then
                Break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT128DC.Vec(const v: TKDT128DC_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT128DC_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT128DC.Distance(const v1, v2: TKDT128DC_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT128DC_Axis - 1 do
      Result := Result + (v2[i] - v1[i]) * (v2[i] - v1[i]);
end;

procedure TKDT128DC.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT128DC_Source; const Data: Pointer);
begin
  Source.buff := TestBuff[IndexFor];
  Source.Token := umlIntToStr(IndexFor);
end;

class procedure TKDT128DC.Test;
var
  TKDT128DC_Test: TKDT128DC;
  t: TTimeTick;
  i, j: NativeInt;
  TestResultBuff: TKDT128DC_DynamicVecBuffer;
  TestResultIndex: TKMIntegerArray;
  KMeanOutIndex: TKMIntegerArray;
  errored: Boolean;
  m64: TMemoryStream64;
  p: PKDT128DC_Node;
  n: TPascalString;
begin
  errored := False;
  n := PFormat('test %s...', [ClassName]);
  t := GetTimeTick;

  n.Append('...build');
  TKDT128DC_Test := TKDT128DC.Create;

  n.Append('...');
  SetLength(TKDT128DC_Test.TestBuff, 1000);
  for i := 0 to length(TKDT128DC_Test.TestBuff) - 1 do
    for j := 0 to KDT128DC_Axis - 1 do
        TKDT128DC_Test.TestBuff[i][j] := i * KDT128DC_Axis + j;

{$IFDEF FPC}
  TKDT128DC_Test.BuildKDTreeM(length(TKDT128DC_Test.TestBuff), nil, @TKDT128DC_Test.Test_BuildM);
{$ELSE FPC}
  TKDT128DC_Test.BuildKDTreeM(length(TKDT128DC_Test.TestBuff), nil, TKDT128DC_Test.Test_BuildM);
{$ENDIF FPC}
  { save/load test }
  n.Append('...save/load');
  m64 := TMemoryStream64.CustomCreate(1024 * 1024);
  TKDT128DC_Test.SaveToStream(m64);
  m64.Position := 0;
  TKDT128DC_Test.LoadFromStream(m64);
  for i := 0 to length(TKDT128DC_Test.TestBuff) - 1 do
    begin
      p := TKDT128DC_Test.Search(TKDT128DC_Test.TestBuff[i]);
      if p^.Vec^.Index <> i then
          errored := True;
      if not p^.Vec^.Token.Same(umlIntToStr(i)) then
          errored := True;
      if errored then
          Break;
    end;
  DisposeObject(m64);

  if not errored then
    begin
      { parallel search test }
      n.Append('...parallel');
      SetLength(TestResultBuff, length(TKDT128DC_Test.TestBuff));
      SetLength(TestResultIndex, length(TKDT128DC_Test.TestBuff));
      TKDT128DC_Test.Search(TKDT128DC_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if Distance(TKDT128DC_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
            errored := True;
    end;

  if not errored then
    begin
      n.Append('...kMean');
      TKDT128DC_Test.Clear;
      { kMean test }
      TKDT128DC_Test.BuildKDTreeWithCluster(TKDT128DC_Test.TestBuff, 10, 1, KMeanOutIndex);
      { parallel search test }
      TKDT128DC_Test.Search(TKDT128DC_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if TestResultIndex[i] <> KMeanOutIndex[i] then
            errored := True;
    end;

  SetLength(TKDT128DC_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT128DC_Test.Clear;

  n.Append('...');
  if errored then
      n.Append('error!')
  else
      n.Append('passed ok %dms', [GetTimeTick - t]);
  DisposeObject(TKDT128DC_Test);
  DoStatus(n);
  n := '';
end;

function TKDT156DC.InternalBuildKdTree(const KDSourceBufferPtr: PKDT156DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT156DC_Node;
  function SortCompare(const p1, p2: PKDT156DC_Source; const axis: NativeInt): ShortInt;
  begin
    if p1^.buff[axis] = p2^.buff[axis] then
      begin
        if p1^.Index = p2^.Index then
            Result := 0
        else if p1^.Index < p2^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.buff[axis] < p2^.buff[axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT156DC_SourceBuffer; L, R: NativeInt; const axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT156DC_Source;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer^[(L + R) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, axis) < 0 do
            Inc(i);
        while SortCompare(SortBuffer^[j], p, axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, axis);
      L := i;
    until i >= R;
  end;

var
  M: NativeInt;
  axis: NativeInt;
  kdBuffPtr: PKDT156DC_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      new(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.Vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);
    end
  else
    begin
      axis := Depth mod KDT156DC_Axis;
      M := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr^[0], 0, PlanCount - 1, axis);

      new(Result);
      Result^.Parent := nil;
      Result^.Vec := kdBuffPtr^[M];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], M, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[M + 1], PlanCount - (M + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT156DC.GetData(const Index: NativeInt): PKDT156DC_Source;
begin
  Result := @KDStoreBuff[Index];
end;

constructor TKDT156DC.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT156DC.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT156DC.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT156DC_Node(KDNodes[i]));
      Inc(i);
    end;

  for i := 0 to length(KDStoreBuff) - 1 do
      KDStoreBuff[i].Token := '';

  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT156DC.StoreBuffPtr: PKDT156DC_DyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT156DC.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT156DC_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT156DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT156DC.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT156DC_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT156DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT156DC.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT156DC_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT156DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{ k-means++ clusterization }
procedure TKDT156DC.BuildKDTreeWithCluster(const inBuff: TKDT156DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  SetLength(Source, length(inBuff), KDT156DC_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT156DC_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT156DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT156DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT156DC.BuildKDTreeWithCluster(const inBuff: TKDT156DC_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TKMIntegerArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT156DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT156DC_BuildCall);
var
  TempStoreBuff: TKDT156DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT156DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT156DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT156DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT156DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT156DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT156DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT156DC_BuildMethod);
var
  TempStoreBuff: TKDT156DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT156DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT156DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT156DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT156DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT156DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT156DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT156DC_BuildProc);
var
  TempStoreBuff: TKDT156DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT156DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT156DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT156DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT156DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT156DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

function TKDT156DC.Search(const buff: TKDT156DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT156DC_Node;

var
  NearestNeighbour: PKDT156DC_Node;

  function FindParentNode(const buffPtr: PKDT156DC_Vec; NodePtr: PKDT156DC_Node): PKDT156DC_Node;
  var
    Next: PKDT156DC_Node;
    Depth, axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        axis := Depth mod KDT156DC_Axis;
        if buffPtr^[axis] > Next^.Vec^.buff[axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT156DC_Node; const buffPtr: PKDT156DC_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    Inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := Distance(buffPtr^, NodePtr^.Vec^.buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.Vec^.Index < NearestNeighbour^.Vec^.Index) then
        NearestNeighbour := NodePtr;

    axis := Depth mod KDT156DC_Axis;
    Dist := NodePtr^.Vec^.buff[axis] - buffPtr^[axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.Vec^.buff[axis] > buffPtr^[axis] then
            ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const buffPtr: PKDT156DC_Vec; const p1, p2: PKDT156DC_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := Distance(buffPtr^, p1^.Vec^.buff);
    d2 := Distance(buffPtr^, p2^.Vec^.buff);
    if d1 = d2 then
      begin
        if p1^.Vec^.Index = p2^.Vec^.Index then
            Result := 0
        else if p1^.Vec^.Index < p2^.Vec^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; L, R: NativeInt; const buffPtr: PKDT156DC_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT156DC_Node;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer[(L + R) shr 1];
      repeat
        while SortCompare(buffPtr, SortBuffer[i], p) < 0 do
            Inc(i);
        while SortCompare(buffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, buffPtr);
      L := i;
    until i >= R;
  end;

var
  Parent: PKDT156DC_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := Distance(buff, Parent^.Vec^.buff);

  ScanSubtree(RootNode, @buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT156DC_Node(NearestNodes[0]);
    end;
end;

function TKDT156DC.Search(const buff: TKDT156DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT156DC_Node;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT156DC.Search(const buff: TKDT156DC_Vec; var SearchedDistanceMin: Double): PKDT156DC_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT156DC.Search(const buff: TKDT156DC_Vec): PKDT156DC_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT156DC.SearchToken(const buff: TKDT156DC_Vec): TPascalString;
var
  p: PKDT156DC_Node;
begin
  p := Search(buff);
  if p <> nil then
      Result := p^.Vec^.Token
  else
      Result := '';
end;

procedure TKDT156DC.Search(const inBuff: TKDT156DC_DynamicVecBuffer; var OutBuff: TKDT156DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT156DC_DynamicVecBuffer;
  outBuffPtr: PKDT156DC_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT156DC_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outBuffPtr^[pass] := p^.Vec^.buff;
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT156DC_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outBuffPtr^[pass] := p^.Vec^.buff;
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT156DC_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.Vec^.buff;
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT156DC.Search(const inBuff: TKDT156DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT156DC_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT156DC_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT156DC_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT156DC_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT156DC.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  ID := KDT156DC_Axis;

  stream.write(st, 4);
  stream.write(ID, 4);

  stream.write(cnt, 8);

  i := 0;
  while i < cnt do
    begin
      stream.write(KDStoreBuff[i].buff[0], SizeOf(TKDT156DC_Vec));
      stream.write(KDStoreBuff[i].Index, 8);
      token_B := KDStoreBuff[i].Token.Bytes;
      token_L := length(token_B);
      stream.write(token_L, 4);
      if token_L > 0 then
        begin
          stream.write(token_B[0], token_L);
          SetLength(token_B, 0);
        end;
      Inc(i);
    end;
end;

procedure TKDT156DC.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  Clear;

  stream.read(st, 4);
  stream.read(ID, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if ID <> KDT156DC_Axis then
      RaiseInfo('kdtree axis error!');

  stream.read(cnt, 8);

  SetLength(KDStoreBuff, cnt);

  i := 0;
  try
    while i < cnt do
      begin
        if stream.read(KDStoreBuff[i].buff[0], SizeOf(TKDT156DC_Vec)) <> SizeOf(TKDT156DC_Vec) then
          begin
            Clear;
            Exit;
          end;
        if stream.read(KDStoreBuff[i].Index, 8) <> 8 then
          begin
            Clear;
            Exit;
          end;
        if stream.read(token_L, 4) <> 4 then
          begin
            Clear;
            Exit;
          end;
        if token_L > 0 then
          begin
            SetLength(token_B, token_L);
            if stream.read(token_B[0], token_L) <> token_L then
              begin
                Clear;
                Exit;
              end;
            KDStoreBuff[i].Token.Bytes := token_B;
            SetLength(token_B, 0);
          end
        else
            KDStoreBuff[i].Token := '';
        Inc(i);
      end;
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      Inc(i);
    end;

  if cnt > 0 then
      RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT156DC.SaveToFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(FileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT156DC.LoadFromFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT156DC.PrintNodeTree(const NodePtr: PKDT156DC_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT156DC_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.Vec^.Index, Vec(p^.Vec^.buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT156DC.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d - %d : %s ', [i, KDStoreBuff[i].Index, Vec(KDStoreBuff[i].buff)]);
end;

class function TKDT156DC.Vec(const s: SystemString): TKDT156DC_Vec;
var
  t: TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j: NativeInt;
begin
  for i := 0 to KDT156DC_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            Inc(j);
            if j >= KDT156DC_Axis then
                Break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT156DC.Vec(const v: TKDT156DC_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT156DC_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT156DC.Distance(const v1, v2: TKDT156DC_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT156DC_Axis - 1 do
      Result := Result + (v2[i] - v1[i]) * (v2[i] - v1[i]);
end;

procedure TKDT156DC.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT156DC_Source; const Data: Pointer);
begin
  Source.buff := TestBuff[IndexFor];
  Source.Token := umlIntToStr(IndexFor);
end;

class procedure TKDT156DC.Test;
var
  TKDT156DC_Test: TKDT156DC;
  t: TTimeTick;
  i, j: NativeInt;
  TestResultBuff: TKDT156DC_DynamicVecBuffer;
  TestResultIndex: TKMIntegerArray;
  KMeanOutIndex: TKMIntegerArray;
  errored: Boolean;
  m64: TMemoryStream64;
  p: PKDT156DC_Node;
  n: TPascalString;
begin
  errored := False;
  n := PFormat('test %s...', [ClassName]);
  t := GetTimeTick;

  n.Append('...build');
  TKDT156DC_Test := TKDT156DC.Create;

  n.Append('...');
  SetLength(TKDT156DC_Test.TestBuff, 1000);
  for i := 0 to length(TKDT156DC_Test.TestBuff) - 1 do
    for j := 0 to KDT156DC_Axis - 1 do
        TKDT156DC_Test.TestBuff[i][j] := i * KDT156DC_Axis + j;

{$IFDEF FPC}
  TKDT156DC_Test.BuildKDTreeM(length(TKDT156DC_Test.TestBuff), nil, @TKDT156DC_Test.Test_BuildM);
{$ELSE FPC}
  TKDT156DC_Test.BuildKDTreeM(length(TKDT156DC_Test.TestBuff), nil, TKDT156DC_Test.Test_BuildM);
{$ENDIF FPC}
  { save/load test }
  n.Append('...save/load');
  m64 := TMemoryStream64.CustomCreate(1024 * 1024);
  TKDT156DC_Test.SaveToStream(m64);
  m64.Position := 0;
  TKDT156DC_Test.LoadFromStream(m64);
  for i := 0 to length(TKDT156DC_Test.TestBuff) - 1 do
    begin
      p := TKDT156DC_Test.Search(TKDT156DC_Test.TestBuff[i]);
      if p^.Vec^.Index <> i then
          errored := True;
      if not p^.Vec^.Token.Same(umlIntToStr(i)) then
          errored := True;
      if errored then
          Break;
    end;
  DisposeObject(m64);

  if not errored then
    begin
      { parallel search test }
      n.Append('...parallel');
      SetLength(TestResultBuff, length(TKDT156DC_Test.TestBuff));
      SetLength(TestResultIndex, length(TKDT156DC_Test.TestBuff));
      TKDT156DC_Test.Search(TKDT156DC_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if Distance(TKDT156DC_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
            errored := True;
    end;

  if not errored then
    begin
      n.Append('...kMean');
      TKDT156DC_Test.Clear;
      { kMean test }
      TKDT156DC_Test.BuildKDTreeWithCluster(TKDT156DC_Test.TestBuff, 10, 1, KMeanOutIndex);
      { parallel search test }
      TKDT156DC_Test.Search(TKDT156DC_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if TestResultIndex[i] <> KMeanOutIndex[i] then
            errored := True;
    end;

  SetLength(TKDT156DC_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT156DC_Test.Clear;

  n.Append('...');
  if errored then
      n.Append('error!')
  else
      n.Append('passed ok %dms', [GetTimeTick - t]);
  DisposeObject(TKDT156DC_Test);
  DoStatus(n);
  n := '';
end;

function TKDT192DC.InternalBuildKdTree(const KDSourceBufferPtr: PKDT192DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT192DC_Node;
  function SortCompare(const p1, p2: PKDT192DC_Source; const axis: NativeInt): ShortInt;
  begin
    if p1^.buff[axis] = p2^.buff[axis] then
      begin
        if p1^.Index = p2^.Index then
            Result := 0
        else if p1^.Index < p2^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.buff[axis] < p2^.buff[axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT192DC_SourceBuffer; L, R: NativeInt; const axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT192DC_Source;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer^[(L + R) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, axis) < 0 do
            Inc(i);
        while SortCompare(SortBuffer^[j], p, axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, axis);
      L := i;
    until i >= R;
  end;

var
  M: NativeInt;
  axis: NativeInt;
  kdBuffPtr: PKDT192DC_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      new(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.Vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);
    end
  else
    begin
      axis := Depth mod KDT192DC_Axis;
      M := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr^[0], 0, PlanCount - 1, axis);

      new(Result);
      Result^.Parent := nil;
      Result^.Vec := kdBuffPtr^[M];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], M, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[M + 1], PlanCount - (M + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT192DC.GetData(const Index: NativeInt): PKDT192DC_Source;
begin
  Result := @KDStoreBuff[Index];
end;

constructor TKDT192DC.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT192DC.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT192DC.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT192DC_Node(KDNodes[i]));
      Inc(i);
    end;

  for i := 0 to length(KDStoreBuff) - 1 do
      KDStoreBuff[i].Token := '';

  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT192DC.StoreBuffPtr: PKDT192DC_DyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT192DC.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT192DC_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT192DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT192DC.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT192DC_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT192DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT192DC.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT192DC_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT192DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{ k-means++ clusterization }
procedure TKDT192DC.BuildKDTreeWithCluster(const inBuff: TKDT192DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  SetLength(Source, length(inBuff), KDT192DC_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT192DC_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT192DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT192DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT192DC.BuildKDTreeWithCluster(const inBuff: TKDT192DC_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TKMIntegerArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT192DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT192DC_BuildCall);
var
  TempStoreBuff: TKDT192DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT192DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT192DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT192DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT192DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT192DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT192DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT192DC_BuildMethod);
var
  TempStoreBuff: TKDT192DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT192DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT192DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT192DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT192DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT192DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT192DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT192DC_BuildProc);
var
  TempStoreBuff: TKDT192DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT192DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT192DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT192DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT192DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT192DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

function TKDT192DC.Search(const buff: TKDT192DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT192DC_Node;

var
  NearestNeighbour: PKDT192DC_Node;

  function FindParentNode(const buffPtr: PKDT192DC_Vec; NodePtr: PKDT192DC_Node): PKDT192DC_Node;
  var
    Next: PKDT192DC_Node;
    Depth, axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        axis := Depth mod KDT192DC_Axis;
        if buffPtr^[axis] > Next^.Vec^.buff[axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT192DC_Node; const buffPtr: PKDT192DC_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    Inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := Distance(buffPtr^, NodePtr^.Vec^.buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.Vec^.Index < NearestNeighbour^.Vec^.Index) then
        NearestNeighbour := NodePtr;

    axis := Depth mod KDT192DC_Axis;
    Dist := NodePtr^.Vec^.buff[axis] - buffPtr^[axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.Vec^.buff[axis] > buffPtr^[axis] then
            ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const buffPtr: PKDT192DC_Vec; const p1, p2: PKDT192DC_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := Distance(buffPtr^, p1^.Vec^.buff);
    d2 := Distance(buffPtr^, p2^.Vec^.buff);
    if d1 = d2 then
      begin
        if p1^.Vec^.Index = p2^.Vec^.Index then
            Result := 0
        else if p1^.Vec^.Index < p2^.Vec^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; L, R: NativeInt; const buffPtr: PKDT192DC_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT192DC_Node;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer[(L + R) shr 1];
      repeat
        while SortCompare(buffPtr, SortBuffer[i], p) < 0 do
            Inc(i);
        while SortCompare(buffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, buffPtr);
      L := i;
    until i >= R;
  end;

var
  Parent: PKDT192DC_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := Distance(buff, Parent^.Vec^.buff);

  ScanSubtree(RootNode, @buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT192DC_Node(NearestNodes[0]);
    end;
end;

function TKDT192DC.Search(const buff: TKDT192DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT192DC_Node;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT192DC.Search(const buff: TKDT192DC_Vec; var SearchedDistanceMin: Double): PKDT192DC_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT192DC.Search(const buff: TKDT192DC_Vec): PKDT192DC_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT192DC.SearchToken(const buff: TKDT192DC_Vec): TPascalString;
var
  p: PKDT192DC_Node;
begin
  p := Search(buff);
  if p <> nil then
      Result := p^.Vec^.Token
  else
      Result := '';
end;

procedure TKDT192DC.Search(const inBuff: TKDT192DC_DynamicVecBuffer; var OutBuff: TKDT192DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT192DC_DynamicVecBuffer;
  outBuffPtr: PKDT192DC_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT192DC_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outBuffPtr^[pass] := p^.Vec^.buff;
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT192DC_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outBuffPtr^[pass] := p^.Vec^.buff;
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT192DC_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.Vec^.buff;
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT192DC.Search(const inBuff: TKDT192DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT192DC_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT192DC_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT192DC_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT192DC_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT192DC.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  ID := KDT192DC_Axis;

  stream.write(st, 4);
  stream.write(ID, 4);

  stream.write(cnt, 8);

  i := 0;
  while i < cnt do
    begin
      stream.write(KDStoreBuff[i].buff[0], SizeOf(TKDT192DC_Vec));
      stream.write(KDStoreBuff[i].Index, 8);
      token_B := KDStoreBuff[i].Token.Bytes;
      token_L := length(token_B);
      stream.write(token_L, 4);
      if token_L > 0 then
        begin
          stream.write(token_B[0], token_L);
          SetLength(token_B, 0);
        end;
      Inc(i);
    end;
end;

procedure TKDT192DC.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  Clear;

  stream.read(st, 4);
  stream.read(ID, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if ID <> KDT192DC_Axis then
      RaiseInfo('kdtree axis error!');

  stream.read(cnt, 8);

  SetLength(KDStoreBuff, cnt);

  i := 0;
  try
    while i < cnt do
      begin
        if stream.read(KDStoreBuff[i].buff[0], SizeOf(TKDT192DC_Vec)) <> SizeOf(TKDT192DC_Vec) then
          begin
            Clear;
            Exit;
          end;
        if stream.read(KDStoreBuff[i].Index, 8) <> 8 then
          begin
            Clear;
            Exit;
          end;
        if stream.read(token_L, 4) <> 4 then
          begin
            Clear;
            Exit;
          end;
        if token_L > 0 then
          begin
            SetLength(token_B, token_L);
            if stream.read(token_B[0], token_L) <> token_L then
              begin
                Clear;
                Exit;
              end;
            KDStoreBuff[i].Token.Bytes := token_B;
            SetLength(token_B, 0);
          end
        else
            KDStoreBuff[i].Token := '';
        Inc(i);
      end;
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      Inc(i);
    end;

  if cnt > 0 then
      RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT192DC.SaveToFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(FileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT192DC.LoadFromFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT192DC.PrintNodeTree(const NodePtr: PKDT192DC_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT192DC_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.Vec^.Index, Vec(p^.Vec^.buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT192DC.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d - %d : %s ', [i, KDStoreBuff[i].Index, Vec(KDStoreBuff[i].buff)]);
end;

class function TKDT192DC.Vec(const s: SystemString): TKDT192DC_Vec;
var
  t: TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j: NativeInt;
begin
  for i := 0 to KDT192DC_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            Inc(j);
            if j >= KDT192DC_Axis then
                Break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT192DC.Vec(const v: TKDT192DC_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT192DC_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT192DC.Distance(const v1, v2: TKDT192DC_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT192DC_Axis - 1 do
      Result := Result + (v2[i] - v1[i]) * (v2[i] - v1[i]);
end;

procedure TKDT192DC.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT192DC_Source; const Data: Pointer);
begin
  Source.buff := TestBuff[IndexFor];
  Source.Token := umlIntToStr(IndexFor);
end;

class procedure TKDT192DC.Test;
var
  TKDT192DC_Test: TKDT192DC;
  t: TTimeTick;
  i, j: NativeInt;
  TestResultBuff: TKDT192DC_DynamicVecBuffer;
  TestResultIndex: TKMIntegerArray;
  KMeanOutIndex: TKMIntegerArray;
  errored: Boolean;
  m64: TMemoryStream64;
  p: PKDT192DC_Node;
  n: TPascalString;
begin
  errored := False;
  n := PFormat('test %s...', [ClassName]);
  t := GetTimeTick;

  n.Append('...build');
  TKDT192DC_Test := TKDT192DC.Create;

  n.Append('...');
  SetLength(TKDT192DC_Test.TestBuff, 1000);
  for i := 0 to length(TKDT192DC_Test.TestBuff) - 1 do
    for j := 0 to KDT192DC_Axis - 1 do
        TKDT192DC_Test.TestBuff[i][j] := i * KDT192DC_Axis + j;

{$IFDEF FPC}
  TKDT192DC_Test.BuildKDTreeM(length(TKDT192DC_Test.TestBuff), nil, @TKDT192DC_Test.Test_BuildM);
{$ELSE FPC}
  TKDT192DC_Test.BuildKDTreeM(length(TKDT192DC_Test.TestBuff), nil, TKDT192DC_Test.Test_BuildM);
{$ENDIF FPC}
  { save/load test }
  n.Append('...save/load');
  m64 := TMemoryStream64.CustomCreate(1024 * 1024);
  TKDT192DC_Test.SaveToStream(m64);
  m64.Position := 0;
  TKDT192DC_Test.LoadFromStream(m64);
  for i := 0 to length(TKDT192DC_Test.TestBuff) - 1 do
    begin
      p := TKDT192DC_Test.Search(TKDT192DC_Test.TestBuff[i]);
      if p^.Vec^.Index <> i then
          errored := True;
      if not p^.Vec^.Token.Same(umlIntToStr(i)) then
          errored := True;
      if errored then
          Break;
    end;
  DisposeObject(m64);

  if not errored then
    begin
      { parallel search test }
      n.Append('...parallel');
      SetLength(TestResultBuff, length(TKDT192DC_Test.TestBuff));
      SetLength(TestResultIndex, length(TKDT192DC_Test.TestBuff));
      TKDT192DC_Test.Search(TKDT192DC_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if Distance(TKDT192DC_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
            errored := True;
    end;

  if not errored then
    begin
      n.Append('...kMean');
      TKDT192DC_Test.Clear;
      { kMean test }
      TKDT192DC_Test.BuildKDTreeWithCluster(TKDT192DC_Test.TestBuff, 10, 1, KMeanOutIndex);
      { parallel search test }
      TKDT192DC_Test.Search(TKDT192DC_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if TestResultIndex[i] <> KMeanOutIndex[i] then
            errored := True;
    end;

  SetLength(TKDT192DC_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT192DC_Test.Clear;

  n.Append('...');
  if errored then
      n.Append('error!')
  else
      n.Append('passed ok %dms', [GetTimeTick - t]);
  DisposeObject(TKDT192DC_Test);
  DoStatus(n);
  n := '';
end;

function TKDT256DC.InternalBuildKdTree(const KDSourceBufferPtr: PKDT256DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT256DC_Node;
  function SortCompare(const p1, p2: PKDT256DC_Source; const axis: NativeInt): ShortInt;
  begin
    if p1^.buff[axis] = p2^.buff[axis] then
      begin
        if p1^.Index = p2^.Index then
            Result := 0
        else if p1^.Index < p2^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.buff[axis] < p2^.buff[axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT256DC_SourceBuffer; L, R: NativeInt; const axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT256DC_Source;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer^[(L + R) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, axis) < 0 do
            Inc(i);
        while SortCompare(SortBuffer^[j], p, axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, axis);
      L := i;
    until i >= R;
  end;

var
  M: NativeInt;
  axis: NativeInt;
  kdBuffPtr: PKDT256DC_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      new(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.Vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);
    end
  else
    begin
      axis := Depth mod KDT256DC_Axis;
      M := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr^[0], 0, PlanCount - 1, axis);

      new(Result);
      Result^.Parent := nil;
      Result^.Vec := kdBuffPtr^[M];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], M, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[M + 1], PlanCount - (M + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT256DC.GetData(const Index: NativeInt): PKDT256DC_Source;
begin
  Result := @KDStoreBuff[Index];
end;

constructor TKDT256DC.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT256DC.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT256DC.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT256DC_Node(KDNodes[i]));
      Inc(i);
    end;

  for i := 0 to length(KDStoreBuff) - 1 do
      KDStoreBuff[i].Token := '';

  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT256DC.StoreBuffPtr: PKDT256DC_DyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT256DC.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT256DC_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT256DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT256DC.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT256DC_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT256DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT256DC.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT256DC_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT256DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{ k-means++ clusterization }
procedure TKDT256DC.BuildKDTreeWithCluster(const inBuff: TKDT256DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  SetLength(Source, length(inBuff), KDT256DC_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT256DC_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT256DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT256DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT256DC.BuildKDTreeWithCluster(const inBuff: TKDT256DC_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TKMIntegerArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT256DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT256DC_BuildCall);
var
  TempStoreBuff: TKDT256DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT256DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT256DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT256DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT256DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT256DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT256DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT256DC_BuildMethod);
var
  TempStoreBuff: TKDT256DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT256DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT256DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT256DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT256DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT256DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT256DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT256DC_BuildProc);
var
  TempStoreBuff: TKDT256DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT256DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT256DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT256DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT256DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT256DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

function TKDT256DC.Search(const buff: TKDT256DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT256DC_Node;

var
  NearestNeighbour: PKDT256DC_Node;

  function FindParentNode(const buffPtr: PKDT256DC_Vec; NodePtr: PKDT256DC_Node): PKDT256DC_Node;
  var
    Next: PKDT256DC_Node;
    Depth, axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        axis := Depth mod KDT256DC_Axis;
        if buffPtr^[axis] > Next^.Vec^.buff[axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT256DC_Node; const buffPtr: PKDT256DC_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    Inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := Distance(buffPtr^, NodePtr^.Vec^.buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.Vec^.Index < NearestNeighbour^.Vec^.Index) then
        NearestNeighbour := NodePtr;

    axis := Depth mod KDT256DC_Axis;
    Dist := NodePtr^.Vec^.buff[axis] - buffPtr^[axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.Vec^.buff[axis] > buffPtr^[axis] then
            ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const buffPtr: PKDT256DC_Vec; const p1, p2: PKDT256DC_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := Distance(buffPtr^, p1^.Vec^.buff);
    d2 := Distance(buffPtr^, p2^.Vec^.buff);
    if d1 = d2 then
      begin
        if p1^.Vec^.Index = p2^.Vec^.Index then
            Result := 0
        else if p1^.Vec^.Index < p2^.Vec^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; L, R: NativeInt; const buffPtr: PKDT256DC_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT256DC_Node;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer[(L + R) shr 1];
      repeat
        while SortCompare(buffPtr, SortBuffer[i], p) < 0 do
            Inc(i);
        while SortCompare(buffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, buffPtr);
      L := i;
    until i >= R;
  end;

var
  Parent: PKDT256DC_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := Distance(buff, Parent^.Vec^.buff);

  ScanSubtree(RootNode, @buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT256DC_Node(NearestNodes[0]);
    end;
end;

function TKDT256DC.Search(const buff: TKDT256DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT256DC_Node;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT256DC.Search(const buff: TKDT256DC_Vec; var SearchedDistanceMin: Double): PKDT256DC_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT256DC.Search(const buff: TKDT256DC_Vec): PKDT256DC_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT256DC.SearchToken(const buff: TKDT256DC_Vec): TPascalString;
var
  p: PKDT256DC_Node;
begin
  p := Search(buff);
  if p <> nil then
      Result := p^.Vec^.Token
  else
      Result := '';
end;

procedure TKDT256DC.Search(const inBuff: TKDT256DC_DynamicVecBuffer; var OutBuff: TKDT256DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT256DC_DynamicVecBuffer;
  outBuffPtr: PKDT256DC_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT256DC_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outBuffPtr^[pass] := p^.Vec^.buff;
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT256DC_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outBuffPtr^[pass] := p^.Vec^.buff;
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT256DC_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.Vec^.buff;
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT256DC.Search(const inBuff: TKDT256DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT256DC_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT256DC_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT256DC_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT256DC_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT256DC.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  ID := KDT256DC_Axis;

  stream.write(st, 4);
  stream.write(ID, 4);

  stream.write(cnt, 8);

  i := 0;
  while i < cnt do
    begin
      stream.write(KDStoreBuff[i].buff[0], SizeOf(TKDT256DC_Vec));
      stream.write(KDStoreBuff[i].Index, 8);
      token_B := KDStoreBuff[i].Token.Bytes;
      token_L := length(token_B);
      stream.write(token_L, 4);
      if token_L > 0 then
        begin
          stream.write(token_B[0], token_L);
          SetLength(token_B, 0);
        end;
      Inc(i);
    end;
end;

procedure TKDT256DC.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  Clear;

  stream.read(st, 4);
  stream.read(ID, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if ID <> KDT256DC_Axis then
      RaiseInfo('kdtree axis error!');

  stream.read(cnt, 8);

  SetLength(KDStoreBuff, cnt);

  i := 0;
  try
    while i < cnt do
      begin
        if stream.read(KDStoreBuff[i].buff[0], SizeOf(TKDT256DC_Vec)) <> SizeOf(TKDT256DC_Vec) then
          begin
            Clear;
            Exit;
          end;
        if stream.read(KDStoreBuff[i].Index, 8) <> 8 then
          begin
            Clear;
            Exit;
          end;
        if stream.read(token_L, 4) <> 4 then
          begin
            Clear;
            Exit;
          end;
        if token_L > 0 then
          begin
            SetLength(token_B, token_L);
            if stream.read(token_B[0], token_L) <> token_L then
              begin
                Clear;
                Exit;
              end;
            KDStoreBuff[i].Token.Bytes := token_B;
            SetLength(token_B, 0);
          end
        else
            KDStoreBuff[i].Token := '';
        Inc(i);
      end;
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      Inc(i);
    end;

  if cnt > 0 then
      RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT256DC.SaveToFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(FileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT256DC.LoadFromFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT256DC.PrintNodeTree(const NodePtr: PKDT256DC_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT256DC_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.Vec^.Index, Vec(p^.Vec^.buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT256DC.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d - %d : %s ', [i, KDStoreBuff[i].Index, Vec(KDStoreBuff[i].buff)]);
end;

class function TKDT256DC.Vec(const s: SystemString): TKDT256DC_Vec;
var
  t: TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j: NativeInt;
begin
  for i := 0 to KDT256DC_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            Inc(j);
            if j >= KDT256DC_Axis then
                Break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT256DC.Vec(const v: TKDT256DC_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT256DC_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT256DC.Distance(const v1, v2: TKDT256DC_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT256DC_Axis - 1 do
      Result := Result + (v2[i] - v1[i]) * (v2[i] - v1[i]);
end;

procedure TKDT256DC.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT256DC_Source; const Data: Pointer);
begin
  Source.buff := TestBuff[IndexFor];
  Source.Token := umlIntToStr(IndexFor);
end;

class procedure TKDT256DC.Test;
var
  TKDT256DC_Test: TKDT256DC;
  t: TTimeTick;
  i, j: NativeInt;
  TestResultBuff: TKDT256DC_DynamicVecBuffer;
  TestResultIndex: TKMIntegerArray;
  KMeanOutIndex: TKMIntegerArray;
  errored: Boolean;
  m64: TMemoryStream64;
  p: PKDT256DC_Node;
  n: TPascalString;
begin
  errored := False;
  n := PFormat('test %s...', [ClassName]);
  t := GetTimeTick;

  n.Append('...build');
  TKDT256DC_Test := TKDT256DC.Create;

  n.Append('...');
  SetLength(TKDT256DC_Test.TestBuff, 1000);
  for i := 0 to length(TKDT256DC_Test.TestBuff) - 1 do
    for j := 0 to KDT256DC_Axis - 1 do
        TKDT256DC_Test.TestBuff[i][j] := i * KDT256DC_Axis + j;

{$IFDEF FPC}
  TKDT256DC_Test.BuildKDTreeM(length(TKDT256DC_Test.TestBuff), nil, @TKDT256DC_Test.Test_BuildM);
{$ELSE FPC}
  TKDT256DC_Test.BuildKDTreeM(length(TKDT256DC_Test.TestBuff), nil, TKDT256DC_Test.Test_BuildM);
{$ENDIF FPC}
  { save/load test }
  n.Append('...save/load');
  m64 := TMemoryStream64.CustomCreate(1024 * 1024);
  TKDT256DC_Test.SaveToStream(m64);
  m64.Position := 0;
  TKDT256DC_Test.LoadFromStream(m64);
  for i := 0 to length(TKDT256DC_Test.TestBuff) - 1 do
    begin
      p := TKDT256DC_Test.Search(TKDT256DC_Test.TestBuff[i]);
      if p^.Vec^.Index <> i then
          errored := True;
      if not p^.Vec^.Token.Same(umlIntToStr(i)) then
          errored := True;
      if errored then
          Break;
    end;
  DisposeObject(m64);

  if not errored then
    begin
      { parallel search test }
      n.Append('...parallel');
      SetLength(TestResultBuff, length(TKDT256DC_Test.TestBuff));
      SetLength(TestResultIndex, length(TKDT256DC_Test.TestBuff));
      TKDT256DC_Test.Search(TKDT256DC_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if Distance(TKDT256DC_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
            errored := True;
    end;

  if not errored then
    begin
      n.Append('...kMean');
      TKDT256DC_Test.Clear;
      { kMean test }
      TKDT256DC_Test.BuildKDTreeWithCluster(TKDT256DC_Test.TestBuff, 10, 1, KMeanOutIndex);
      { parallel search test }
      TKDT256DC_Test.Search(TKDT256DC_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if TestResultIndex[i] <> KMeanOutIndex[i] then
            errored := True;
    end;

  SetLength(TKDT256DC_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT256DC_Test.Clear;

  n.Append('...');
  if errored then
      n.Append('error!')
  else
      n.Append('passed ok %dms', [GetTimeTick - t]);
  DisposeObject(TKDT256DC_Test);
  DoStatus(n);
  n := '';
end;

function TKDT384DC.InternalBuildKdTree(const KDSourceBufferPtr: PKDT384DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT384DC_Node;
  function SortCompare(const p1, p2: PKDT384DC_Source; const axis: NativeInt): ShortInt;
  begin
    if p1^.buff[axis] = p2^.buff[axis] then
      begin
        if p1^.Index = p2^.Index then
            Result := 0
        else if p1^.Index < p2^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.buff[axis] < p2^.buff[axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT384DC_SourceBuffer; L, R: NativeInt; const axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT384DC_Source;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer^[(L + R) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, axis) < 0 do
            Inc(i);
        while SortCompare(SortBuffer^[j], p, axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, axis);
      L := i;
    until i >= R;
  end;

var
  M: NativeInt;
  axis: NativeInt;
  kdBuffPtr: PKDT384DC_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      new(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.Vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);
    end
  else
    begin
      axis := Depth mod KDT384DC_Axis;
      M := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr^[0], 0, PlanCount - 1, axis);

      new(Result);
      Result^.Parent := nil;
      Result^.Vec := kdBuffPtr^[M];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], M, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[M + 1], PlanCount - (M + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT384DC.GetData(const Index: NativeInt): PKDT384DC_Source;
begin
  Result := @KDStoreBuff[Index];
end;

constructor TKDT384DC.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT384DC.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT384DC.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT384DC_Node(KDNodes[i]));
      Inc(i);
    end;

  for i := 0 to length(KDStoreBuff) - 1 do
      KDStoreBuff[i].Token := '';

  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT384DC.StoreBuffPtr: PKDT384DC_DyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT384DC.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT384DC_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT384DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT384DC.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT384DC_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT384DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT384DC.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT384DC_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT384DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{ k-means++ clusterization }
procedure TKDT384DC.BuildKDTreeWithCluster(const inBuff: TKDT384DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  SetLength(Source, length(inBuff), KDT384DC_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT384DC_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT384DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT384DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT384DC.BuildKDTreeWithCluster(const inBuff: TKDT384DC_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TKMIntegerArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT384DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT384DC_BuildCall);
var
  TempStoreBuff: TKDT384DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT384DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT384DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT384DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT384DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT384DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT384DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT384DC_BuildMethod);
var
  TempStoreBuff: TKDT384DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT384DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT384DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT384DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT384DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT384DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT384DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT384DC_BuildProc);
var
  TempStoreBuff: TKDT384DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT384DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT384DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT384DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT384DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT384DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

function TKDT384DC.Search(const buff: TKDT384DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT384DC_Node;

var
  NearestNeighbour: PKDT384DC_Node;

  function FindParentNode(const buffPtr: PKDT384DC_Vec; NodePtr: PKDT384DC_Node): PKDT384DC_Node;
  var
    Next: PKDT384DC_Node;
    Depth, axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        axis := Depth mod KDT384DC_Axis;
        if buffPtr^[axis] > Next^.Vec^.buff[axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT384DC_Node; const buffPtr: PKDT384DC_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    Inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := Distance(buffPtr^, NodePtr^.Vec^.buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.Vec^.Index < NearestNeighbour^.Vec^.Index) then
        NearestNeighbour := NodePtr;

    axis := Depth mod KDT384DC_Axis;
    Dist := NodePtr^.Vec^.buff[axis] - buffPtr^[axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.Vec^.buff[axis] > buffPtr^[axis] then
            ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const buffPtr: PKDT384DC_Vec; const p1, p2: PKDT384DC_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := Distance(buffPtr^, p1^.Vec^.buff);
    d2 := Distance(buffPtr^, p2^.Vec^.buff);
    if d1 = d2 then
      begin
        if p1^.Vec^.Index = p2^.Vec^.Index then
            Result := 0
        else if p1^.Vec^.Index < p2^.Vec^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; L, R: NativeInt; const buffPtr: PKDT384DC_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT384DC_Node;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer[(L + R) shr 1];
      repeat
        while SortCompare(buffPtr, SortBuffer[i], p) < 0 do
            Inc(i);
        while SortCompare(buffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, buffPtr);
      L := i;
    until i >= R;
  end;

var
  Parent: PKDT384DC_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := Distance(buff, Parent^.Vec^.buff);

  ScanSubtree(RootNode, @buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT384DC_Node(NearestNodes[0]);
    end;
end;

function TKDT384DC.Search(const buff: TKDT384DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT384DC_Node;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT384DC.Search(const buff: TKDT384DC_Vec; var SearchedDistanceMin: Double): PKDT384DC_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT384DC.Search(const buff: TKDT384DC_Vec): PKDT384DC_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT384DC.SearchToken(const buff: TKDT384DC_Vec): TPascalString;
var
  p: PKDT384DC_Node;
begin
  p := Search(buff);
  if p <> nil then
      Result := p^.Vec^.Token
  else
      Result := '';
end;

procedure TKDT384DC.Search(const inBuff: TKDT384DC_DynamicVecBuffer; var OutBuff: TKDT384DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT384DC_DynamicVecBuffer;
  outBuffPtr: PKDT384DC_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT384DC_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outBuffPtr^[pass] := p^.Vec^.buff;
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT384DC_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outBuffPtr^[pass] := p^.Vec^.buff;
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT384DC_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.Vec^.buff;
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT384DC.Search(const inBuff: TKDT384DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT384DC_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT384DC_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT384DC_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT384DC_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT384DC.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  ID := KDT384DC_Axis;

  stream.write(st, 4);
  stream.write(ID, 4);

  stream.write(cnt, 8);

  i := 0;
  while i < cnt do
    begin
      stream.write(KDStoreBuff[i].buff[0], SizeOf(TKDT384DC_Vec));
      stream.write(KDStoreBuff[i].Index, 8);
      token_B := KDStoreBuff[i].Token.Bytes;
      token_L := length(token_B);
      stream.write(token_L, 4);
      if token_L > 0 then
        begin
          stream.write(token_B[0], token_L);
          SetLength(token_B, 0);
        end;
      Inc(i);
    end;
end;

procedure TKDT384DC.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  Clear;

  stream.read(st, 4);
  stream.read(ID, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if ID <> KDT384DC_Axis then
      RaiseInfo('kdtree axis error!');

  stream.read(cnt, 8);

  SetLength(KDStoreBuff, cnt);

  i := 0;
  try
    while i < cnt do
      begin
        if stream.read(KDStoreBuff[i].buff[0], SizeOf(TKDT384DC_Vec)) <> SizeOf(TKDT384DC_Vec) then
          begin
            Clear;
            Exit;
          end;
        if stream.read(KDStoreBuff[i].Index, 8) <> 8 then
          begin
            Clear;
            Exit;
          end;
        if stream.read(token_L, 4) <> 4 then
          begin
            Clear;
            Exit;
          end;
        if token_L > 0 then
          begin
            SetLength(token_B, token_L);
            if stream.read(token_B[0], token_L) <> token_L then
              begin
                Clear;
                Exit;
              end;
            KDStoreBuff[i].Token.Bytes := token_B;
            SetLength(token_B, 0);
          end
        else
            KDStoreBuff[i].Token := '';
        Inc(i);
      end;
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      Inc(i);
    end;

  if cnt > 0 then
      RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT384DC.SaveToFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(FileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT384DC.LoadFromFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT384DC.PrintNodeTree(const NodePtr: PKDT384DC_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT384DC_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.Vec^.Index, Vec(p^.Vec^.buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT384DC.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d - %d : %s ', [i, KDStoreBuff[i].Index, Vec(KDStoreBuff[i].buff)]);
end;

class function TKDT384DC.Vec(const s: SystemString): TKDT384DC_Vec;
var
  t: TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j: NativeInt;
begin
  for i := 0 to KDT384DC_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            Inc(j);
            if j >= KDT384DC_Axis then
                Break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT384DC.Vec(const v: TKDT384DC_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT384DC_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT384DC.Distance(const v1, v2: TKDT384DC_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT384DC_Axis - 1 do
      Result := Result + (v2[i] - v1[i]) * (v2[i] - v1[i]);
end;

procedure TKDT384DC.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT384DC_Source; const Data: Pointer);
begin
  Source.buff := TestBuff[IndexFor];
  Source.Token := umlIntToStr(IndexFor);
end;

class procedure TKDT384DC.Test;
var
  TKDT384DC_Test: TKDT384DC;
  t: TTimeTick;
  i, j: NativeInt;
  TestResultBuff: TKDT384DC_DynamicVecBuffer;
  TestResultIndex: TKMIntegerArray;
  KMeanOutIndex: TKMIntegerArray;
  errored: Boolean;
  m64: TMemoryStream64;
  p: PKDT384DC_Node;
  n: TPascalString;
begin
  errored := False;
  n := PFormat('test %s...', [ClassName]);
  t := GetTimeTick;

  n.Append('...build');
  TKDT384DC_Test := TKDT384DC.Create;

  n.Append('...');
  SetLength(TKDT384DC_Test.TestBuff, 1000);
  for i := 0 to length(TKDT384DC_Test.TestBuff) - 1 do
    for j := 0 to KDT384DC_Axis - 1 do
        TKDT384DC_Test.TestBuff[i][j] := i * KDT384DC_Axis + j;

{$IFDEF FPC}
  TKDT384DC_Test.BuildKDTreeM(length(TKDT384DC_Test.TestBuff), nil, @TKDT384DC_Test.Test_BuildM);
{$ELSE FPC}
  TKDT384DC_Test.BuildKDTreeM(length(TKDT384DC_Test.TestBuff), nil, TKDT384DC_Test.Test_BuildM);
{$ENDIF FPC}
  { save/load test }
  n.Append('...save/load');
  m64 := TMemoryStream64.CustomCreate(1024 * 1024);
  TKDT384DC_Test.SaveToStream(m64);
  m64.Position := 0;
  TKDT384DC_Test.LoadFromStream(m64);
  for i := 0 to length(TKDT384DC_Test.TestBuff) - 1 do
    begin
      p := TKDT384DC_Test.Search(TKDT384DC_Test.TestBuff[i]);
      if p^.Vec^.Index <> i then
          errored := True;
      if not p^.Vec^.Token.Same(umlIntToStr(i)) then
          errored := True;
      if errored then
          Break;
    end;
  DisposeObject(m64);

  if not errored then
    begin
      { parallel search test }
      n.Append('...parallel');
      SetLength(TestResultBuff, length(TKDT384DC_Test.TestBuff));
      SetLength(TestResultIndex, length(TKDT384DC_Test.TestBuff));
      TKDT384DC_Test.Search(TKDT384DC_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if Distance(TKDT384DC_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
            errored := True;
    end;

  if not errored then
    begin
      n.Append('...kMean');
      TKDT384DC_Test.Clear;
      { kMean test }
      TKDT384DC_Test.BuildKDTreeWithCluster(TKDT384DC_Test.TestBuff, 10, 1, KMeanOutIndex);
      { parallel search test }
      TKDT384DC_Test.Search(TKDT384DC_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if TestResultIndex[i] <> KMeanOutIndex[i] then
            errored := True;
    end;

  SetLength(TKDT384DC_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT384DC_Test.Clear;

  n.Append('...');
  if errored then
      n.Append('error!')
  else
      n.Append('passed ok %dms', [GetTimeTick - t]);
  DisposeObject(TKDT384DC_Test);
  DoStatus(n);
  n := '';
end;

function TKDT512DC.InternalBuildKdTree(const KDSourceBufferPtr: PKDT512DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT512DC_Node;
  function SortCompare(const p1, p2: PKDT512DC_Source; const axis: NativeInt): ShortInt;
  begin
    if p1^.buff[axis] = p2^.buff[axis] then
      begin
        if p1^.Index = p2^.Index then
            Result := 0
        else if p1^.Index < p2^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.buff[axis] < p2^.buff[axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT512DC_SourceBuffer; L, R: NativeInt; const axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT512DC_Source;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer^[(L + R) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, axis) < 0 do
            Inc(i);
        while SortCompare(SortBuffer^[j], p, axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, axis);
      L := i;
    until i >= R;
  end;

var
  M: NativeInt;
  axis: NativeInt;
  kdBuffPtr: PKDT512DC_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      new(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.Vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);
    end
  else
    begin
      axis := Depth mod KDT512DC_Axis;
      M := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr^[0], 0, PlanCount - 1, axis);

      new(Result);
      Result^.Parent := nil;
      Result^.Vec := kdBuffPtr^[M];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], M, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[M + 1], PlanCount - (M + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT512DC.GetData(const Index: NativeInt): PKDT512DC_Source;
begin
  Result := @KDStoreBuff[Index];
end;

constructor TKDT512DC.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT512DC.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT512DC.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT512DC_Node(KDNodes[i]));
      Inc(i);
    end;

  for i := 0 to length(KDStoreBuff) - 1 do
      KDStoreBuff[i].Token := '';

  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT512DC.StoreBuffPtr: PKDT512DC_DyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT512DC.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT512DC_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT512DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT512DC.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT512DC_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT512DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT512DC.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT512DC_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT512DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{ k-means++ clusterization }
procedure TKDT512DC.BuildKDTreeWithCluster(const inBuff: TKDT512DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  SetLength(Source, length(inBuff), KDT512DC_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT512DC_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT512DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT512DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT512DC.BuildKDTreeWithCluster(const inBuff: TKDT512DC_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TKMIntegerArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT512DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT512DC_BuildCall);
var
  TempStoreBuff: TKDT512DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT512DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT512DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT512DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT512DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT512DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT512DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT512DC_BuildMethod);
var
  TempStoreBuff: TKDT512DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT512DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT512DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT512DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT512DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT512DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT512DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT512DC_BuildProc);
var
  TempStoreBuff: TKDT512DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT512DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT512DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT512DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT512DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT512DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

function TKDT512DC.Search(const buff: TKDT512DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT512DC_Node;

var
  NearestNeighbour: PKDT512DC_Node;

  function FindParentNode(const buffPtr: PKDT512DC_Vec; NodePtr: PKDT512DC_Node): PKDT512DC_Node;
  var
    Next: PKDT512DC_Node;
    Depth, axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        axis := Depth mod KDT512DC_Axis;
        if buffPtr^[axis] > Next^.Vec^.buff[axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT512DC_Node; const buffPtr: PKDT512DC_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    Inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := Distance(buffPtr^, NodePtr^.Vec^.buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.Vec^.Index < NearestNeighbour^.Vec^.Index) then
        NearestNeighbour := NodePtr;

    axis := Depth mod KDT512DC_Axis;
    Dist := NodePtr^.Vec^.buff[axis] - buffPtr^[axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.Vec^.buff[axis] > buffPtr^[axis] then
            ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const buffPtr: PKDT512DC_Vec; const p1, p2: PKDT512DC_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := Distance(buffPtr^, p1^.Vec^.buff);
    d2 := Distance(buffPtr^, p2^.Vec^.buff);
    if d1 = d2 then
      begin
        if p1^.Vec^.Index = p2^.Vec^.Index then
            Result := 0
        else if p1^.Vec^.Index < p2^.Vec^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; L, R: NativeInt; const buffPtr: PKDT512DC_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT512DC_Node;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer[(L + R) shr 1];
      repeat
        while SortCompare(buffPtr, SortBuffer[i], p) < 0 do
            Inc(i);
        while SortCompare(buffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, buffPtr);
      L := i;
    until i >= R;
  end;

var
  Parent: PKDT512DC_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := Distance(buff, Parent^.Vec^.buff);

  ScanSubtree(RootNode, @buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT512DC_Node(NearestNodes[0]);
    end;
end;

function TKDT512DC.Search(const buff: TKDT512DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT512DC_Node;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT512DC.Search(const buff: TKDT512DC_Vec; var SearchedDistanceMin: Double): PKDT512DC_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT512DC.Search(const buff: TKDT512DC_Vec): PKDT512DC_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT512DC.SearchToken(const buff: TKDT512DC_Vec): TPascalString;
var
  p: PKDT512DC_Node;
begin
  p := Search(buff);
  if p <> nil then
      Result := p^.Vec^.Token
  else
      Result := '';
end;

procedure TKDT512DC.Search(const inBuff: TKDT512DC_DynamicVecBuffer; var OutBuff: TKDT512DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT512DC_DynamicVecBuffer;
  outBuffPtr: PKDT512DC_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT512DC_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outBuffPtr^[pass] := p^.Vec^.buff;
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT512DC_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outBuffPtr^[pass] := p^.Vec^.buff;
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT512DC_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.Vec^.buff;
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT512DC.Search(const inBuff: TKDT512DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT512DC_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT512DC_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT512DC_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT512DC_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT512DC.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  ID := KDT512DC_Axis;

  stream.write(st, 4);
  stream.write(ID, 4);

  stream.write(cnt, 8);

  i := 0;
  while i < cnt do
    begin
      stream.write(KDStoreBuff[i].buff[0], SizeOf(TKDT512DC_Vec));
      stream.write(KDStoreBuff[i].Index, 8);
      token_B := KDStoreBuff[i].Token.Bytes;
      token_L := length(token_B);
      stream.write(token_L, 4);
      if token_L > 0 then
        begin
          stream.write(token_B[0], token_L);
          SetLength(token_B, 0);
        end;
      Inc(i);
    end;
end;

procedure TKDT512DC.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  Clear;

  stream.read(st, 4);
  stream.read(ID, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if ID <> KDT512DC_Axis then
      RaiseInfo('kdtree axis error!');

  stream.read(cnt, 8);

  SetLength(KDStoreBuff, cnt);

  i := 0;
  try
    while i < cnt do
      begin
        if stream.read(KDStoreBuff[i].buff[0], SizeOf(TKDT512DC_Vec)) <> SizeOf(TKDT512DC_Vec) then
          begin
            Clear;
            Exit;
          end;
        if stream.read(KDStoreBuff[i].Index, 8) <> 8 then
          begin
            Clear;
            Exit;
          end;
        if stream.read(token_L, 4) <> 4 then
          begin
            Clear;
            Exit;
          end;
        if token_L > 0 then
          begin
            SetLength(token_B, token_L);
            if stream.read(token_B[0], token_L) <> token_L then
              begin
                Clear;
                Exit;
              end;
            KDStoreBuff[i].Token.Bytes := token_B;
            SetLength(token_B, 0);
          end
        else
            KDStoreBuff[i].Token := '';
        Inc(i);
      end;
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      Inc(i);
    end;

  if cnt > 0 then
      RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT512DC.SaveToFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(FileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT512DC.LoadFromFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT512DC.PrintNodeTree(const NodePtr: PKDT512DC_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT512DC_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.Vec^.Index, Vec(p^.Vec^.buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT512DC.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d - %d : %s ', [i, KDStoreBuff[i].Index, Vec(KDStoreBuff[i].buff)]);
end;

class function TKDT512DC.Vec(const s: SystemString): TKDT512DC_Vec;
var
  t: TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j: NativeInt;
begin
  for i := 0 to KDT512DC_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            Inc(j);
            if j >= KDT512DC_Axis then
                Break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT512DC.Vec(const v: TKDT512DC_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT512DC_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT512DC.Distance(const v1, v2: TKDT512DC_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT512DC_Axis - 1 do
      Result := Result + (v2[i] - v1[i]) * (v2[i] - v1[i]);
end;

procedure TKDT512DC.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT512DC_Source; const Data: Pointer);
begin
  Source.buff := TestBuff[IndexFor];
  Source.Token := umlIntToStr(IndexFor);
end;

class procedure TKDT512DC.Test;
var
  TKDT512DC_Test: TKDT512DC;
  t: TTimeTick;
  i, j: NativeInt;
  TestResultBuff: TKDT512DC_DynamicVecBuffer;
  TestResultIndex: TKMIntegerArray;
  KMeanOutIndex: TKMIntegerArray;
  errored: Boolean;
  m64: TMemoryStream64;
  p: PKDT512DC_Node;
  n: TPascalString;
begin
  errored := False;
  n := PFormat('test %s...', [ClassName]);
  t := GetTimeTick;

  n.Append('...build');
  TKDT512DC_Test := TKDT512DC.Create;

  n.Append('...');
  SetLength(TKDT512DC_Test.TestBuff, 1000);
  for i := 0 to length(TKDT512DC_Test.TestBuff) - 1 do
    for j := 0 to KDT512DC_Axis - 1 do
        TKDT512DC_Test.TestBuff[i][j] := i * KDT512DC_Axis + j;

{$IFDEF FPC}
  TKDT512DC_Test.BuildKDTreeM(length(TKDT512DC_Test.TestBuff), nil, @TKDT512DC_Test.Test_BuildM);
{$ELSE FPC}
  TKDT512DC_Test.BuildKDTreeM(length(TKDT512DC_Test.TestBuff), nil, TKDT512DC_Test.Test_BuildM);
{$ENDIF FPC}
  { save/load test }
  n.Append('...save/load');
  m64 := TMemoryStream64.CustomCreate(1024 * 1024);
  TKDT512DC_Test.SaveToStream(m64);
  m64.Position := 0;
  TKDT512DC_Test.LoadFromStream(m64);
  for i := 0 to length(TKDT512DC_Test.TestBuff) - 1 do
    begin
      p := TKDT512DC_Test.Search(TKDT512DC_Test.TestBuff[i]);
      if p^.Vec^.Index <> i then
          errored := True;
      if not p^.Vec^.Token.Same(umlIntToStr(i)) then
          errored := True;
      if errored then
          Break;
    end;
  DisposeObject(m64);

  if not errored then
    begin
      { parallel search test }
      n.Append('...parallel');
      SetLength(TestResultBuff, length(TKDT512DC_Test.TestBuff));
      SetLength(TestResultIndex, length(TKDT512DC_Test.TestBuff));
      TKDT512DC_Test.Search(TKDT512DC_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if Distance(TKDT512DC_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
            errored := True;
    end;

  if not errored then
    begin
      n.Append('...kMean');
      TKDT512DC_Test.Clear;
      { kMean test }
      TKDT512DC_Test.BuildKDTreeWithCluster(TKDT512DC_Test.TestBuff, 10, 1, KMeanOutIndex);
      { parallel search test }
      TKDT512DC_Test.Search(TKDT512DC_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if TestResultIndex[i] <> KMeanOutIndex[i] then
            errored := True;
    end;

  SetLength(TKDT512DC_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT512DC_Test.Clear;

  n.Append('...');
  if errored then
      n.Append('error!')
  else
      n.Append('passed ok %dms', [GetTimeTick - t]);
  DisposeObject(TKDT512DC_Test);
  DoStatus(n);
  n := '';
end;

function TKDT800DC.InternalBuildKdTree(const KDSourceBufferPtr: PKDT800DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT800DC_Node;
  function SortCompare(const p1, p2: PKDT800DC_Source; const axis: NativeInt): ShortInt;
  begin
    if p1^.buff[axis] = p2^.buff[axis] then
      begin
        if p1^.Index = p2^.Index then
            Result := 0
        else if p1^.Index < p2^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.buff[axis] < p2^.buff[axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT800DC_SourceBuffer; L, R: NativeInt; const axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT800DC_Source;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer^[(L + R) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, axis) < 0 do
            Inc(i);
        while SortCompare(SortBuffer^[j], p, axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, axis);
      L := i;
    until i >= R;
  end;

var
  M: NativeInt;
  axis: NativeInt;
  kdBuffPtr: PKDT800DC_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      new(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.Vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);
    end
  else
    begin
      axis := Depth mod KDT800DC_Axis;
      M := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr^[0], 0, PlanCount - 1, axis);

      new(Result);
      Result^.Parent := nil;
      Result^.Vec := kdBuffPtr^[M];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], M, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[M + 1], PlanCount - (M + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT800DC.GetData(const Index: NativeInt): PKDT800DC_Source;
begin
  Result := @KDStoreBuff[Index];
end;

constructor TKDT800DC.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT800DC.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT800DC.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT800DC_Node(KDNodes[i]));
      Inc(i);
    end;

  for i := 0 to length(KDStoreBuff) - 1 do
      KDStoreBuff[i].Token := '';

  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT800DC.StoreBuffPtr: PKDT800DC_DyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT800DC.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT800DC_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT800DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT800DC.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT800DC_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT800DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT800DC.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT800DC_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT800DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{ k-means++ clusterization }
procedure TKDT800DC.BuildKDTreeWithCluster(const inBuff: TKDT800DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  SetLength(Source, length(inBuff), KDT800DC_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT800DC_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT800DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT800DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT800DC.BuildKDTreeWithCluster(const inBuff: TKDT800DC_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TKMIntegerArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT800DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT800DC_BuildCall);
var
  TempStoreBuff: TKDT800DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT800DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT800DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT800DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT800DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT800DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT800DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT800DC_BuildMethod);
var
  TempStoreBuff: TKDT800DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT800DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT800DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT800DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT800DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT800DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT800DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT800DC_BuildProc);
var
  TempStoreBuff: TKDT800DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT800DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT800DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT800DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT800DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT800DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

function TKDT800DC.Search(const buff: TKDT800DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT800DC_Node;

var
  NearestNeighbour: PKDT800DC_Node;

  function FindParentNode(const buffPtr: PKDT800DC_Vec; NodePtr: PKDT800DC_Node): PKDT800DC_Node;
  var
    Next: PKDT800DC_Node;
    Depth, axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        axis := Depth mod KDT800DC_Axis;
        if buffPtr^[axis] > Next^.Vec^.buff[axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT800DC_Node; const buffPtr: PKDT800DC_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    Inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := Distance(buffPtr^, NodePtr^.Vec^.buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.Vec^.Index < NearestNeighbour^.Vec^.Index) then
        NearestNeighbour := NodePtr;

    axis := Depth mod KDT800DC_Axis;
    Dist := NodePtr^.Vec^.buff[axis] - buffPtr^[axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.Vec^.buff[axis] > buffPtr^[axis] then
            ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const buffPtr: PKDT800DC_Vec; const p1, p2: PKDT800DC_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := Distance(buffPtr^, p1^.Vec^.buff);
    d2 := Distance(buffPtr^, p2^.Vec^.buff);
    if d1 = d2 then
      begin
        if p1^.Vec^.Index = p2^.Vec^.Index then
            Result := 0
        else if p1^.Vec^.Index < p2^.Vec^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; L, R: NativeInt; const buffPtr: PKDT800DC_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT800DC_Node;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer[(L + R) shr 1];
      repeat
        while SortCompare(buffPtr, SortBuffer[i], p) < 0 do
            Inc(i);
        while SortCompare(buffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, buffPtr);
      L := i;
    until i >= R;
  end;

var
  Parent: PKDT800DC_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := Distance(buff, Parent^.Vec^.buff);

  ScanSubtree(RootNode, @buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT800DC_Node(NearestNodes[0]);
    end;
end;

function TKDT800DC.Search(const buff: TKDT800DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT800DC_Node;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT800DC.Search(const buff: TKDT800DC_Vec; var SearchedDistanceMin: Double): PKDT800DC_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT800DC.Search(const buff: TKDT800DC_Vec): PKDT800DC_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT800DC.SearchToken(const buff: TKDT800DC_Vec): TPascalString;
var
  p: PKDT800DC_Node;
begin
  p := Search(buff);
  if p <> nil then
      Result := p^.Vec^.Token
  else
      Result := '';
end;

procedure TKDT800DC.Search(const inBuff: TKDT800DC_DynamicVecBuffer; var OutBuff: TKDT800DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT800DC_DynamicVecBuffer;
  outBuffPtr: PKDT800DC_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT800DC_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outBuffPtr^[pass] := p^.Vec^.buff;
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT800DC_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outBuffPtr^[pass] := p^.Vec^.buff;
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT800DC_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.Vec^.buff;
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT800DC.Search(const inBuff: TKDT800DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT800DC_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT800DC_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT800DC_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT800DC_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT800DC.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  ID := KDT800DC_Axis;

  stream.write(st, 4);
  stream.write(ID, 4);

  stream.write(cnt, 8);

  i := 0;
  while i < cnt do
    begin
      stream.write(KDStoreBuff[i].buff[0], SizeOf(TKDT800DC_Vec));
      stream.write(KDStoreBuff[i].Index, 8);
      token_B := KDStoreBuff[i].Token.Bytes;
      token_L := length(token_B);
      stream.write(token_L, 4);
      if token_L > 0 then
        begin
          stream.write(token_B[0], token_L);
          SetLength(token_B, 0);
        end;
      Inc(i);
    end;
end;

procedure TKDT800DC.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  Clear;

  stream.read(st, 4);
  stream.read(ID, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if ID <> KDT800DC_Axis then
      RaiseInfo('kdtree axis error!');

  stream.read(cnt, 8);

  SetLength(KDStoreBuff, cnt);

  i := 0;
  try
    while i < cnt do
      begin
        if stream.read(KDStoreBuff[i].buff[0], SizeOf(TKDT800DC_Vec)) <> SizeOf(TKDT800DC_Vec) then
          begin
            Clear;
            Exit;
          end;
        if stream.read(KDStoreBuff[i].Index, 8) <> 8 then
          begin
            Clear;
            Exit;
          end;
        if stream.read(token_L, 4) <> 4 then
          begin
            Clear;
            Exit;
          end;
        if token_L > 0 then
          begin
            SetLength(token_B, token_L);
            if stream.read(token_B[0], token_L) <> token_L then
              begin
                Clear;
                Exit;
              end;
            KDStoreBuff[i].Token.Bytes := token_B;
            SetLength(token_B, 0);
          end
        else
            KDStoreBuff[i].Token := '';
        Inc(i);
      end;
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      Inc(i);
    end;

  if cnt > 0 then
      RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT800DC.SaveToFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(FileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT800DC.LoadFromFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT800DC.PrintNodeTree(const NodePtr: PKDT800DC_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT800DC_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.Vec^.Index, Vec(p^.Vec^.buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT800DC.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d - %d : %s ', [i, KDStoreBuff[i].Index, Vec(KDStoreBuff[i].buff)]);
end;

class function TKDT800DC.Vec(const s: SystemString): TKDT800DC_Vec;
var
  t: TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j: NativeInt;
begin
  for i := 0 to KDT800DC_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            Inc(j);
            if j >= KDT800DC_Axis then
                Break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT800DC.Vec(const v: TKDT800DC_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT800DC_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT800DC.Distance(const v1, v2: TKDT800DC_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT800DC_Axis - 1 do
      Result := Result + (v2[i] - v1[i]) * (v2[i] - v1[i]);
end;

procedure TKDT800DC.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT800DC_Source; const Data: Pointer);
begin
  Source.buff := TestBuff[IndexFor];
  Source.Token := umlIntToStr(IndexFor);
end;

class procedure TKDT800DC.Test;
var
  TKDT800DC_Test: TKDT800DC;
  t: TTimeTick;
  i, j: NativeInt;
  TestResultBuff: TKDT800DC_DynamicVecBuffer;
  TestResultIndex: TKMIntegerArray;
  KMeanOutIndex: TKMIntegerArray;
  errored: Boolean;
  m64: TMemoryStream64;
  p: PKDT800DC_Node;
  n: TPascalString;
begin
  errored := False;
  n := PFormat('test %s...', [ClassName]);
  t := GetTimeTick;

  n.Append('...build');
  TKDT800DC_Test := TKDT800DC.Create;

  n.Append('...');
  SetLength(TKDT800DC_Test.TestBuff, 1000);
  for i := 0 to length(TKDT800DC_Test.TestBuff) - 1 do
    for j := 0 to KDT800DC_Axis - 1 do
        TKDT800DC_Test.TestBuff[i][j] := i * KDT800DC_Axis + j;

{$IFDEF FPC}
  TKDT800DC_Test.BuildKDTreeM(length(TKDT800DC_Test.TestBuff), nil, @TKDT800DC_Test.Test_BuildM);
{$ELSE FPC}
  TKDT800DC_Test.BuildKDTreeM(length(TKDT800DC_Test.TestBuff), nil, TKDT800DC_Test.Test_BuildM);
{$ENDIF FPC}
  { save/load test }
  n.Append('...save/load');
  m64 := TMemoryStream64.CustomCreate(1024 * 1024);
  TKDT800DC_Test.SaveToStream(m64);
  m64.Position := 0;
  TKDT800DC_Test.LoadFromStream(m64);
  for i := 0 to length(TKDT800DC_Test.TestBuff) - 1 do
    begin
      p := TKDT800DC_Test.Search(TKDT800DC_Test.TestBuff[i]);
      if p^.Vec^.Index <> i then
          errored := True;
      if not p^.Vec^.Token.Same(umlIntToStr(i)) then
          errored := True;
      if errored then
          Break;
    end;
  DisposeObject(m64);

  if not errored then
    begin
      { parallel search test }
      n.Append('...parallel');
      SetLength(TestResultBuff, length(TKDT800DC_Test.TestBuff));
      SetLength(TestResultIndex, length(TKDT800DC_Test.TestBuff));
      TKDT800DC_Test.Search(TKDT800DC_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if Distance(TKDT800DC_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
            errored := True;
    end;

  if not errored then
    begin
      n.Append('...kMean');
      TKDT800DC_Test.Clear;
      { kMean test }
      TKDT800DC_Test.BuildKDTreeWithCluster(TKDT800DC_Test.TestBuff, 10, 1, KMeanOutIndex);
      { parallel search test }
      TKDT800DC_Test.Search(TKDT800DC_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if TestResultIndex[i] <> KMeanOutIndex[i] then
            errored := True;
    end;

  SetLength(TKDT800DC_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT800DC_Test.Clear;

  n.Append('...');
  if errored then
      n.Append('error!')
  else
      n.Append('passed ok %dms', [GetTimeTick - t]);
  DisposeObject(TKDT800DC_Test);
  DoStatus(n);
  n := '';
end;

function TKDT1024DC.InternalBuildKdTree(const KDSourceBufferPtr: PKDT1024DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1024DC_Node;
  function SortCompare(const p1, p2: PKDT1024DC_Source; const axis: NativeInt): ShortInt;
  begin
    if p1^.buff[axis] = p2^.buff[axis] then
      begin
        if p1^.Index = p2^.Index then
            Result := 0
        else if p1^.Index < p2^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.buff[axis] < p2^.buff[axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT1024DC_SourceBuffer; L, R: NativeInt; const axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT1024DC_Source;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer^[(L + R) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, axis) < 0 do
            Inc(i);
        while SortCompare(SortBuffer^[j], p, axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, axis);
      L := i;
    until i >= R;
  end;

var
  M: NativeInt;
  axis: NativeInt;
  kdBuffPtr: PKDT1024DC_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      new(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.Vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);
    end
  else
    begin
      axis := Depth mod KDT1024DC_Axis;
      M := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr^[0], 0, PlanCount - 1, axis);

      new(Result);
      Result^.Parent := nil;
      Result^.Vec := kdBuffPtr^[M];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], M, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[M + 1], PlanCount - (M + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT1024DC.GetData(const Index: NativeInt): PKDT1024DC_Source;
begin
  Result := @KDStoreBuff[Index];
end;

constructor TKDT1024DC.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT1024DC.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT1024DC.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT1024DC_Node(KDNodes[i]));
      Inc(i);
    end;

  for i := 0 to length(KDStoreBuff) - 1 do
      KDStoreBuff[i].Token := '';

  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT1024DC.StoreBuffPtr: PKDT1024DC_DyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT1024DC.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1024DC_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT1024DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT1024DC.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1024DC_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT1024DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT1024DC.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1024DC_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT1024DC_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{ k-means++ clusterization }
procedure TKDT1024DC.BuildKDTreeWithCluster(const inBuff: TKDT1024DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  SetLength(Source, length(inBuff), KDT1024DC_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT1024DC_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT1024DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT1024DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT1024DC.BuildKDTreeWithCluster(const inBuff: TKDT1024DC_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TKMIntegerArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT1024DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT1024DC_BuildCall);
var
  TempStoreBuff: TKDT1024DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT1024DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1024DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1024DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT1024DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT1024DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1024DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT1024DC_BuildMethod);
var
  TempStoreBuff: TKDT1024DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT1024DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1024DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1024DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT1024DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT1024DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1024DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT1024DC_BuildProc);
var
  TempStoreBuff: TKDT1024DC_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT1024DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1024DC_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1024DC_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT1024DC_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT1024DC_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

function TKDT1024DC.Search(const buff: TKDT1024DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1024DC_Node;

var
  NearestNeighbour: PKDT1024DC_Node;

  function FindParentNode(const buffPtr: PKDT1024DC_Vec; NodePtr: PKDT1024DC_Node): PKDT1024DC_Node;
  var
    Next: PKDT1024DC_Node;
    Depth, axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        axis := Depth mod KDT1024DC_Axis;
        if buffPtr^[axis] > Next^.Vec^.buff[axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT1024DC_Node; const buffPtr: PKDT1024DC_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    Inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := Distance(buffPtr^, NodePtr^.Vec^.buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.Vec^.Index < NearestNeighbour^.Vec^.Index) then
        NearestNeighbour := NodePtr;

    axis := Depth mod KDT1024DC_Axis;
    Dist := NodePtr^.Vec^.buff[axis] - buffPtr^[axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.Vec^.buff[axis] > buffPtr^[axis] then
            ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const buffPtr: PKDT1024DC_Vec; const p1, p2: PKDT1024DC_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := Distance(buffPtr^, p1^.Vec^.buff);
    d2 := Distance(buffPtr^, p2^.Vec^.buff);
    if d1 = d2 then
      begin
        if p1^.Vec^.Index = p2^.Vec^.Index then
            Result := 0
        else if p1^.Vec^.Index < p2^.Vec^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; L, R: NativeInt; const buffPtr: PKDT1024DC_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT1024DC_Node;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer[(L + R) shr 1];
      repeat
        while SortCompare(buffPtr, SortBuffer[i], p) < 0 do
            Inc(i);
        while SortCompare(buffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, buffPtr);
      L := i;
    until i >= R;
  end;

var
  Parent: PKDT1024DC_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := Distance(buff, Parent^.Vec^.buff);

  ScanSubtree(RootNode, @buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT1024DC_Node(NearestNodes[0]);
    end;
end;

function TKDT1024DC.Search(const buff: TKDT1024DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1024DC_Node;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT1024DC.Search(const buff: TKDT1024DC_Vec; var SearchedDistanceMin: Double): PKDT1024DC_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT1024DC.Search(const buff: TKDT1024DC_Vec): PKDT1024DC_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT1024DC.SearchToken(const buff: TKDT1024DC_Vec): TPascalString;
var
  p: PKDT1024DC_Node;
begin
  p := Search(buff);
  if p <> nil then
      Result := p^.Vec^.Token
  else
      Result := '';
end;

procedure TKDT1024DC.Search(const inBuff: TKDT1024DC_DynamicVecBuffer; var OutBuff: TKDT1024DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT1024DC_DynamicVecBuffer;
  outBuffPtr: PKDT1024DC_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT1024DC_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outBuffPtr^[pass] := p^.Vec^.buff;
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT1024DC_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outBuffPtr^[pass] := p^.Vec^.buff;
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1024DC_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.Vec^.buff;
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1024DC.Search(const inBuff: TKDT1024DC_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT1024DC_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT1024DC_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT1024DC_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1024DC_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1024DC.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  ID := KDT1024DC_Axis;

  stream.write(st, 4);
  stream.write(ID, 4);

  stream.write(cnt, 8);

  i := 0;
  while i < cnt do
    begin
      stream.write(KDStoreBuff[i].buff[0], SizeOf(TKDT1024DC_Vec));
      stream.write(KDStoreBuff[i].Index, 8);
      token_B := KDStoreBuff[i].Token.Bytes;
      token_L := length(token_B);
      stream.write(token_L, 4);
      if token_L > 0 then
        begin
          stream.write(token_B[0], token_L);
          SetLength(token_B, 0);
        end;
      Inc(i);
    end;
end;

procedure TKDT1024DC.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  Clear;

  stream.read(st, 4);
  stream.read(ID, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if ID <> KDT1024DC_Axis then
      RaiseInfo('kdtree axis error!');

  stream.read(cnt, 8);

  SetLength(KDStoreBuff, cnt);

  i := 0;
  try
    while i < cnt do
      begin
        if stream.read(KDStoreBuff[i].buff[0], SizeOf(TKDT1024DC_Vec)) <> SizeOf(TKDT1024DC_Vec) then
          begin
            Clear;
            Exit;
          end;
        if stream.read(KDStoreBuff[i].Index, 8) <> 8 then
          begin
            Clear;
            Exit;
          end;
        if stream.read(token_L, 4) <> 4 then
          begin
            Clear;
            Exit;
          end;
        if token_L > 0 then
          begin
            SetLength(token_B, token_L);
            if stream.read(token_B[0], token_L) <> token_L then
              begin
                Clear;
                Exit;
              end;
            KDStoreBuff[i].Token.Bytes := token_B;
            SetLength(token_B, 0);
          end
        else
            KDStoreBuff[i].Token := '';
        Inc(i);
      end;
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      Inc(i);
    end;

  if cnt > 0 then
      RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT1024DC.SaveToFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(FileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1024DC.LoadFromFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1024DC.PrintNodeTree(const NodePtr: PKDT1024DC_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT1024DC_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.Vec^.Index, Vec(p^.Vec^.buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT1024DC.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d - %d : %s ', [i, KDStoreBuff[i].Index, Vec(KDStoreBuff[i].buff)]);
end;

class function TKDT1024DC.Vec(const s: SystemString): TKDT1024DC_Vec;
var
  t: TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j: NativeInt;
begin
  for i := 0 to KDT1024DC_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            Inc(j);
            if j >= KDT1024DC_Axis then
                Break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT1024DC.Vec(const v: TKDT1024DC_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT1024DC_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT1024DC.Distance(const v1, v2: TKDT1024DC_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT1024DC_Axis - 1 do
      Result := Result + (v2[i] - v1[i]) * (v2[i] - v1[i]);
end;

procedure TKDT1024DC.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT1024DC_Source; const Data: Pointer);
begin
  Source.buff := TestBuff[IndexFor];
  Source.Token := umlIntToStr(IndexFor);
end;

class procedure TKDT1024DC.Test;
var
  TKDT1024DC_Test: TKDT1024DC;
  t: TTimeTick;
  i, j: NativeInt;
  TestResultBuff: TKDT1024DC_DynamicVecBuffer;
  TestResultIndex: TKMIntegerArray;
  KMeanOutIndex: TKMIntegerArray;
  errored: Boolean;
  m64: TMemoryStream64;
  p: PKDT1024DC_Node;
  n: TPascalString;
begin
  errored := False;
  n := PFormat('test %s...', [ClassName]);
  t := GetTimeTick;

  n.Append('...build');
  TKDT1024DC_Test := TKDT1024DC.Create;

  n.Append('...');
  SetLength(TKDT1024DC_Test.TestBuff, 1000);
  for i := 0 to length(TKDT1024DC_Test.TestBuff) - 1 do
    for j := 0 to KDT1024DC_Axis - 1 do
        TKDT1024DC_Test.TestBuff[i][j] := i * KDT1024DC_Axis + j;

{$IFDEF FPC}
  TKDT1024DC_Test.BuildKDTreeM(length(TKDT1024DC_Test.TestBuff), nil, @TKDT1024DC_Test.Test_BuildM);
{$ELSE FPC}
  TKDT1024DC_Test.BuildKDTreeM(length(TKDT1024DC_Test.TestBuff), nil, TKDT1024DC_Test.Test_BuildM);
{$ENDIF FPC}
  { save/load test }
  n.Append('...save/load');
  m64 := TMemoryStream64.CustomCreate(1024 * 1024);
  TKDT1024DC_Test.SaveToStream(m64);
  m64.Position := 0;
  TKDT1024DC_Test.LoadFromStream(m64);
  for i := 0 to length(TKDT1024DC_Test.TestBuff) - 1 do
    begin
      p := TKDT1024DC_Test.Search(TKDT1024DC_Test.TestBuff[i]);
      if p^.Vec^.Index <> i then
          errored := True;
      if not p^.Vec^.Token.Same(umlIntToStr(i)) then
          errored := True;
      if errored then
          Break;
    end;
  DisposeObject(m64);

  if not errored then
    begin
      { parallel search test }
      n.Append('...parallel');
      SetLength(TestResultBuff, length(TKDT1024DC_Test.TestBuff));
      SetLength(TestResultIndex, length(TKDT1024DC_Test.TestBuff));
      TKDT1024DC_Test.Search(TKDT1024DC_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if Distance(TKDT1024DC_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
            errored := True;
    end;

  if not errored then
    begin
      n.Append('...kMean');
      TKDT1024DC_Test.Clear;
      { kMean test }
      TKDT1024DC_Test.BuildKDTreeWithCluster(TKDT1024DC_Test.TestBuff, 10, 1, KMeanOutIndex);
      { parallel search test }
      TKDT1024DC_Test.Search(TKDT1024DC_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if TestResultIndex[i] <> KMeanOutIndex[i] then
            errored := True;
    end;

  SetLength(TKDT1024DC_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT1024DC_Test.Clear;

  n.Append('...');
  if errored then
      n.Append('error!')
  else
      n.Append('passed ok %dms', [GetTimeTick - t]);
  DisposeObject(TKDT1024DC_Test);
  DoStatus(n);
  n := '';
end;


procedure Test_All;
begin
  TKDT1DC.Test();
  TKDT2DC.Test();
  TKDT3DC.Test();
  TKDT4DC.Test();
  TKDT5DC.Test();
  TKDT6DC.Test();
  TKDT7DC.Test();
  TKDT8DC.Test();
  TKDT9DC.Test();
  TKDT10DC.Test();
  TKDT11DC.Test();
  TKDT12DC.Test();
  TKDT13DC.Test();
  TKDT14DC.Test();
  TKDT15DC.Test();
  TKDT16DC.Test();
  TKDT17DC.Test();
  TKDT18DC.Test();
  TKDT19DC.Test();
  TKDT20DC.Test();
  TKDT21DC.Test();
  TKDT22DC.Test();
  TKDT23DC.Test();
  TKDT24DC.Test();
  TKDT48DC.Test();
  TKDT52DC.Test();
  TKDT64DC.Test();
  TKDT96DC.Test();
  TKDT128DC.Test();
  TKDT156DC.Test();
  TKDT192DC.Test();
  TKDT256DC.Test();
  TKDT384DC.Test();
  TKDT512DC.Test();
  TKDT800DC.Test();
  TKDT1024DC.Test();
end;





initialization

finalization

end.


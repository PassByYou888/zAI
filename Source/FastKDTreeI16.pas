{ ****************************************************************************** }
{ Fast KDTree SmallInt type support                                              }
{ ****************************************************************************** }
{ * https://zpascal.net                                                        * }
{ * https://github.com/PassByYou888/zAI                                        * }
{ * https://github.com/PassByYou888/ZServer4D                                  * }
{ * https://github.com/PassByYou888/PascalString                               * }
{ * https://github.com/PassByYou888/zRasterization                             * }
{ * https://github.com/PassByYou888/CoreCipher                                 * }
{ * https://github.com/PassByYou888/zSound                                     * }
{ * https://github.com/PassByYou888/zChinese                                   * }
{ * https://github.com/PassByYou888/zExpression                                * }
{ * https://github.com/PassByYou888/zGameWare                                  * }
{ * https://github.com/PassByYou888/zAnalysis                                  * }
{ * https://github.com/PassByYou888/FFMPEG-Header                              * }
{ * https://github.com/PassByYou888/zTranslate                                 * }
{ * https://github.com/PassByYou888/InfiniteIoT                                * }
{ * https://github.com/PassByYou888/FastMD5                                    * }
{ ****************************************************************************** }

unit FastKDTreeI16;

{$INCLUDE zDefine.inc}

interface

uses CoreClasses, PascalStrings, UnicodeMixedLib, KM;

const

  // SmallInt KDTree
  KDT1DI16_Axis = 1;
  KDT2DI16_Axis = 2;
  KDT3DI16_Axis = 3;
  KDT4DI16_Axis = 4;
  KDT5DI16_Axis = 5;
  KDT6DI16_Axis = 6;
  KDT7DI16_Axis = 7;
  KDT8DI16_Axis = 8;
  KDT9DI16_Axis = 9;
  KDT10DI16_Axis = 10;
  KDT11DI16_Axis = 11;
  KDT12DI16_Axis = 12;
  KDT13DI16_Axis = 13;
  KDT14DI16_Axis = 14;
  KDT15DI16_Axis = 15;
  KDT16DI16_Axis = 16;
  KDT17DI16_Axis = 17;
  KDT18DI16_Axis = 18;
  KDT19DI16_Axis = 19;
  KDT20DI16_Axis = 20;
  KDT21DI16_Axis = 21;
  KDT22DI16_Axis = 22;
  KDT23DI16_Axis = 23;
  KDT24DI16_Axis = 24;
  KDT48DI16_Axis = 48;
  KDT52DI16_Axis = 52;
  KDT64DI16_Axis = 64;
  KDT96DI16_Axis = 96;
  KDT128DI16_Axis = 128;
  KDT156DI16_Axis = 156;
  KDT192DI16_Axis = 192;
  KDT256DI16_Axis = 256;
  KDT384DI16_Axis = 384;
  KDT512DI16_Axis = 512;
  KDT800DI16_Axis = 800;
  KDT1024DI16_Axis = 1024;

type

  // SmallInt: KDTree
  TKDT1DI16 = class;  TKDT1DI16_VecType = KM.TKMFloat; // 1D
  TKDT2DI16 = class;  TKDT2DI16_VecType = KM.TKMFloat; // 2D
  TKDT3DI16 = class;  TKDT3DI16_VecType = KM.TKMFloat; // 3D
  TKDT4DI16 = class;  TKDT4DI16_VecType = KM.TKMFloat; // 4D
  TKDT5DI16 = class;  TKDT5DI16_VecType = KM.TKMFloat; // 5D
  TKDT6DI16 = class;  TKDT6DI16_VecType = KM.TKMFloat; // 6D
  TKDT7DI16 = class;  TKDT7DI16_VecType = KM.TKMFloat; // 7D
  TKDT8DI16 = class;  TKDT8DI16_VecType = KM.TKMFloat; // 8D
  TKDT9DI16 = class;  TKDT9DI16_VecType = KM.TKMFloat; // 9D
  TKDT10DI16 = class;  TKDT10DI16_VecType = KM.TKMFloat; // 10D
  TKDT11DI16 = class;  TKDT11DI16_VecType = KM.TKMFloat; // 11D
  TKDT12DI16 = class;  TKDT12DI16_VecType = KM.TKMFloat; // 12D
  TKDT13DI16 = class;  TKDT13DI16_VecType = KM.TKMFloat; // 13D
  TKDT14DI16 = class;  TKDT14DI16_VecType = KM.TKMFloat; // 14D
  TKDT15DI16 = class;  TKDT15DI16_VecType = KM.TKMFloat; // 15D
  TKDT16DI16 = class;  TKDT16DI16_VecType = KM.TKMFloat; // 16D
  TKDT17DI16 = class;  TKDT17DI16_VecType = KM.TKMFloat; // 17D
  TKDT18DI16 = class;  TKDT18DI16_VecType = KM.TKMFloat; // 18D
  TKDT19DI16 = class;  TKDT19DI16_VecType = KM.TKMFloat; // 19D
  TKDT20DI16 = class;  TKDT20DI16_VecType = KM.TKMFloat; // 20D
  TKDT21DI16 = class;  TKDT21DI16_VecType = KM.TKMFloat; // 21D
  TKDT22DI16 = class;  TKDT22DI16_VecType = KM.TKMFloat; // 22D
  TKDT23DI16 = class;  TKDT23DI16_VecType = KM.TKMFloat; // 23D
  TKDT24DI16 = class;  TKDT24DI16_VecType = KM.TKMFloat; // 24D
  TKDT48DI16 = class;  TKDT48DI16_VecType = KM.TKMFloat; // 48D
  TKDT52DI16 = class;  TKDT52DI16_VecType = KM.TKMFloat; // 52D
  TKDT64DI16 = class;  TKDT64DI16_VecType = KM.TKMFloat; // 64D
  TKDT96DI16 = class;  TKDT96DI16_VecType = KM.TKMFloat; // 96D
  TKDT128DI16 = class;  TKDT128DI16_VecType = KM.TKMFloat; // 128D
  TKDT156DI16 = class;  TKDT156DI16_VecType = KM.TKMFloat; // 156D
  TKDT192DI16 = class;  TKDT192DI16_VecType = KM.TKMFloat; // 192D
  TKDT256DI16 = class;  TKDT256DI16_VecType = KM.TKMFloat; // 256D
  TKDT384DI16 = class;  TKDT384DI16_VecType = KM.TKMFloat; // 384D
  TKDT512DI16 = class;  TKDT512DI16_VecType = KM.TKMFloat; // 512D
  TKDT800DI16 = class;  TKDT800DI16_VecType = KM.TKMFloat; // 800D
  TKDT1024DI16 = class;  TKDT1024DI16_VecType = KM.TKMFloat; // 1024D










  // SmallInt KDTree


  TKDT1DI16 = class(TCoreClassObject)
  public type
    // code split
    TKDT1DI16_Vec = array [0 .. KDT1DI16_Axis - 1] of TKDT1DI16_VecType;
    PKDT1DI16_Vec = ^TKDT1DI16_Vec;

    TKDT1DI16_DynamicVecBuffer = array of TKDT1DI16_Vec;
    PKDT1DI16_DynamicVecBuffer = ^TKDT1DI16_DynamicVecBuffer;

    TKDT1DI16_Source = record
      buff: TKDT1DI16_Vec;
      Index: Int64;
      Token: TPascalString;
    end;

    PKDT1DI16_Source = ^TKDT1DI16_Source;
    TKDT1DI16_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT1DI16_Source) - 1] of PKDT1DI16_Source;
    PKDT1DI16_SourceBuffer = ^TKDT1DI16_SourceBuffer;

    TKDT1DI16_DyanmicSourceBuffer = array of PKDT1DI16_Source;
    PKDT1DI16_DyanmicSourceBuffer = ^TKDT1DI16_DyanmicSourceBuffer;

    TKDT1DI16_DyanmicStoreBuffer = array of TKDT1DI16_Source;
    PKDT1DI16_DyanmicStoreBuffer = ^TKDT1DI16_DyanmicStoreBuffer;

    PKDT1DI16_Node = ^TKDT1DI16_Node;

    TKDT1DI16_Node = record
      Parent, Right, Left: PKDT1DI16_Node;
      Vec: PKDT1DI16_Source;
    end;

    TKDT1DI16_BuildCall = procedure(const IndexFor: NativeInt; var Source: TKDT1DI16_Source; const Data: Pointer);
    TKDT1DI16_BuildMethod = procedure(const IndexFor: NativeInt; var Source: TKDT1DI16_Source; const Data: Pointer) of object;
{$IFDEF FPC}
    TKDT1DI16_BuildProc = procedure(const IndexFor: NativeInt; var Source: TKDT1DI16_Source; const Data: Pointer) is nested;
{$ELSE FPC}
    TKDT1DI16_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT1DI16_Source; const Data: Pointer);
{$ENDIF FPC}
  private
    KDStoreBuff: TKDT1DI16_DyanmicStoreBuffer;
    KDBuff: TKDT1DI16_DyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes: array of PKDT1DI16_Node;
    TestBuff: TKDT1DI16_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT1DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1DI16_Node;
    function GetData(const Index: NativeInt): PKDT1DI16_Source;
  public
    RootNode: PKDT1DI16_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT1DI16_DyanmicStoreBuffer;
    property SourceP[const Index: NativeInt]: PKDT1DI16_Source read GetData; default;

    { bakcall build }
    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1DI16_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1DI16_BuildMethod);
    procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1DI16_BuildProc);
    { fill k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1DI16_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT1DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT1DI16_BuildMethod); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT1DI16_BuildProc); overload;
    { search }
    function Search(const buff: TKDT1DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1DI16_Node; overload;
    function Search(const buff: TKDT1DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1DI16_Node; overload;
    function Search(const buff: TKDT1DI16_Vec; var SearchedDistanceMin: Double): PKDT1DI16_Node; overload;
    function Search(const buff: TKDT1DI16_Vec): PKDT1DI16_Node; overload;
    function SearchToken(const buff: TKDT1DI16_Vec): TPascalString;
    { parallel search }
    procedure Search(const inBuff: TKDT1DI16_DynamicVecBuffer; var OutBuff: TKDT1DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;
    procedure Search(const inBuff: TKDT1DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);
    procedure SaveToFile(FileName: SystemString);
    procedure LoadFromFile(FileName: SystemString);
    procedure PrintNodeTree(const NodePtr: PKDT1DI16_Node);
    procedure PrintBuffer;
    class function Vec(const s: SystemString): TKDT1DI16_Vec; overload;
    class function Vec(const v: TKDT1DI16_Vec): SystemString; overload;
    class function Distance(const v1, v2: TKDT1DI16_Vec): Double;
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT1DI16_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT2DI16 = class(TCoreClassObject)
  public type
    // code split
    TKDT2DI16_Vec = array [0 .. KDT2DI16_Axis - 1] of TKDT2DI16_VecType;
    PKDT2DI16_Vec = ^TKDT2DI16_Vec;

    TKDT2DI16_DynamicVecBuffer = array of TKDT2DI16_Vec;
    PKDT2DI16_DynamicVecBuffer = ^TKDT2DI16_DynamicVecBuffer;

    TKDT2DI16_Source = record
      buff: TKDT2DI16_Vec;
      Index: Int64;
      Token: TPascalString;
    end;

    PKDT2DI16_Source = ^TKDT2DI16_Source;
    TKDT2DI16_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT2DI16_Source) - 1] of PKDT2DI16_Source;
    PKDT2DI16_SourceBuffer = ^TKDT2DI16_SourceBuffer;

    TKDT2DI16_DyanmicSourceBuffer = array of PKDT2DI16_Source;
    PKDT2DI16_DyanmicSourceBuffer = ^TKDT2DI16_DyanmicSourceBuffer;

    TKDT2DI16_DyanmicStoreBuffer = array of TKDT2DI16_Source;
    PKDT2DI16_DyanmicStoreBuffer = ^TKDT2DI16_DyanmicStoreBuffer;

    PKDT2DI16_Node = ^TKDT2DI16_Node;

    TKDT2DI16_Node = record
      Parent, Right, Left: PKDT2DI16_Node;
      Vec: PKDT2DI16_Source;
    end;

    TKDT2DI16_BuildCall = procedure(const IndexFor: NativeInt; var Source: TKDT2DI16_Source; const Data: Pointer);
    TKDT2DI16_BuildMethod = procedure(const IndexFor: NativeInt; var Source: TKDT2DI16_Source; const Data: Pointer) of object;
{$IFDEF FPC}
    TKDT2DI16_BuildProc = procedure(const IndexFor: NativeInt; var Source: TKDT2DI16_Source; const Data: Pointer) is nested;
{$ELSE FPC}
    TKDT2DI16_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT2DI16_Source; const Data: Pointer);
{$ENDIF FPC}
  private
    KDStoreBuff: TKDT2DI16_DyanmicStoreBuffer;
    KDBuff: TKDT2DI16_DyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes: array of PKDT2DI16_Node;
    TestBuff: TKDT2DI16_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT2DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT2DI16_Node;
    function GetData(const Index: NativeInt): PKDT2DI16_Source;
  public
    RootNode: PKDT2DI16_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT2DI16_DyanmicStoreBuffer;
    property SourceP[const Index: NativeInt]: PKDT2DI16_Source read GetData; default;

    { bakcall build }
    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT2DI16_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT2DI16_BuildMethod);
    procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT2DI16_BuildProc);
    { fill k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT2DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT2DI16_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT2DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT2DI16_BuildMethod); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT2DI16_BuildProc); overload;
    { search }
    function Search(const buff: TKDT2DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT2DI16_Node; overload;
    function Search(const buff: TKDT2DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT2DI16_Node; overload;
    function Search(const buff: TKDT2DI16_Vec; var SearchedDistanceMin: Double): PKDT2DI16_Node; overload;
    function Search(const buff: TKDT2DI16_Vec): PKDT2DI16_Node; overload;
    function SearchToken(const buff: TKDT2DI16_Vec): TPascalString;
    { parallel search }
    procedure Search(const inBuff: TKDT2DI16_DynamicVecBuffer; var OutBuff: TKDT2DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;
    procedure Search(const inBuff: TKDT2DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);
    procedure SaveToFile(FileName: SystemString);
    procedure LoadFromFile(FileName: SystemString);
    procedure PrintNodeTree(const NodePtr: PKDT2DI16_Node);
    procedure PrintBuffer;
    class function Vec(const s: SystemString): TKDT2DI16_Vec; overload;
    class function Vec(const v: TKDT2DI16_Vec): SystemString; overload;
    class function Distance(const v1, v2: TKDT2DI16_Vec): Double;
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT2DI16_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT3DI16 = class(TCoreClassObject)
  public type
    // code split
    TKDT3DI16_Vec = array [0 .. KDT3DI16_Axis - 1] of TKDT3DI16_VecType;
    PKDT3DI16_Vec = ^TKDT3DI16_Vec;

    TKDT3DI16_DynamicVecBuffer = array of TKDT3DI16_Vec;
    PKDT3DI16_DynamicVecBuffer = ^TKDT3DI16_DynamicVecBuffer;

    TKDT3DI16_Source = record
      buff: TKDT3DI16_Vec;
      Index: Int64;
      Token: TPascalString;
    end;

    PKDT3DI16_Source = ^TKDT3DI16_Source;
    TKDT3DI16_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT3DI16_Source) - 1] of PKDT3DI16_Source;
    PKDT3DI16_SourceBuffer = ^TKDT3DI16_SourceBuffer;

    TKDT3DI16_DyanmicSourceBuffer = array of PKDT3DI16_Source;
    PKDT3DI16_DyanmicSourceBuffer = ^TKDT3DI16_DyanmicSourceBuffer;

    TKDT3DI16_DyanmicStoreBuffer = array of TKDT3DI16_Source;
    PKDT3DI16_DyanmicStoreBuffer = ^TKDT3DI16_DyanmicStoreBuffer;

    PKDT3DI16_Node = ^TKDT3DI16_Node;

    TKDT3DI16_Node = record
      Parent, Right, Left: PKDT3DI16_Node;
      Vec: PKDT3DI16_Source;
    end;

    TKDT3DI16_BuildCall = procedure(const IndexFor: NativeInt; var Source: TKDT3DI16_Source; const Data: Pointer);
    TKDT3DI16_BuildMethod = procedure(const IndexFor: NativeInt; var Source: TKDT3DI16_Source; const Data: Pointer) of object;
{$IFDEF FPC}
    TKDT3DI16_BuildProc = procedure(const IndexFor: NativeInt; var Source: TKDT3DI16_Source; const Data: Pointer) is nested;
{$ELSE FPC}
    TKDT3DI16_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT3DI16_Source; const Data: Pointer);
{$ENDIF FPC}
  private
    KDStoreBuff: TKDT3DI16_DyanmicStoreBuffer;
    KDBuff: TKDT3DI16_DyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes: array of PKDT3DI16_Node;
    TestBuff: TKDT3DI16_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT3DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT3DI16_Node;
    function GetData(const Index: NativeInt): PKDT3DI16_Source;
  public
    RootNode: PKDT3DI16_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT3DI16_DyanmicStoreBuffer;
    property SourceP[const Index: NativeInt]: PKDT3DI16_Source read GetData; default;

    { bakcall build }
    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3DI16_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3DI16_BuildMethod);
    procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3DI16_BuildProc);
    { fill k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT3DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT3DI16_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT3DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT3DI16_BuildMethod); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT3DI16_BuildProc); overload;
    { search }
    function Search(const buff: TKDT3DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT3DI16_Node; overload;
    function Search(const buff: TKDT3DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT3DI16_Node; overload;
    function Search(const buff: TKDT3DI16_Vec; var SearchedDistanceMin: Double): PKDT3DI16_Node; overload;
    function Search(const buff: TKDT3DI16_Vec): PKDT3DI16_Node; overload;
    function SearchToken(const buff: TKDT3DI16_Vec): TPascalString;
    { parallel search }
    procedure Search(const inBuff: TKDT3DI16_DynamicVecBuffer; var OutBuff: TKDT3DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;
    procedure Search(const inBuff: TKDT3DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);
    procedure SaveToFile(FileName: SystemString);
    procedure LoadFromFile(FileName: SystemString);
    procedure PrintNodeTree(const NodePtr: PKDT3DI16_Node);
    procedure PrintBuffer;
    class function Vec(const s: SystemString): TKDT3DI16_Vec; overload;
    class function Vec(const v: TKDT3DI16_Vec): SystemString; overload;
    class function Distance(const v1, v2: TKDT3DI16_Vec): Double;
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT3DI16_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT4DI16 = class(TCoreClassObject)
  public type
    // code split
    TKDT4DI16_Vec = array [0 .. KDT4DI16_Axis - 1] of TKDT4DI16_VecType;
    PKDT4DI16_Vec = ^TKDT4DI16_Vec;

    TKDT4DI16_DynamicVecBuffer = array of TKDT4DI16_Vec;
    PKDT4DI16_DynamicVecBuffer = ^TKDT4DI16_DynamicVecBuffer;

    TKDT4DI16_Source = record
      buff: TKDT4DI16_Vec;
      Index: Int64;
      Token: TPascalString;
    end;

    PKDT4DI16_Source = ^TKDT4DI16_Source;
    TKDT4DI16_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT4DI16_Source) - 1] of PKDT4DI16_Source;
    PKDT4DI16_SourceBuffer = ^TKDT4DI16_SourceBuffer;

    TKDT4DI16_DyanmicSourceBuffer = array of PKDT4DI16_Source;
    PKDT4DI16_DyanmicSourceBuffer = ^TKDT4DI16_DyanmicSourceBuffer;

    TKDT4DI16_DyanmicStoreBuffer = array of TKDT4DI16_Source;
    PKDT4DI16_DyanmicStoreBuffer = ^TKDT4DI16_DyanmicStoreBuffer;

    PKDT4DI16_Node = ^TKDT4DI16_Node;

    TKDT4DI16_Node = record
      Parent, Right, Left: PKDT4DI16_Node;
      Vec: PKDT4DI16_Source;
    end;

    TKDT4DI16_BuildCall = procedure(const IndexFor: NativeInt; var Source: TKDT4DI16_Source; const Data: Pointer);
    TKDT4DI16_BuildMethod = procedure(const IndexFor: NativeInt; var Source: TKDT4DI16_Source; const Data: Pointer) of object;
{$IFDEF FPC}
    TKDT4DI16_BuildProc = procedure(const IndexFor: NativeInt; var Source: TKDT4DI16_Source; const Data: Pointer) is nested;
{$ELSE FPC}
    TKDT4DI16_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT4DI16_Source; const Data: Pointer);
{$ENDIF FPC}
  private
    KDStoreBuff: TKDT4DI16_DyanmicStoreBuffer;
    KDBuff: TKDT4DI16_DyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes: array of PKDT4DI16_Node;
    TestBuff: TKDT4DI16_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT4DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT4DI16_Node;
    function GetData(const Index: NativeInt): PKDT4DI16_Source;
  public
    RootNode: PKDT4DI16_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT4DI16_DyanmicStoreBuffer;
    property SourceP[const Index: NativeInt]: PKDT4DI16_Source read GetData; default;

    { bakcall build }
    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT4DI16_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT4DI16_BuildMethod);
    procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT4DI16_BuildProc);
    { fill k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT4DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT4DI16_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT4DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT4DI16_BuildMethod); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT4DI16_BuildProc); overload;
    { search }
    function Search(const buff: TKDT4DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT4DI16_Node; overload;
    function Search(const buff: TKDT4DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT4DI16_Node; overload;
    function Search(const buff: TKDT4DI16_Vec; var SearchedDistanceMin: Double): PKDT4DI16_Node; overload;
    function Search(const buff: TKDT4DI16_Vec): PKDT4DI16_Node; overload;
    function SearchToken(const buff: TKDT4DI16_Vec): TPascalString;
    { parallel search }
    procedure Search(const inBuff: TKDT4DI16_DynamicVecBuffer; var OutBuff: TKDT4DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;
    procedure Search(const inBuff: TKDT4DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);
    procedure SaveToFile(FileName: SystemString);
    procedure LoadFromFile(FileName: SystemString);
    procedure PrintNodeTree(const NodePtr: PKDT4DI16_Node);
    procedure PrintBuffer;
    class function Vec(const s: SystemString): TKDT4DI16_Vec; overload;
    class function Vec(const v: TKDT4DI16_Vec): SystemString; overload;
    class function Distance(const v1, v2: TKDT4DI16_Vec): Double;
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT4DI16_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT5DI16 = class(TCoreClassObject)
  public type
    // code split
    TKDT5DI16_Vec = array [0 .. KDT5DI16_Axis - 1] of TKDT5DI16_VecType;
    PKDT5DI16_Vec = ^TKDT5DI16_Vec;

    TKDT5DI16_DynamicVecBuffer = array of TKDT5DI16_Vec;
    PKDT5DI16_DynamicVecBuffer = ^TKDT5DI16_DynamicVecBuffer;

    TKDT5DI16_Source = record
      buff: TKDT5DI16_Vec;
      Index: Int64;
      Token: TPascalString;
    end;

    PKDT5DI16_Source = ^TKDT5DI16_Source;
    TKDT5DI16_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT5DI16_Source) - 1] of PKDT5DI16_Source;
    PKDT5DI16_SourceBuffer = ^TKDT5DI16_SourceBuffer;

    TKDT5DI16_DyanmicSourceBuffer = array of PKDT5DI16_Source;
    PKDT5DI16_DyanmicSourceBuffer = ^TKDT5DI16_DyanmicSourceBuffer;

    TKDT5DI16_DyanmicStoreBuffer = array of TKDT5DI16_Source;
    PKDT5DI16_DyanmicStoreBuffer = ^TKDT5DI16_DyanmicStoreBuffer;

    PKDT5DI16_Node = ^TKDT5DI16_Node;

    TKDT5DI16_Node = record
      Parent, Right, Left: PKDT5DI16_Node;
      Vec: PKDT5DI16_Source;
    end;

    TKDT5DI16_BuildCall = procedure(const IndexFor: NativeInt; var Source: TKDT5DI16_Source; const Data: Pointer);
    TKDT5DI16_BuildMethod = procedure(const IndexFor: NativeInt; var Source: TKDT5DI16_Source; const Data: Pointer) of object;
{$IFDEF FPC}
    TKDT5DI16_BuildProc = procedure(const IndexFor: NativeInt; var Source: TKDT5DI16_Source; const Data: Pointer) is nested;
{$ELSE FPC}
    TKDT5DI16_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT5DI16_Source; const Data: Pointer);
{$ENDIF FPC}
  private
    KDStoreBuff: TKDT5DI16_DyanmicStoreBuffer;
    KDBuff: TKDT5DI16_DyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes: array of PKDT5DI16_Node;
    TestBuff: TKDT5DI16_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT5DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT5DI16_Node;
    function GetData(const Index: NativeInt): PKDT5DI16_Source;
  public
    RootNode: PKDT5DI16_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT5DI16_DyanmicStoreBuffer;
    property SourceP[const Index: NativeInt]: PKDT5DI16_Source read GetData; default;

    { bakcall build }
    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT5DI16_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT5DI16_BuildMethod);
    procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT5DI16_BuildProc);
    { fill k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT5DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT5DI16_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT5DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT5DI16_BuildMethod); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT5DI16_BuildProc); overload;
    { search }
    function Search(const buff: TKDT5DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT5DI16_Node; overload;
    function Search(const buff: TKDT5DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT5DI16_Node; overload;
    function Search(const buff: TKDT5DI16_Vec; var SearchedDistanceMin: Double): PKDT5DI16_Node; overload;
    function Search(const buff: TKDT5DI16_Vec): PKDT5DI16_Node; overload;
    function SearchToken(const buff: TKDT5DI16_Vec): TPascalString;
    { parallel search }
    procedure Search(const inBuff: TKDT5DI16_DynamicVecBuffer; var OutBuff: TKDT5DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;
    procedure Search(const inBuff: TKDT5DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);
    procedure SaveToFile(FileName: SystemString);
    procedure LoadFromFile(FileName: SystemString);
    procedure PrintNodeTree(const NodePtr: PKDT5DI16_Node);
    procedure PrintBuffer;
    class function Vec(const s: SystemString): TKDT5DI16_Vec; overload;
    class function Vec(const v: TKDT5DI16_Vec): SystemString; overload;
    class function Distance(const v1, v2: TKDT5DI16_Vec): Double;
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT5DI16_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT6DI16 = class(TCoreClassObject)
  public type
    // code split
    TKDT6DI16_Vec = array [0 .. KDT6DI16_Axis - 1] of TKDT6DI16_VecType;
    PKDT6DI16_Vec = ^TKDT6DI16_Vec;

    TKDT6DI16_DynamicVecBuffer = array of TKDT6DI16_Vec;
    PKDT6DI16_DynamicVecBuffer = ^TKDT6DI16_DynamicVecBuffer;

    TKDT6DI16_Source = record
      buff: TKDT6DI16_Vec;
      Index: Int64;
      Token: TPascalString;
    end;

    PKDT6DI16_Source = ^TKDT6DI16_Source;
    TKDT6DI16_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT6DI16_Source) - 1] of PKDT6DI16_Source;
    PKDT6DI16_SourceBuffer = ^TKDT6DI16_SourceBuffer;

    TKDT6DI16_DyanmicSourceBuffer = array of PKDT6DI16_Source;
    PKDT6DI16_DyanmicSourceBuffer = ^TKDT6DI16_DyanmicSourceBuffer;

    TKDT6DI16_DyanmicStoreBuffer = array of TKDT6DI16_Source;
    PKDT6DI16_DyanmicStoreBuffer = ^TKDT6DI16_DyanmicStoreBuffer;

    PKDT6DI16_Node = ^TKDT6DI16_Node;

    TKDT6DI16_Node = record
      Parent, Right, Left: PKDT6DI16_Node;
      Vec: PKDT6DI16_Source;
    end;

    TKDT6DI16_BuildCall = procedure(const IndexFor: NativeInt; var Source: TKDT6DI16_Source; const Data: Pointer);
    TKDT6DI16_BuildMethod = procedure(const IndexFor: NativeInt; var Source: TKDT6DI16_Source; const Data: Pointer) of object;
{$IFDEF FPC}
    TKDT6DI16_BuildProc = procedure(const IndexFor: NativeInt; var Source: TKDT6DI16_Source; const Data: Pointer) is nested;
{$ELSE FPC}
    TKDT6DI16_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT6DI16_Source; const Data: Pointer);
{$ENDIF FPC}
  private
    KDStoreBuff: TKDT6DI16_DyanmicStoreBuffer;
    KDBuff: TKDT6DI16_DyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes: array of PKDT6DI16_Node;
    TestBuff: TKDT6DI16_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT6DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT6DI16_Node;
    function GetData(const Index: NativeInt): PKDT6DI16_Source;
  public
    RootNode: PKDT6DI16_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT6DI16_DyanmicStoreBuffer;
    property SourceP[const Index: NativeInt]: PKDT6DI16_Source read GetData; default;

    { bakcall build }
    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT6DI16_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT6DI16_BuildMethod);
    procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT6DI16_BuildProc);
    { fill k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT6DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT6DI16_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT6DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT6DI16_BuildMethod); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT6DI16_BuildProc); overload;
    { search }
    function Search(const buff: TKDT6DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT6DI16_Node; overload;
    function Search(const buff: TKDT6DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT6DI16_Node; overload;
    function Search(const buff: TKDT6DI16_Vec; var SearchedDistanceMin: Double): PKDT6DI16_Node; overload;
    function Search(const buff: TKDT6DI16_Vec): PKDT6DI16_Node; overload;
    function SearchToken(const buff: TKDT6DI16_Vec): TPascalString;
    { parallel search }
    procedure Search(const inBuff: TKDT6DI16_DynamicVecBuffer; var OutBuff: TKDT6DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;
    procedure Search(const inBuff: TKDT6DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);
    procedure SaveToFile(FileName: SystemString);
    procedure LoadFromFile(FileName: SystemString);
    procedure PrintNodeTree(const NodePtr: PKDT6DI16_Node);
    procedure PrintBuffer;
    class function Vec(const s: SystemString): TKDT6DI16_Vec; overload;
    class function Vec(const v: TKDT6DI16_Vec): SystemString; overload;
    class function Distance(const v1, v2: TKDT6DI16_Vec): Double;
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT6DI16_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT7DI16 = class(TCoreClassObject)
  public type
    // code split
    TKDT7DI16_Vec = array [0 .. KDT7DI16_Axis - 1] of TKDT7DI16_VecType;
    PKDT7DI16_Vec = ^TKDT7DI16_Vec;

    TKDT7DI16_DynamicVecBuffer = array of TKDT7DI16_Vec;
    PKDT7DI16_DynamicVecBuffer = ^TKDT7DI16_DynamicVecBuffer;

    TKDT7DI16_Source = record
      buff: TKDT7DI16_Vec;
      Index: Int64;
      Token: TPascalString;
    end;

    PKDT7DI16_Source = ^TKDT7DI16_Source;
    TKDT7DI16_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT7DI16_Source) - 1] of PKDT7DI16_Source;
    PKDT7DI16_SourceBuffer = ^TKDT7DI16_SourceBuffer;

    TKDT7DI16_DyanmicSourceBuffer = array of PKDT7DI16_Source;
    PKDT7DI16_DyanmicSourceBuffer = ^TKDT7DI16_DyanmicSourceBuffer;

    TKDT7DI16_DyanmicStoreBuffer = array of TKDT7DI16_Source;
    PKDT7DI16_DyanmicStoreBuffer = ^TKDT7DI16_DyanmicStoreBuffer;

    PKDT7DI16_Node = ^TKDT7DI16_Node;

    TKDT7DI16_Node = record
      Parent, Right, Left: PKDT7DI16_Node;
      Vec: PKDT7DI16_Source;
    end;

    TKDT7DI16_BuildCall = procedure(const IndexFor: NativeInt; var Source: TKDT7DI16_Source; const Data: Pointer);
    TKDT7DI16_BuildMethod = procedure(const IndexFor: NativeInt; var Source: TKDT7DI16_Source; const Data: Pointer) of object;
{$IFDEF FPC}
    TKDT7DI16_BuildProc = procedure(const IndexFor: NativeInt; var Source: TKDT7DI16_Source; const Data: Pointer) is nested;
{$ELSE FPC}
    TKDT7DI16_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT7DI16_Source; const Data: Pointer);
{$ENDIF FPC}
  private
    KDStoreBuff: TKDT7DI16_DyanmicStoreBuffer;
    KDBuff: TKDT7DI16_DyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes: array of PKDT7DI16_Node;
    TestBuff: TKDT7DI16_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT7DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT7DI16_Node;
    function GetData(const Index: NativeInt): PKDT7DI16_Source;
  public
    RootNode: PKDT7DI16_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT7DI16_DyanmicStoreBuffer;
    property SourceP[const Index: NativeInt]: PKDT7DI16_Source read GetData; default;

    { bakcall build }
    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT7DI16_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT7DI16_BuildMethod);
    procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT7DI16_BuildProc);
    { fill k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT7DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT7DI16_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT7DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT7DI16_BuildMethod); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT7DI16_BuildProc); overload;
    { search }
    function Search(const buff: TKDT7DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT7DI16_Node; overload;
    function Search(const buff: TKDT7DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT7DI16_Node; overload;
    function Search(const buff: TKDT7DI16_Vec; var SearchedDistanceMin: Double): PKDT7DI16_Node; overload;
    function Search(const buff: TKDT7DI16_Vec): PKDT7DI16_Node; overload;
    function SearchToken(const buff: TKDT7DI16_Vec): TPascalString;
    { parallel search }
    procedure Search(const inBuff: TKDT7DI16_DynamicVecBuffer; var OutBuff: TKDT7DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;
    procedure Search(const inBuff: TKDT7DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);
    procedure SaveToFile(FileName: SystemString);
    procedure LoadFromFile(FileName: SystemString);
    procedure PrintNodeTree(const NodePtr: PKDT7DI16_Node);
    procedure PrintBuffer;
    class function Vec(const s: SystemString): TKDT7DI16_Vec; overload;
    class function Vec(const v: TKDT7DI16_Vec): SystemString; overload;
    class function Distance(const v1, v2: TKDT7DI16_Vec): Double;
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT7DI16_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT8DI16 = class(TCoreClassObject)
  public type
    // code split
    TKDT8DI16_Vec = array [0 .. KDT8DI16_Axis - 1] of TKDT8DI16_VecType;
    PKDT8DI16_Vec = ^TKDT8DI16_Vec;

    TKDT8DI16_DynamicVecBuffer = array of TKDT8DI16_Vec;
    PKDT8DI16_DynamicVecBuffer = ^TKDT8DI16_DynamicVecBuffer;

    TKDT8DI16_Source = record
      buff: TKDT8DI16_Vec;
      Index: Int64;
      Token: TPascalString;
    end;

    PKDT8DI16_Source = ^TKDT8DI16_Source;
    TKDT8DI16_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT8DI16_Source) - 1] of PKDT8DI16_Source;
    PKDT8DI16_SourceBuffer = ^TKDT8DI16_SourceBuffer;

    TKDT8DI16_DyanmicSourceBuffer = array of PKDT8DI16_Source;
    PKDT8DI16_DyanmicSourceBuffer = ^TKDT8DI16_DyanmicSourceBuffer;

    TKDT8DI16_DyanmicStoreBuffer = array of TKDT8DI16_Source;
    PKDT8DI16_DyanmicStoreBuffer = ^TKDT8DI16_DyanmicStoreBuffer;

    PKDT8DI16_Node = ^TKDT8DI16_Node;

    TKDT8DI16_Node = record
      Parent, Right, Left: PKDT8DI16_Node;
      Vec: PKDT8DI16_Source;
    end;

    TKDT8DI16_BuildCall = procedure(const IndexFor: NativeInt; var Source: TKDT8DI16_Source; const Data: Pointer);
    TKDT8DI16_BuildMethod = procedure(const IndexFor: NativeInt; var Source: TKDT8DI16_Source; const Data: Pointer) of object;
{$IFDEF FPC}
    TKDT8DI16_BuildProc = procedure(const IndexFor: NativeInt; var Source: TKDT8DI16_Source; const Data: Pointer) is nested;
{$ELSE FPC}
    TKDT8DI16_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT8DI16_Source; const Data: Pointer);
{$ENDIF FPC}
  private
    KDStoreBuff: TKDT8DI16_DyanmicStoreBuffer;
    KDBuff: TKDT8DI16_DyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes: array of PKDT8DI16_Node;
    TestBuff: TKDT8DI16_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT8DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT8DI16_Node;
    function GetData(const Index: NativeInt): PKDT8DI16_Source;
  public
    RootNode: PKDT8DI16_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT8DI16_DyanmicStoreBuffer;
    property SourceP[const Index: NativeInt]: PKDT8DI16_Source read GetData; default;

    { bakcall build }
    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT8DI16_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT8DI16_BuildMethod);
    procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT8DI16_BuildProc);
    { fill k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT8DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT8DI16_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT8DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT8DI16_BuildMethod); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT8DI16_BuildProc); overload;
    { search }
    function Search(const buff: TKDT8DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT8DI16_Node; overload;
    function Search(const buff: TKDT8DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT8DI16_Node; overload;
    function Search(const buff: TKDT8DI16_Vec; var SearchedDistanceMin: Double): PKDT8DI16_Node; overload;
    function Search(const buff: TKDT8DI16_Vec): PKDT8DI16_Node; overload;
    function SearchToken(const buff: TKDT8DI16_Vec): TPascalString;
    { parallel search }
    procedure Search(const inBuff: TKDT8DI16_DynamicVecBuffer; var OutBuff: TKDT8DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;
    procedure Search(const inBuff: TKDT8DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);
    procedure SaveToFile(FileName: SystemString);
    procedure LoadFromFile(FileName: SystemString);
    procedure PrintNodeTree(const NodePtr: PKDT8DI16_Node);
    procedure PrintBuffer;
    class function Vec(const s: SystemString): TKDT8DI16_Vec; overload;
    class function Vec(const v: TKDT8DI16_Vec): SystemString; overload;
    class function Distance(const v1, v2: TKDT8DI16_Vec): Double;
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT8DI16_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT9DI16 = class(TCoreClassObject)
  public type
    // code split
    TKDT9DI16_Vec = array [0 .. KDT9DI16_Axis - 1] of TKDT9DI16_VecType;
    PKDT9DI16_Vec = ^TKDT9DI16_Vec;

    TKDT9DI16_DynamicVecBuffer = array of TKDT9DI16_Vec;
    PKDT9DI16_DynamicVecBuffer = ^TKDT9DI16_DynamicVecBuffer;

    TKDT9DI16_Source = record
      buff: TKDT9DI16_Vec;
      Index: Int64;
      Token: TPascalString;
    end;

    PKDT9DI16_Source = ^TKDT9DI16_Source;
    TKDT9DI16_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT9DI16_Source) - 1] of PKDT9DI16_Source;
    PKDT9DI16_SourceBuffer = ^TKDT9DI16_SourceBuffer;

    TKDT9DI16_DyanmicSourceBuffer = array of PKDT9DI16_Source;
    PKDT9DI16_DyanmicSourceBuffer = ^TKDT9DI16_DyanmicSourceBuffer;

    TKDT9DI16_DyanmicStoreBuffer = array of TKDT9DI16_Source;
    PKDT9DI16_DyanmicStoreBuffer = ^TKDT9DI16_DyanmicStoreBuffer;

    PKDT9DI16_Node = ^TKDT9DI16_Node;

    TKDT9DI16_Node = record
      Parent, Right, Left: PKDT9DI16_Node;
      Vec: PKDT9DI16_Source;
    end;

    TKDT9DI16_BuildCall = procedure(const IndexFor: NativeInt; var Source: TKDT9DI16_Source; const Data: Pointer);
    TKDT9DI16_BuildMethod = procedure(const IndexFor: NativeInt; var Source: TKDT9DI16_Source; const Data: Pointer) of object;
{$IFDEF FPC}
    TKDT9DI16_BuildProc = procedure(const IndexFor: NativeInt; var Source: TKDT9DI16_Source; const Data: Pointer) is nested;
{$ELSE FPC}
    TKDT9DI16_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT9DI16_Source; const Data: Pointer);
{$ENDIF FPC}
  private
    KDStoreBuff: TKDT9DI16_DyanmicStoreBuffer;
    KDBuff: TKDT9DI16_DyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes: array of PKDT9DI16_Node;
    TestBuff: TKDT9DI16_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT9DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT9DI16_Node;
    function GetData(const Index: NativeInt): PKDT9DI16_Source;
  public
    RootNode: PKDT9DI16_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT9DI16_DyanmicStoreBuffer;
    property SourceP[const Index: NativeInt]: PKDT9DI16_Source read GetData; default;

    { bakcall build }
    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT9DI16_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT9DI16_BuildMethod);
    procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT9DI16_BuildProc);
    { fill k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT9DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT9DI16_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT9DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT9DI16_BuildMethod); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT9DI16_BuildProc); overload;
    { search }
    function Search(const buff: TKDT9DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT9DI16_Node; overload;
    function Search(const buff: TKDT9DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT9DI16_Node; overload;
    function Search(const buff: TKDT9DI16_Vec; var SearchedDistanceMin: Double): PKDT9DI16_Node; overload;
    function Search(const buff: TKDT9DI16_Vec): PKDT9DI16_Node; overload;
    function SearchToken(const buff: TKDT9DI16_Vec): TPascalString;
    { parallel search }
    procedure Search(const inBuff: TKDT9DI16_DynamicVecBuffer; var OutBuff: TKDT9DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;
    procedure Search(const inBuff: TKDT9DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);
    procedure SaveToFile(FileName: SystemString);
    procedure LoadFromFile(FileName: SystemString);
    procedure PrintNodeTree(const NodePtr: PKDT9DI16_Node);
    procedure PrintBuffer;
    class function Vec(const s: SystemString): TKDT9DI16_Vec; overload;
    class function Vec(const v: TKDT9DI16_Vec): SystemString; overload;
    class function Distance(const v1, v2: TKDT9DI16_Vec): Double;
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT9DI16_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT10DI16 = class(TCoreClassObject)
  public type
    // code split
    TKDT10DI16_Vec = array [0 .. KDT10DI16_Axis - 1] of TKDT10DI16_VecType;
    PKDT10DI16_Vec = ^TKDT10DI16_Vec;

    TKDT10DI16_DynamicVecBuffer = array of TKDT10DI16_Vec;
    PKDT10DI16_DynamicVecBuffer = ^TKDT10DI16_DynamicVecBuffer;

    TKDT10DI16_Source = record
      buff: TKDT10DI16_Vec;
      Index: Int64;
      Token: TPascalString;
    end;

    PKDT10DI16_Source = ^TKDT10DI16_Source;
    TKDT10DI16_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT10DI16_Source) - 1] of PKDT10DI16_Source;
    PKDT10DI16_SourceBuffer = ^TKDT10DI16_SourceBuffer;

    TKDT10DI16_DyanmicSourceBuffer = array of PKDT10DI16_Source;
    PKDT10DI16_DyanmicSourceBuffer = ^TKDT10DI16_DyanmicSourceBuffer;

    TKDT10DI16_DyanmicStoreBuffer = array of TKDT10DI16_Source;
    PKDT10DI16_DyanmicStoreBuffer = ^TKDT10DI16_DyanmicStoreBuffer;

    PKDT10DI16_Node = ^TKDT10DI16_Node;

    TKDT10DI16_Node = record
      Parent, Right, Left: PKDT10DI16_Node;
      Vec: PKDT10DI16_Source;
    end;

    TKDT10DI16_BuildCall = procedure(const IndexFor: NativeInt; var Source: TKDT10DI16_Source; const Data: Pointer);
    TKDT10DI16_BuildMethod = procedure(const IndexFor: NativeInt; var Source: TKDT10DI16_Source; const Data: Pointer) of object;
{$IFDEF FPC}
    TKDT10DI16_BuildProc = procedure(const IndexFor: NativeInt; var Source: TKDT10DI16_Source; const Data: Pointer) is nested;
{$ELSE FPC}
    TKDT10DI16_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT10DI16_Source; const Data: Pointer);
{$ENDIF FPC}
  private
    KDStoreBuff: TKDT10DI16_DyanmicStoreBuffer;
    KDBuff: TKDT10DI16_DyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes: array of PKDT10DI16_Node;
    TestBuff: TKDT10DI16_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT10DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT10DI16_Node;
    function GetData(const Index: NativeInt): PKDT10DI16_Source;
  public
    RootNode: PKDT10DI16_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT10DI16_DyanmicStoreBuffer;
    property SourceP[const Index: NativeInt]: PKDT10DI16_Source read GetData; default;

    { bakcall build }
    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT10DI16_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT10DI16_BuildMethod);
    procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT10DI16_BuildProc);
    { fill k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT10DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT10DI16_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT10DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT10DI16_BuildMethod); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT10DI16_BuildProc); overload;
    { search }
    function Search(const buff: TKDT10DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT10DI16_Node; overload;
    function Search(const buff: TKDT10DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT10DI16_Node; overload;
    function Search(const buff: TKDT10DI16_Vec; var SearchedDistanceMin: Double): PKDT10DI16_Node; overload;
    function Search(const buff: TKDT10DI16_Vec): PKDT10DI16_Node; overload;
    function SearchToken(const buff: TKDT10DI16_Vec): TPascalString;
    { parallel search }
    procedure Search(const inBuff: TKDT10DI16_DynamicVecBuffer; var OutBuff: TKDT10DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;
    procedure Search(const inBuff: TKDT10DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);
    procedure SaveToFile(FileName: SystemString);
    procedure LoadFromFile(FileName: SystemString);
    procedure PrintNodeTree(const NodePtr: PKDT10DI16_Node);
    procedure PrintBuffer;
    class function Vec(const s: SystemString): TKDT10DI16_Vec; overload;
    class function Vec(const v: TKDT10DI16_Vec): SystemString; overload;
    class function Distance(const v1, v2: TKDT10DI16_Vec): Double;
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT10DI16_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT11DI16 = class(TCoreClassObject)
  public type
    // code split
    TKDT11DI16_Vec = array [0 .. KDT11DI16_Axis - 1] of TKDT11DI16_VecType;
    PKDT11DI16_Vec = ^TKDT11DI16_Vec;

    TKDT11DI16_DynamicVecBuffer = array of TKDT11DI16_Vec;
    PKDT11DI16_DynamicVecBuffer = ^TKDT11DI16_DynamicVecBuffer;

    TKDT11DI16_Source = record
      buff: TKDT11DI16_Vec;
      Index: Int64;
      Token: TPascalString;
    end;

    PKDT11DI16_Source = ^TKDT11DI16_Source;
    TKDT11DI16_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT11DI16_Source) - 1] of PKDT11DI16_Source;
    PKDT11DI16_SourceBuffer = ^TKDT11DI16_SourceBuffer;

    TKDT11DI16_DyanmicSourceBuffer = array of PKDT11DI16_Source;
    PKDT11DI16_DyanmicSourceBuffer = ^TKDT11DI16_DyanmicSourceBuffer;

    TKDT11DI16_DyanmicStoreBuffer = array of TKDT11DI16_Source;
    PKDT11DI16_DyanmicStoreBuffer = ^TKDT11DI16_DyanmicStoreBuffer;

    PKDT11DI16_Node = ^TKDT11DI16_Node;

    TKDT11DI16_Node = record
      Parent, Right, Left: PKDT11DI16_Node;
      Vec: PKDT11DI16_Source;
    end;

    TKDT11DI16_BuildCall = procedure(const IndexFor: NativeInt; var Source: TKDT11DI16_Source; const Data: Pointer);
    TKDT11DI16_BuildMethod = procedure(const IndexFor: NativeInt; var Source: TKDT11DI16_Source; const Data: Pointer) of object;
{$IFDEF FPC}
    TKDT11DI16_BuildProc = procedure(const IndexFor: NativeInt; var Source: TKDT11DI16_Source; const Data: Pointer) is nested;
{$ELSE FPC}
    TKDT11DI16_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT11DI16_Source; const Data: Pointer);
{$ENDIF FPC}
  private
    KDStoreBuff: TKDT11DI16_DyanmicStoreBuffer;
    KDBuff: TKDT11DI16_DyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes: array of PKDT11DI16_Node;
    TestBuff: TKDT11DI16_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT11DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT11DI16_Node;
    function GetData(const Index: NativeInt): PKDT11DI16_Source;
  public
    RootNode: PKDT11DI16_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT11DI16_DyanmicStoreBuffer;
    property SourceP[const Index: NativeInt]: PKDT11DI16_Source read GetData; default;

    { bakcall build }
    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT11DI16_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT11DI16_BuildMethod);
    procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT11DI16_BuildProc);
    { fill k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT11DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT11DI16_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT11DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT11DI16_BuildMethod); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT11DI16_BuildProc); overload;
    { search }
    function Search(const buff: TKDT11DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT11DI16_Node; overload;
    function Search(const buff: TKDT11DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT11DI16_Node; overload;
    function Search(const buff: TKDT11DI16_Vec; var SearchedDistanceMin: Double): PKDT11DI16_Node; overload;
    function Search(const buff: TKDT11DI16_Vec): PKDT11DI16_Node; overload;
    function SearchToken(const buff: TKDT11DI16_Vec): TPascalString;
    { parallel search }
    procedure Search(const inBuff: TKDT11DI16_DynamicVecBuffer; var OutBuff: TKDT11DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;
    procedure Search(const inBuff: TKDT11DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);
    procedure SaveToFile(FileName: SystemString);
    procedure LoadFromFile(FileName: SystemString);
    procedure PrintNodeTree(const NodePtr: PKDT11DI16_Node);
    procedure PrintBuffer;
    class function Vec(const s: SystemString): TKDT11DI16_Vec; overload;
    class function Vec(const v: TKDT11DI16_Vec): SystemString; overload;
    class function Distance(const v1, v2: TKDT11DI16_Vec): Double;
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT11DI16_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT12DI16 = class(TCoreClassObject)
  public type
    // code split
    TKDT12DI16_Vec = array [0 .. KDT12DI16_Axis - 1] of TKDT12DI16_VecType;
    PKDT12DI16_Vec = ^TKDT12DI16_Vec;

    TKDT12DI16_DynamicVecBuffer = array of TKDT12DI16_Vec;
    PKDT12DI16_DynamicVecBuffer = ^TKDT12DI16_DynamicVecBuffer;

    TKDT12DI16_Source = record
      buff: TKDT12DI16_Vec;
      Index: Int64;
      Token: TPascalString;
    end;

    PKDT12DI16_Source = ^TKDT12DI16_Source;
    TKDT12DI16_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT12DI16_Source) - 1] of PKDT12DI16_Source;
    PKDT12DI16_SourceBuffer = ^TKDT12DI16_SourceBuffer;

    TKDT12DI16_DyanmicSourceBuffer = array of PKDT12DI16_Source;
    PKDT12DI16_DyanmicSourceBuffer = ^TKDT12DI16_DyanmicSourceBuffer;

    TKDT12DI16_DyanmicStoreBuffer = array of TKDT12DI16_Source;
    PKDT12DI16_DyanmicStoreBuffer = ^TKDT12DI16_DyanmicStoreBuffer;

    PKDT12DI16_Node = ^TKDT12DI16_Node;

    TKDT12DI16_Node = record
      Parent, Right, Left: PKDT12DI16_Node;
      Vec: PKDT12DI16_Source;
    end;

    TKDT12DI16_BuildCall = procedure(const IndexFor: NativeInt; var Source: TKDT12DI16_Source; const Data: Pointer);
    TKDT12DI16_BuildMethod = procedure(const IndexFor: NativeInt; var Source: TKDT12DI16_Source; const Data: Pointer) of object;
{$IFDEF FPC}
    TKDT12DI16_BuildProc = procedure(const IndexFor: NativeInt; var Source: TKDT12DI16_Source; const Data: Pointer) is nested;
{$ELSE FPC}
    TKDT12DI16_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT12DI16_Source; const Data: Pointer);
{$ENDIF FPC}
  private
    KDStoreBuff: TKDT12DI16_DyanmicStoreBuffer;
    KDBuff: TKDT12DI16_DyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes: array of PKDT12DI16_Node;
    TestBuff: TKDT12DI16_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT12DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT12DI16_Node;
    function GetData(const Index: NativeInt): PKDT12DI16_Source;
  public
    RootNode: PKDT12DI16_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT12DI16_DyanmicStoreBuffer;
    property SourceP[const Index: NativeInt]: PKDT12DI16_Source read GetData; default;

    { bakcall build }
    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT12DI16_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT12DI16_BuildMethod);
    procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT12DI16_BuildProc);
    { fill k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT12DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT12DI16_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT12DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT12DI16_BuildMethod); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT12DI16_BuildProc); overload;
    { search }
    function Search(const buff: TKDT12DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT12DI16_Node; overload;
    function Search(const buff: TKDT12DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT12DI16_Node; overload;
    function Search(const buff: TKDT12DI16_Vec; var SearchedDistanceMin: Double): PKDT12DI16_Node; overload;
    function Search(const buff: TKDT12DI16_Vec): PKDT12DI16_Node; overload;
    function SearchToken(const buff: TKDT12DI16_Vec): TPascalString;
    { parallel search }
    procedure Search(const inBuff: TKDT12DI16_DynamicVecBuffer; var OutBuff: TKDT12DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;
    procedure Search(const inBuff: TKDT12DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);
    procedure SaveToFile(FileName: SystemString);
    procedure LoadFromFile(FileName: SystemString);
    procedure PrintNodeTree(const NodePtr: PKDT12DI16_Node);
    procedure PrintBuffer;
    class function Vec(const s: SystemString): TKDT12DI16_Vec; overload;
    class function Vec(const v: TKDT12DI16_Vec): SystemString; overload;
    class function Distance(const v1, v2: TKDT12DI16_Vec): Double;
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT12DI16_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT13DI16 = class(TCoreClassObject)
  public type
    // code split
    TKDT13DI16_Vec = array [0 .. KDT13DI16_Axis - 1] of TKDT13DI16_VecType;
    PKDT13DI16_Vec = ^TKDT13DI16_Vec;

    TKDT13DI16_DynamicVecBuffer = array of TKDT13DI16_Vec;
    PKDT13DI16_DynamicVecBuffer = ^TKDT13DI16_DynamicVecBuffer;

    TKDT13DI16_Source = record
      buff: TKDT13DI16_Vec;
      Index: Int64;
      Token: TPascalString;
    end;

    PKDT13DI16_Source = ^TKDT13DI16_Source;
    TKDT13DI16_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT13DI16_Source) - 1] of PKDT13DI16_Source;
    PKDT13DI16_SourceBuffer = ^TKDT13DI16_SourceBuffer;

    TKDT13DI16_DyanmicSourceBuffer = array of PKDT13DI16_Source;
    PKDT13DI16_DyanmicSourceBuffer = ^TKDT13DI16_DyanmicSourceBuffer;

    TKDT13DI16_DyanmicStoreBuffer = array of TKDT13DI16_Source;
    PKDT13DI16_DyanmicStoreBuffer = ^TKDT13DI16_DyanmicStoreBuffer;

    PKDT13DI16_Node = ^TKDT13DI16_Node;

    TKDT13DI16_Node = record
      Parent, Right, Left: PKDT13DI16_Node;
      Vec: PKDT13DI16_Source;
    end;

    TKDT13DI16_BuildCall = procedure(const IndexFor: NativeInt; var Source: TKDT13DI16_Source; const Data: Pointer);
    TKDT13DI16_BuildMethod = procedure(const IndexFor: NativeInt; var Source: TKDT13DI16_Source; const Data: Pointer) of object;
{$IFDEF FPC}
    TKDT13DI16_BuildProc = procedure(const IndexFor: NativeInt; var Source: TKDT13DI16_Source; const Data: Pointer) is nested;
{$ELSE FPC}
    TKDT13DI16_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT13DI16_Source; const Data: Pointer);
{$ENDIF FPC}
  private
    KDStoreBuff: TKDT13DI16_DyanmicStoreBuffer;
    KDBuff: TKDT13DI16_DyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes: array of PKDT13DI16_Node;
    TestBuff: TKDT13DI16_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT13DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT13DI16_Node;
    function GetData(const Index: NativeInt): PKDT13DI16_Source;
  public
    RootNode: PKDT13DI16_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT13DI16_DyanmicStoreBuffer;
    property SourceP[const Index: NativeInt]: PKDT13DI16_Source read GetData; default;

    { bakcall build }
    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT13DI16_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT13DI16_BuildMethod);
    procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT13DI16_BuildProc);
    { fill k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT13DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT13DI16_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT13DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT13DI16_BuildMethod); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT13DI16_BuildProc); overload;
    { search }
    function Search(const buff: TKDT13DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT13DI16_Node; overload;
    function Search(const buff: TKDT13DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT13DI16_Node; overload;
    function Search(const buff: TKDT13DI16_Vec; var SearchedDistanceMin: Double): PKDT13DI16_Node; overload;
    function Search(const buff: TKDT13DI16_Vec): PKDT13DI16_Node; overload;
    function SearchToken(const buff: TKDT13DI16_Vec): TPascalString;
    { parallel search }
    procedure Search(const inBuff: TKDT13DI16_DynamicVecBuffer; var OutBuff: TKDT13DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;
    procedure Search(const inBuff: TKDT13DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);
    procedure SaveToFile(FileName: SystemString);
    procedure LoadFromFile(FileName: SystemString);
    procedure PrintNodeTree(const NodePtr: PKDT13DI16_Node);
    procedure PrintBuffer;
    class function Vec(const s: SystemString): TKDT13DI16_Vec; overload;
    class function Vec(const v: TKDT13DI16_Vec): SystemString; overload;
    class function Distance(const v1, v2: TKDT13DI16_Vec): Double;
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT13DI16_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT14DI16 = class(TCoreClassObject)
  public type
    // code split
    TKDT14DI16_Vec = array [0 .. KDT14DI16_Axis - 1] of TKDT14DI16_VecType;
    PKDT14DI16_Vec = ^TKDT14DI16_Vec;

    TKDT14DI16_DynamicVecBuffer = array of TKDT14DI16_Vec;
    PKDT14DI16_DynamicVecBuffer = ^TKDT14DI16_DynamicVecBuffer;

    TKDT14DI16_Source = record
      buff: TKDT14DI16_Vec;
      Index: Int64;
      Token: TPascalString;
    end;

    PKDT14DI16_Source = ^TKDT14DI16_Source;
    TKDT14DI16_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT14DI16_Source) - 1] of PKDT14DI16_Source;
    PKDT14DI16_SourceBuffer = ^TKDT14DI16_SourceBuffer;

    TKDT14DI16_DyanmicSourceBuffer = array of PKDT14DI16_Source;
    PKDT14DI16_DyanmicSourceBuffer = ^TKDT14DI16_DyanmicSourceBuffer;

    TKDT14DI16_DyanmicStoreBuffer = array of TKDT14DI16_Source;
    PKDT14DI16_DyanmicStoreBuffer = ^TKDT14DI16_DyanmicStoreBuffer;

    PKDT14DI16_Node = ^TKDT14DI16_Node;

    TKDT14DI16_Node = record
      Parent, Right, Left: PKDT14DI16_Node;
      Vec: PKDT14DI16_Source;
    end;

    TKDT14DI16_BuildCall = procedure(const IndexFor: NativeInt; var Source: TKDT14DI16_Source; const Data: Pointer);
    TKDT14DI16_BuildMethod = procedure(const IndexFor: NativeInt; var Source: TKDT14DI16_Source; const Data: Pointer) of object;
{$IFDEF FPC}
    TKDT14DI16_BuildProc = procedure(const IndexFor: NativeInt; var Source: TKDT14DI16_Source; const Data: Pointer) is nested;
{$ELSE FPC}
    TKDT14DI16_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT14DI16_Source; const Data: Pointer);
{$ENDIF FPC}
  private
    KDStoreBuff: TKDT14DI16_DyanmicStoreBuffer;
    KDBuff: TKDT14DI16_DyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes: array of PKDT14DI16_Node;
    TestBuff: TKDT14DI16_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT14DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT14DI16_Node;
    function GetData(const Index: NativeInt): PKDT14DI16_Source;
  public
    RootNode: PKDT14DI16_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT14DI16_DyanmicStoreBuffer;
    property SourceP[const Index: NativeInt]: PKDT14DI16_Source read GetData; default;

    { bakcall build }
    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT14DI16_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT14DI16_BuildMethod);
    procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT14DI16_BuildProc);
    { fill k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT14DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT14DI16_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT14DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT14DI16_BuildMethod); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT14DI16_BuildProc); overload;
    { search }
    function Search(const buff: TKDT14DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT14DI16_Node; overload;
    function Search(const buff: TKDT14DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT14DI16_Node; overload;
    function Search(const buff: TKDT14DI16_Vec; var SearchedDistanceMin: Double): PKDT14DI16_Node; overload;
    function Search(const buff: TKDT14DI16_Vec): PKDT14DI16_Node; overload;
    function SearchToken(const buff: TKDT14DI16_Vec): TPascalString;
    { parallel search }
    procedure Search(const inBuff: TKDT14DI16_DynamicVecBuffer; var OutBuff: TKDT14DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;
    procedure Search(const inBuff: TKDT14DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);
    procedure SaveToFile(FileName: SystemString);
    procedure LoadFromFile(FileName: SystemString);
    procedure PrintNodeTree(const NodePtr: PKDT14DI16_Node);
    procedure PrintBuffer;
    class function Vec(const s: SystemString): TKDT14DI16_Vec; overload;
    class function Vec(const v: TKDT14DI16_Vec): SystemString; overload;
    class function Distance(const v1, v2: TKDT14DI16_Vec): Double;
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT14DI16_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT15DI16 = class(TCoreClassObject)
  public type
    // code split
    TKDT15DI16_Vec = array [0 .. KDT15DI16_Axis - 1] of TKDT15DI16_VecType;
    PKDT15DI16_Vec = ^TKDT15DI16_Vec;

    TKDT15DI16_DynamicVecBuffer = array of TKDT15DI16_Vec;
    PKDT15DI16_DynamicVecBuffer = ^TKDT15DI16_DynamicVecBuffer;

    TKDT15DI16_Source = record
      buff: TKDT15DI16_Vec;
      Index: Int64;
      Token: TPascalString;
    end;

    PKDT15DI16_Source = ^TKDT15DI16_Source;
    TKDT15DI16_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT15DI16_Source) - 1] of PKDT15DI16_Source;
    PKDT15DI16_SourceBuffer = ^TKDT15DI16_SourceBuffer;

    TKDT15DI16_DyanmicSourceBuffer = array of PKDT15DI16_Source;
    PKDT15DI16_DyanmicSourceBuffer = ^TKDT15DI16_DyanmicSourceBuffer;

    TKDT15DI16_DyanmicStoreBuffer = array of TKDT15DI16_Source;
    PKDT15DI16_DyanmicStoreBuffer = ^TKDT15DI16_DyanmicStoreBuffer;

    PKDT15DI16_Node = ^TKDT15DI16_Node;

    TKDT15DI16_Node = record
      Parent, Right, Left: PKDT15DI16_Node;
      Vec: PKDT15DI16_Source;
    end;

    TKDT15DI16_BuildCall = procedure(const IndexFor: NativeInt; var Source: TKDT15DI16_Source; const Data: Pointer);
    TKDT15DI16_BuildMethod = procedure(const IndexFor: NativeInt; var Source: TKDT15DI16_Source; const Data: Pointer) of object;
{$IFDEF FPC}
    TKDT15DI16_BuildProc = procedure(const IndexFor: NativeInt; var Source: TKDT15DI16_Source; const Data: Pointer) is nested;
{$ELSE FPC}
    TKDT15DI16_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT15DI16_Source; const Data: Pointer);
{$ENDIF FPC}
  private
    KDStoreBuff: TKDT15DI16_DyanmicStoreBuffer;
    KDBuff: TKDT15DI16_DyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes: array of PKDT15DI16_Node;
    TestBuff: TKDT15DI16_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT15DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT15DI16_Node;
    function GetData(const Index: NativeInt): PKDT15DI16_Source;
  public
    RootNode: PKDT15DI16_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT15DI16_DyanmicStoreBuffer;
    property SourceP[const Index: NativeInt]: PKDT15DI16_Source read GetData; default;

    { bakcall build }
    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT15DI16_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT15DI16_BuildMethod);
    procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT15DI16_BuildProc);
    { fill k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT15DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT15DI16_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT15DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT15DI16_BuildMethod); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT15DI16_BuildProc); overload;
    { search }
    function Search(const buff: TKDT15DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT15DI16_Node; overload;
    function Search(const buff: TKDT15DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT15DI16_Node; overload;
    function Search(const buff: TKDT15DI16_Vec; var SearchedDistanceMin: Double): PKDT15DI16_Node; overload;
    function Search(const buff: TKDT15DI16_Vec): PKDT15DI16_Node; overload;
    function SearchToken(const buff: TKDT15DI16_Vec): TPascalString;
    { parallel search }
    procedure Search(const inBuff: TKDT15DI16_DynamicVecBuffer; var OutBuff: TKDT15DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;
    procedure Search(const inBuff: TKDT15DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);
    procedure SaveToFile(FileName: SystemString);
    procedure LoadFromFile(FileName: SystemString);
    procedure PrintNodeTree(const NodePtr: PKDT15DI16_Node);
    procedure PrintBuffer;
    class function Vec(const s: SystemString): TKDT15DI16_Vec; overload;
    class function Vec(const v: TKDT15DI16_Vec): SystemString; overload;
    class function Distance(const v1, v2: TKDT15DI16_Vec): Double;
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT15DI16_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT16DI16 = class(TCoreClassObject)
  public type
    // code split
    TKDT16DI16_Vec = array [0 .. KDT16DI16_Axis - 1] of TKDT16DI16_VecType;
    PKDT16DI16_Vec = ^TKDT16DI16_Vec;

    TKDT16DI16_DynamicVecBuffer = array of TKDT16DI16_Vec;
    PKDT16DI16_DynamicVecBuffer = ^TKDT16DI16_DynamicVecBuffer;

    TKDT16DI16_Source = record
      buff: TKDT16DI16_Vec;
      Index: Int64;
      Token: TPascalString;
    end;

    PKDT16DI16_Source = ^TKDT16DI16_Source;
    TKDT16DI16_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT16DI16_Source) - 1] of PKDT16DI16_Source;
    PKDT16DI16_SourceBuffer = ^TKDT16DI16_SourceBuffer;

    TKDT16DI16_DyanmicSourceBuffer = array of PKDT16DI16_Source;
    PKDT16DI16_DyanmicSourceBuffer = ^TKDT16DI16_DyanmicSourceBuffer;

    TKDT16DI16_DyanmicStoreBuffer = array of TKDT16DI16_Source;
    PKDT16DI16_DyanmicStoreBuffer = ^TKDT16DI16_DyanmicStoreBuffer;

    PKDT16DI16_Node = ^TKDT16DI16_Node;

    TKDT16DI16_Node = record
      Parent, Right, Left: PKDT16DI16_Node;
      Vec: PKDT16DI16_Source;
    end;

    TKDT16DI16_BuildCall = procedure(const IndexFor: NativeInt; var Source: TKDT16DI16_Source; const Data: Pointer);
    TKDT16DI16_BuildMethod = procedure(const IndexFor: NativeInt; var Source: TKDT16DI16_Source; const Data: Pointer) of object;
{$IFDEF FPC}
    TKDT16DI16_BuildProc = procedure(const IndexFor: NativeInt; var Source: TKDT16DI16_Source; const Data: Pointer) is nested;
{$ELSE FPC}
    TKDT16DI16_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT16DI16_Source; const Data: Pointer);
{$ENDIF FPC}
  private
    KDStoreBuff: TKDT16DI16_DyanmicStoreBuffer;
    KDBuff: TKDT16DI16_DyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes: array of PKDT16DI16_Node;
    TestBuff: TKDT16DI16_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT16DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT16DI16_Node;
    function GetData(const Index: NativeInt): PKDT16DI16_Source;
  public
    RootNode: PKDT16DI16_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT16DI16_DyanmicStoreBuffer;
    property SourceP[const Index: NativeInt]: PKDT16DI16_Source read GetData; default;

    { bakcall build }
    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT16DI16_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT16DI16_BuildMethod);
    procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT16DI16_BuildProc);
    { fill k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT16DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT16DI16_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT16DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT16DI16_BuildMethod); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT16DI16_BuildProc); overload;
    { search }
    function Search(const buff: TKDT16DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT16DI16_Node; overload;
    function Search(const buff: TKDT16DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT16DI16_Node; overload;
    function Search(const buff: TKDT16DI16_Vec; var SearchedDistanceMin: Double): PKDT16DI16_Node; overload;
    function Search(const buff: TKDT16DI16_Vec): PKDT16DI16_Node; overload;
    function SearchToken(const buff: TKDT16DI16_Vec): TPascalString;
    { parallel search }
    procedure Search(const inBuff: TKDT16DI16_DynamicVecBuffer; var OutBuff: TKDT16DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;
    procedure Search(const inBuff: TKDT16DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);
    procedure SaveToFile(FileName: SystemString);
    procedure LoadFromFile(FileName: SystemString);
    procedure PrintNodeTree(const NodePtr: PKDT16DI16_Node);
    procedure PrintBuffer;
    class function Vec(const s: SystemString): TKDT16DI16_Vec; overload;
    class function Vec(const v: TKDT16DI16_Vec): SystemString; overload;
    class function Distance(const v1, v2: TKDT16DI16_Vec): Double;
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT16DI16_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT17DI16 = class(TCoreClassObject)
  public type
    // code split
    TKDT17DI16_Vec = array [0 .. KDT17DI16_Axis - 1] of TKDT17DI16_VecType;
    PKDT17DI16_Vec = ^TKDT17DI16_Vec;

    TKDT17DI16_DynamicVecBuffer = array of TKDT17DI16_Vec;
    PKDT17DI16_DynamicVecBuffer = ^TKDT17DI16_DynamicVecBuffer;

    TKDT17DI16_Source = record
      buff: TKDT17DI16_Vec;
      Index: Int64;
      Token: TPascalString;
    end;

    PKDT17DI16_Source = ^TKDT17DI16_Source;
    TKDT17DI16_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT17DI16_Source) - 1] of PKDT17DI16_Source;
    PKDT17DI16_SourceBuffer = ^TKDT17DI16_SourceBuffer;

    TKDT17DI16_DyanmicSourceBuffer = array of PKDT17DI16_Source;
    PKDT17DI16_DyanmicSourceBuffer = ^TKDT17DI16_DyanmicSourceBuffer;

    TKDT17DI16_DyanmicStoreBuffer = array of TKDT17DI16_Source;
    PKDT17DI16_DyanmicStoreBuffer = ^TKDT17DI16_DyanmicStoreBuffer;

    PKDT17DI16_Node = ^TKDT17DI16_Node;

    TKDT17DI16_Node = record
      Parent, Right, Left: PKDT17DI16_Node;
      Vec: PKDT17DI16_Source;
    end;

    TKDT17DI16_BuildCall = procedure(const IndexFor: NativeInt; var Source: TKDT17DI16_Source; const Data: Pointer);
    TKDT17DI16_BuildMethod = procedure(const IndexFor: NativeInt; var Source: TKDT17DI16_Source; const Data: Pointer) of object;
{$IFDEF FPC}
    TKDT17DI16_BuildProc = procedure(const IndexFor: NativeInt; var Source: TKDT17DI16_Source; const Data: Pointer) is nested;
{$ELSE FPC}
    TKDT17DI16_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT17DI16_Source; const Data: Pointer);
{$ENDIF FPC}
  private
    KDStoreBuff: TKDT17DI16_DyanmicStoreBuffer;
    KDBuff: TKDT17DI16_DyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes: array of PKDT17DI16_Node;
    TestBuff: TKDT17DI16_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT17DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT17DI16_Node;
    function GetData(const Index: NativeInt): PKDT17DI16_Source;
  public
    RootNode: PKDT17DI16_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT17DI16_DyanmicStoreBuffer;
    property SourceP[const Index: NativeInt]: PKDT17DI16_Source read GetData; default;

    { bakcall build }
    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT17DI16_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT17DI16_BuildMethod);
    procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT17DI16_BuildProc);
    { fill k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT17DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT17DI16_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT17DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT17DI16_BuildMethod); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT17DI16_BuildProc); overload;
    { search }
    function Search(const buff: TKDT17DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT17DI16_Node; overload;
    function Search(const buff: TKDT17DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT17DI16_Node; overload;
    function Search(const buff: TKDT17DI16_Vec; var SearchedDistanceMin: Double): PKDT17DI16_Node; overload;
    function Search(const buff: TKDT17DI16_Vec): PKDT17DI16_Node; overload;
    function SearchToken(const buff: TKDT17DI16_Vec): TPascalString;
    { parallel search }
    procedure Search(const inBuff: TKDT17DI16_DynamicVecBuffer; var OutBuff: TKDT17DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;
    procedure Search(const inBuff: TKDT17DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);
    procedure SaveToFile(FileName: SystemString);
    procedure LoadFromFile(FileName: SystemString);
    procedure PrintNodeTree(const NodePtr: PKDT17DI16_Node);
    procedure PrintBuffer;
    class function Vec(const s: SystemString): TKDT17DI16_Vec; overload;
    class function Vec(const v: TKDT17DI16_Vec): SystemString; overload;
    class function Distance(const v1, v2: TKDT17DI16_Vec): Double;
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT17DI16_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT18DI16 = class(TCoreClassObject)
  public type
    // code split
    TKDT18DI16_Vec = array [0 .. KDT18DI16_Axis - 1] of TKDT18DI16_VecType;
    PKDT18DI16_Vec = ^TKDT18DI16_Vec;

    TKDT18DI16_DynamicVecBuffer = array of TKDT18DI16_Vec;
    PKDT18DI16_DynamicVecBuffer = ^TKDT18DI16_DynamicVecBuffer;

    TKDT18DI16_Source = record
      buff: TKDT18DI16_Vec;
      Index: Int64;
      Token: TPascalString;
    end;

    PKDT18DI16_Source = ^TKDT18DI16_Source;
    TKDT18DI16_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT18DI16_Source) - 1] of PKDT18DI16_Source;
    PKDT18DI16_SourceBuffer = ^TKDT18DI16_SourceBuffer;

    TKDT18DI16_DyanmicSourceBuffer = array of PKDT18DI16_Source;
    PKDT18DI16_DyanmicSourceBuffer = ^TKDT18DI16_DyanmicSourceBuffer;

    TKDT18DI16_DyanmicStoreBuffer = array of TKDT18DI16_Source;
    PKDT18DI16_DyanmicStoreBuffer = ^TKDT18DI16_DyanmicStoreBuffer;

    PKDT18DI16_Node = ^TKDT18DI16_Node;

    TKDT18DI16_Node = record
      Parent, Right, Left: PKDT18DI16_Node;
      Vec: PKDT18DI16_Source;
    end;

    TKDT18DI16_BuildCall = procedure(const IndexFor: NativeInt; var Source: TKDT18DI16_Source; const Data: Pointer);
    TKDT18DI16_BuildMethod = procedure(const IndexFor: NativeInt; var Source: TKDT18DI16_Source; const Data: Pointer) of object;
{$IFDEF FPC}
    TKDT18DI16_BuildProc = procedure(const IndexFor: NativeInt; var Source: TKDT18DI16_Source; const Data: Pointer) is nested;
{$ELSE FPC}
    TKDT18DI16_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT18DI16_Source; const Data: Pointer);
{$ENDIF FPC}
  private
    KDStoreBuff: TKDT18DI16_DyanmicStoreBuffer;
    KDBuff: TKDT18DI16_DyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes: array of PKDT18DI16_Node;
    TestBuff: TKDT18DI16_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT18DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT18DI16_Node;
    function GetData(const Index: NativeInt): PKDT18DI16_Source;
  public
    RootNode: PKDT18DI16_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT18DI16_DyanmicStoreBuffer;
    property SourceP[const Index: NativeInt]: PKDT18DI16_Source read GetData; default;

    { bakcall build }
    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT18DI16_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT18DI16_BuildMethod);
    procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT18DI16_BuildProc);
    { fill k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT18DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT18DI16_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT18DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT18DI16_BuildMethod); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT18DI16_BuildProc); overload;
    { search }
    function Search(const buff: TKDT18DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT18DI16_Node; overload;
    function Search(const buff: TKDT18DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT18DI16_Node; overload;
    function Search(const buff: TKDT18DI16_Vec; var SearchedDistanceMin: Double): PKDT18DI16_Node; overload;
    function Search(const buff: TKDT18DI16_Vec): PKDT18DI16_Node; overload;
    function SearchToken(const buff: TKDT18DI16_Vec): TPascalString;
    { parallel search }
    procedure Search(const inBuff: TKDT18DI16_DynamicVecBuffer; var OutBuff: TKDT18DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;
    procedure Search(const inBuff: TKDT18DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);
    procedure SaveToFile(FileName: SystemString);
    procedure LoadFromFile(FileName: SystemString);
    procedure PrintNodeTree(const NodePtr: PKDT18DI16_Node);
    procedure PrintBuffer;
    class function Vec(const s: SystemString): TKDT18DI16_Vec; overload;
    class function Vec(const v: TKDT18DI16_Vec): SystemString; overload;
    class function Distance(const v1, v2: TKDT18DI16_Vec): Double;
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT18DI16_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT19DI16 = class(TCoreClassObject)
  public type
    // code split
    TKDT19DI16_Vec = array [0 .. KDT19DI16_Axis - 1] of TKDT19DI16_VecType;
    PKDT19DI16_Vec = ^TKDT19DI16_Vec;

    TKDT19DI16_DynamicVecBuffer = array of TKDT19DI16_Vec;
    PKDT19DI16_DynamicVecBuffer = ^TKDT19DI16_DynamicVecBuffer;

    TKDT19DI16_Source = record
      buff: TKDT19DI16_Vec;
      Index: Int64;
      Token: TPascalString;
    end;

    PKDT19DI16_Source = ^TKDT19DI16_Source;
    TKDT19DI16_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT19DI16_Source) - 1] of PKDT19DI16_Source;
    PKDT19DI16_SourceBuffer = ^TKDT19DI16_SourceBuffer;

    TKDT19DI16_DyanmicSourceBuffer = array of PKDT19DI16_Source;
    PKDT19DI16_DyanmicSourceBuffer = ^TKDT19DI16_DyanmicSourceBuffer;

    TKDT19DI16_DyanmicStoreBuffer = array of TKDT19DI16_Source;
    PKDT19DI16_DyanmicStoreBuffer = ^TKDT19DI16_DyanmicStoreBuffer;

    PKDT19DI16_Node = ^TKDT19DI16_Node;

    TKDT19DI16_Node = record
      Parent, Right, Left: PKDT19DI16_Node;
      Vec: PKDT19DI16_Source;
    end;

    TKDT19DI16_BuildCall = procedure(const IndexFor: NativeInt; var Source: TKDT19DI16_Source; const Data: Pointer);
    TKDT19DI16_BuildMethod = procedure(const IndexFor: NativeInt; var Source: TKDT19DI16_Source; const Data: Pointer) of object;
{$IFDEF FPC}
    TKDT19DI16_BuildProc = procedure(const IndexFor: NativeInt; var Source: TKDT19DI16_Source; const Data: Pointer) is nested;
{$ELSE FPC}
    TKDT19DI16_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT19DI16_Source; const Data: Pointer);
{$ENDIF FPC}
  private
    KDStoreBuff: TKDT19DI16_DyanmicStoreBuffer;
    KDBuff: TKDT19DI16_DyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes: array of PKDT19DI16_Node;
    TestBuff: TKDT19DI16_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT19DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT19DI16_Node;
    function GetData(const Index: NativeInt): PKDT19DI16_Source;
  public
    RootNode: PKDT19DI16_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT19DI16_DyanmicStoreBuffer;
    property SourceP[const Index: NativeInt]: PKDT19DI16_Source read GetData; default;

    { bakcall build }
    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT19DI16_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT19DI16_BuildMethod);
    procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT19DI16_BuildProc);
    { fill k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT19DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT19DI16_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT19DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT19DI16_BuildMethod); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT19DI16_BuildProc); overload;
    { search }
    function Search(const buff: TKDT19DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT19DI16_Node; overload;
    function Search(const buff: TKDT19DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT19DI16_Node; overload;
    function Search(const buff: TKDT19DI16_Vec; var SearchedDistanceMin: Double): PKDT19DI16_Node; overload;
    function Search(const buff: TKDT19DI16_Vec): PKDT19DI16_Node; overload;
    function SearchToken(const buff: TKDT19DI16_Vec): TPascalString;
    { parallel search }
    procedure Search(const inBuff: TKDT19DI16_DynamicVecBuffer; var OutBuff: TKDT19DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;
    procedure Search(const inBuff: TKDT19DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);
    procedure SaveToFile(FileName: SystemString);
    procedure LoadFromFile(FileName: SystemString);
    procedure PrintNodeTree(const NodePtr: PKDT19DI16_Node);
    procedure PrintBuffer;
    class function Vec(const s: SystemString): TKDT19DI16_Vec; overload;
    class function Vec(const v: TKDT19DI16_Vec): SystemString; overload;
    class function Distance(const v1, v2: TKDT19DI16_Vec): Double;
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT19DI16_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT20DI16 = class(TCoreClassObject)
  public type
    // code split
    TKDT20DI16_Vec = array [0 .. KDT20DI16_Axis - 1] of TKDT20DI16_VecType;
    PKDT20DI16_Vec = ^TKDT20DI16_Vec;

    TKDT20DI16_DynamicVecBuffer = array of TKDT20DI16_Vec;
    PKDT20DI16_DynamicVecBuffer = ^TKDT20DI16_DynamicVecBuffer;

    TKDT20DI16_Source = record
      buff: TKDT20DI16_Vec;
      Index: Int64;
      Token: TPascalString;
    end;

    PKDT20DI16_Source = ^TKDT20DI16_Source;
    TKDT20DI16_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT20DI16_Source) - 1] of PKDT20DI16_Source;
    PKDT20DI16_SourceBuffer = ^TKDT20DI16_SourceBuffer;

    TKDT20DI16_DyanmicSourceBuffer = array of PKDT20DI16_Source;
    PKDT20DI16_DyanmicSourceBuffer = ^TKDT20DI16_DyanmicSourceBuffer;

    TKDT20DI16_DyanmicStoreBuffer = array of TKDT20DI16_Source;
    PKDT20DI16_DyanmicStoreBuffer = ^TKDT20DI16_DyanmicStoreBuffer;

    PKDT20DI16_Node = ^TKDT20DI16_Node;

    TKDT20DI16_Node = record
      Parent, Right, Left: PKDT20DI16_Node;
      Vec: PKDT20DI16_Source;
    end;

    TKDT20DI16_BuildCall = procedure(const IndexFor: NativeInt; var Source: TKDT20DI16_Source; const Data: Pointer);
    TKDT20DI16_BuildMethod = procedure(const IndexFor: NativeInt; var Source: TKDT20DI16_Source; const Data: Pointer) of object;
{$IFDEF FPC}
    TKDT20DI16_BuildProc = procedure(const IndexFor: NativeInt; var Source: TKDT20DI16_Source; const Data: Pointer) is nested;
{$ELSE FPC}
    TKDT20DI16_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT20DI16_Source; const Data: Pointer);
{$ENDIF FPC}
  private
    KDStoreBuff: TKDT20DI16_DyanmicStoreBuffer;
    KDBuff: TKDT20DI16_DyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes: array of PKDT20DI16_Node;
    TestBuff: TKDT20DI16_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT20DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT20DI16_Node;
    function GetData(const Index: NativeInt): PKDT20DI16_Source;
  public
    RootNode: PKDT20DI16_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT20DI16_DyanmicStoreBuffer;
    property SourceP[const Index: NativeInt]: PKDT20DI16_Source read GetData; default;

    { bakcall build }
    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT20DI16_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT20DI16_BuildMethod);
    procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT20DI16_BuildProc);
    { fill k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT20DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT20DI16_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT20DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT20DI16_BuildMethod); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT20DI16_BuildProc); overload;
    { search }
    function Search(const buff: TKDT20DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT20DI16_Node; overload;
    function Search(const buff: TKDT20DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT20DI16_Node; overload;
    function Search(const buff: TKDT20DI16_Vec; var SearchedDistanceMin: Double): PKDT20DI16_Node; overload;
    function Search(const buff: TKDT20DI16_Vec): PKDT20DI16_Node; overload;
    function SearchToken(const buff: TKDT20DI16_Vec): TPascalString;
    { parallel search }
    procedure Search(const inBuff: TKDT20DI16_DynamicVecBuffer; var OutBuff: TKDT20DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;
    procedure Search(const inBuff: TKDT20DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);
    procedure SaveToFile(FileName: SystemString);
    procedure LoadFromFile(FileName: SystemString);
    procedure PrintNodeTree(const NodePtr: PKDT20DI16_Node);
    procedure PrintBuffer;
    class function Vec(const s: SystemString): TKDT20DI16_Vec; overload;
    class function Vec(const v: TKDT20DI16_Vec): SystemString; overload;
    class function Distance(const v1, v2: TKDT20DI16_Vec): Double;
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT20DI16_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT21DI16 = class(TCoreClassObject)
  public type
    // code split
    TKDT21DI16_Vec = array [0 .. KDT21DI16_Axis - 1] of TKDT21DI16_VecType;
    PKDT21DI16_Vec = ^TKDT21DI16_Vec;

    TKDT21DI16_DynamicVecBuffer = array of TKDT21DI16_Vec;
    PKDT21DI16_DynamicVecBuffer = ^TKDT21DI16_DynamicVecBuffer;

    TKDT21DI16_Source = record
      buff: TKDT21DI16_Vec;
      Index: Int64;
      Token: TPascalString;
    end;

    PKDT21DI16_Source = ^TKDT21DI16_Source;
    TKDT21DI16_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT21DI16_Source) - 1] of PKDT21DI16_Source;
    PKDT21DI16_SourceBuffer = ^TKDT21DI16_SourceBuffer;

    TKDT21DI16_DyanmicSourceBuffer = array of PKDT21DI16_Source;
    PKDT21DI16_DyanmicSourceBuffer = ^TKDT21DI16_DyanmicSourceBuffer;

    TKDT21DI16_DyanmicStoreBuffer = array of TKDT21DI16_Source;
    PKDT21DI16_DyanmicStoreBuffer = ^TKDT21DI16_DyanmicStoreBuffer;

    PKDT21DI16_Node = ^TKDT21DI16_Node;

    TKDT21DI16_Node = record
      Parent, Right, Left: PKDT21DI16_Node;
      Vec: PKDT21DI16_Source;
    end;

    TKDT21DI16_BuildCall = procedure(const IndexFor: NativeInt; var Source: TKDT21DI16_Source; const Data: Pointer);
    TKDT21DI16_BuildMethod = procedure(const IndexFor: NativeInt; var Source: TKDT21DI16_Source; const Data: Pointer) of object;
{$IFDEF FPC}
    TKDT21DI16_BuildProc = procedure(const IndexFor: NativeInt; var Source: TKDT21DI16_Source; const Data: Pointer) is nested;
{$ELSE FPC}
    TKDT21DI16_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT21DI16_Source; const Data: Pointer);
{$ENDIF FPC}
  private
    KDStoreBuff: TKDT21DI16_DyanmicStoreBuffer;
    KDBuff: TKDT21DI16_DyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes: array of PKDT21DI16_Node;
    TestBuff: TKDT21DI16_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT21DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT21DI16_Node;
    function GetData(const Index: NativeInt): PKDT21DI16_Source;
  public
    RootNode: PKDT21DI16_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT21DI16_DyanmicStoreBuffer;
    property SourceP[const Index: NativeInt]: PKDT21DI16_Source read GetData; default;

    { bakcall build }
    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT21DI16_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT21DI16_BuildMethod);
    procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT21DI16_BuildProc);
    { fill k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT21DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT21DI16_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT21DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT21DI16_BuildMethod); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT21DI16_BuildProc); overload;
    { search }
    function Search(const buff: TKDT21DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT21DI16_Node; overload;
    function Search(const buff: TKDT21DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT21DI16_Node; overload;
    function Search(const buff: TKDT21DI16_Vec; var SearchedDistanceMin: Double): PKDT21DI16_Node; overload;
    function Search(const buff: TKDT21DI16_Vec): PKDT21DI16_Node; overload;
    function SearchToken(const buff: TKDT21DI16_Vec): TPascalString;
    { parallel search }
    procedure Search(const inBuff: TKDT21DI16_DynamicVecBuffer; var OutBuff: TKDT21DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;
    procedure Search(const inBuff: TKDT21DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);
    procedure SaveToFile(FileName: SystemString);
    procedure LoadFromFile(FileName: SystemString);
    procedure PrintNodeTree(const NodePtr: PKDT21DI16_Node);
    procedure PrintBuffer;
    class function Vec(const s: SystemString): TKDT21DI16_Vec; overload;
    class function Vec(const v: TKDT21DI16_Vec): SystemString; overload;
    class function Distance(const v1, v2: TKDT21DI16_Vec): Double;
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT21DI16_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT22DI16 = class(TCoreClassObject)
  public type
    // code split
    TKDT22DI16_Vec = array [0 .. KDT22DI16_Axis - 1] of TKDT22DI16_VecType;
    PKDT22DI16_Vec = ^TKDT22DI16_Vec;

    TKDT22DI16_DynamicVecBuffer = array of TKDT22DI16_Vec;
    PKDT22DI16_DynamicVecBuffer = ^TKDT22DI16_DynamicVecBuffer;

    TKDT22DI16_Source = record
      buff: TKDT22DI16_Vec;
      Index: Int64;
      Token: TPascalString;
    end;

    PKDT22DI16_Source = ^TKDT22DI16_Source;
    TKDT22DI16_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT22DI16_Source) - 1] of PKDT22DI16_Source;
    PKDT22DI16_SourceBuffer = ^TKDT22DI16_SourceBuffer;

    TKDT22DI16_DyanmicSourceBuffer = array of PKDT22DI16_Source;
    PKDT22DI16_DyanmicSourceBuffer = ^TKDT22DI16_DyanmicSourceBuffer;

    TKDT22DI16_DyanmicStoreBuffer = array of TKDT22DI16_Source;
    PKDT22DI16_DyanmicStoreBuffer = ^TKDT22DI16_DyanmicStoreBuffer;

    PKDT22DI16_Node = ^TKDT22DI16_Node;

    TKDT22DI16_Node = record
      Parent, Right, Left: PKDT22DI16_Node;
      Vec: PKDT22DI16_Source;
    end;

    TKDT22DI16_BuildCall = procedure(const IndexFor: NativeInt; var Source: TKDT22DI16_Source; const Data: Pointer);
    TKDT22DI16_BuildMethod = procedure(const IndexFor: NativeInt; var Source: TKDT22DI16_Source; const Data: Pointer) of object;
{$IFDEF FPC}
    TKDT22DI16_BuildProc = procedure(const IndexFor: NativeInt; var Source: TKDT22DI16_Source; const Data: Pointer) is nested;
{$ELSE FPC}
    TKDT22DI16_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT22DI16_Source; const Data: Pointer);
{$ENDIF FPC}
  private
    KDStoreBuff: TKDT22DI16_DyanmicStoreBuffer;
    KDBuff: TKDT22DI16_DyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes: array of PKDT22DI16_Node;
    TestBuff: TKDT22DI16_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT22DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT22DI16_Node;
    function GetData(const Index: NativeInt): PKDT22DI16_Source;
  public
    RootNode: PKDT22DI16_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT22DI16_DyanmicStoreBuffer;
    property SourceP[const Index: NativeInt]: PKDT22DI16_Source read GetData; default;

    { bakcall build }
    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT22DI16_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT22DI16_BuildMethod);
    procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT22DI16_BuildProc);
    { fill k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT22DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT22DI16_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT22DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT22DI16_BuildMethod); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT22DI16_BuildProc); overload;
    { search }
    function Search(const buff: TKDT22DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT22DI16_Node; overload;
    function Search(const buff: TKDT22DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT22DI16_Node; overload;
    function Search(const buff: TKDT22DI16_Vec; var SearchedDistanceMin: Double): PKDT22DI16_Node; overload;
    function Search(const buff: TKDT22DI16_Vec): PKDT22DI16_Node; overload;
    function SearchToken(const buff: TKDT22DI16_Vec): TPascalString;
    { parallel search }
    procedure Search(const inBuff: TKDT22DI16_DynamicVecBuffer; var OutBuff: TKDT22DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;
    procedure Search(const inBuff: TKDT22DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);
    procedure SaveToFile(FileName: SystemString);
    procedure LoadFromFile(FileName: SystemString);
    procedure PrintNodeTree(const NodePtr: PKDT22DI16_Node);
    procedure PrintBuffer;
    class function Vec(const s: SystemString): TKDT22DI16_Vec; overload;
    class function Vec(const v: TKDT22DI16_Vec): SystemString; overload;
    class function Distance(const v1, v2: TKDT22DI16_Vec): Double;
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT22DI16_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT23DI16 = class(TCoreClassObject)
  public type
    // code split
    TKDT23DI16_Vec = array [0 .. KDT23DI16_Axis - 1] of TKDT23DI16_VecType;
    PKDT23DI16_Vec = ^TKDT23DI16_Vec;

    TKDT23DI16_DynamicVecBuffer = array of TKDT23DI16_Vec;
    PKDT23DI16_DynamicVecBuffer = ^TKDT23DI16_DynamicVecBuffer;

    TKDT23DI16_Source = record
      buff: TKDT23DI16_Vec;
      Index: Int64;
      Token: TPascalString;
    end;

    PKDT23DI16_Source = ^TKDT23DI16_Source;
    TKDT23DI16_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT23DI16_Source) - 1] of PKDT23DI16_Source;
    PKDT23DI16_SourceBuffer = ^TKDT23DI16_SourceBuffer;

    TKDT23DI16_DyanmicSourceBuffer = array of PKDT23DI16_Source;
    PKDT23DI16_DyanmicSourceBuffer = ^TKDT23DI16_DyanmicSourceBuffer;

    TKDT23DI16_DyanmicStoreBuffer = array of TKDT23DI16_Source;
    PKDT23DI16_DyanmicStoreBuffer = ^TKDT23DI16_DyanmicStoreBuffer;

    PKDT23DI16_Node = ^TKDT23DI16_Node;

    TKDT23DI16_Node = record
      Parent, Right, Left: PKDT23DI16_Node;
      Vec: PKDT23DI16_Source;
    end;

    TKDT23DI16_BuildCall = procedure(const IndexFor: NativeInt; var Source: TKDT23DI16_Source; const Data: Pointer);
    TKDT23DI16_BuildMethod = procedure(const IndexFor: NativeInt; var Source: TKDT23DI16_Source; const Data: Pointer) of object;
{$IFDEF FPC}
    TKDT23DI16_BuildProc = procedure(const IndexFor: NativeInt; var Source: TKDT23DI16_Source; const Data: Pointer) is nested;
{$ELSE FPC}
    TKDT23DI16_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT23DI16_Source; const Data: Pointer);
{$ENDIF FPC}
  private
    KDStoreBuff: TKDT23DI16_DyanmicStoreBuffer;
    KDBuff: TKDT23DI16_DyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes: array of PKDT23DI16_Node;
    TestBuff: TKDT23DI16_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT23DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT23DI16_Node;
    function GetData(const Index: NativeInt): PKDT23DI16_Source;
  public
    RootNode: PKDT23DI16_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT23DI16_DyanmicStoreBuffer;
    property SourceP[const Index: NativeInt]: PKDT23DI16_Source read GetData; default;

    { bakcall build }
    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT23DI16_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT23DI16_BuildMethod);
    procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT23DI16_BuildProc);
    { fill k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT23DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT23DI16_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT23DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT23DI16_BuildMethod); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT23DI16_BuildProc); overload;
    { search }
    function Search(const buff: TKDT23DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT23DI16_Node; overload;
    function Search(const buff: TKDT23DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT23DI16_Node; overload;
    function Search(const buff: TKDT23DI16_Vec; var SearchedDistanceMin: Double): PKDT23DI16_Node; overload;
    function Search(const buff: TKDT23DI16_Vec): PKDT23DI16_Node; overload;
    function SearchToken(const buff: TKDT23DI16_Vec): TPascalString;
    { parallel search }
    procedure Search(const inBuff: TKDT23DI16_DynamicVecBuffer; var OutBuff: TKDT23DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;
    procedure Search(const inBuff: TKDT23DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);
    procedure SaveToFile(FileName: SystemString);
    procedure LoadFromFile(FileName: SystemString);
    procedure PrintNodeTree(const NodePtr: PKDT23DI16_Node);
    procedure PrintBuffer;
    class function Vec(const s: SystemString): TKDT23DI16_Vec; overload;
    class function Vec(const v: TKDT23DI16_Vec): SystemString; overload;
    class function Distance(const v1, v2: TKDT23DI16_Vec): Double;
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT23DI16_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT24DI16 = class(TCoreClassObject)
  public type
    // code split
    TKDT24DI16_Vec = array [0 .. KDT24DI16_Axis - 1] of TKDT24DI16_VecType;
    PKDT24DI16_Vec = ^TKDT24DI16_Vec;

    TKDT24DI16_DynamicVecBuffer = array of TKDT24DI16_Vec;
    PKDT24DI16_DynamicVecBuffer = ^TKDT24DI16_DynamicVecBuffer;

    TKDT24DI16_Source = record
      buff: TKDT24DI16_Vec;
      Index: Int64;
      Token: TPascalString;
    end;

    PKDT24DI16_Source = ^TKDT24DI16_Source;
    TKDT24DI16_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT24DI16_Source) - 1] of PKDT24DI16_Source;
    PKDT24DI16_SourceBuffer = ^TKDT24DI16_SourceBuffer;

    TKDT24DI16_DyanmicSourceBuffer = array of PKDT24DI16_Source;
    PKDT24DI16_DyanmicSourceBuffer = ^TKDT24DI16_DyanmicSourceBuffer;

    TKDT24DI16_DyanmicStoreBuffer = array of TKDT24DI16_Source;
    PKDT24DI16_DyanmicStoreBuffer = ^TKDT24DI16_DyanmicStoreBuffer;

    PKDT24DI16_Node = ^TKDT24DI16_Node;

    TKDT24DI16_Node = record
      Parent, Right, Left: PKDT24DI16_Node;
      Vec: PKDT24DI16_Source;
    end;

    TKDT24DI16_BuildCall = procedure(const IndexFor: NativeInt; var Source: TKDT24DI16_Source; const Data: Pointer);
    TKDT24DI16_BuildMethod = procedure(const IndexFor: NativeInt; var Source: TKDT24DI16_Source; const Data: Pointer) of object;
{$IFDEF FPC}
    TKDT24DI16_BuildProc = procedure(const IndexFor: NativeInt; var Source: TKDT24DI16_Source; const Data: Pointer) is nested;
{$ELSE FPC}
    TKDT24DI16_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT24DI16_Source; const Data: Pointer);
{$ENDIF FPC}
  private
    KDStoreBuff: TKDT24DI16_DyanmicStoreBuffer;
    KDBuff: TKDT24DI16_DyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes: array of PKDT24DI16_Node;
    TestBuff: TKDT24DI16_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT24DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT24DI16_Node;
    function GetData(const Index: NativeInt): PKDT24DI16_Source;
  public
    RootNode: PKDT24DI16_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT24DI16_DyanmicStoreBuffer;
    property SourceP[const Index: NativeInt]: PKDT24DI16_Source read GetData; default;

    { bakcall build }
    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT24DI16_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT24DI16_BuildMethod);
    procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT24DI16_BuildProc);
    { fill k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT24DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT24DI16_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT24DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT24DI16_BuildMethod); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT24DI16_BuildProc); overload;
    { search }
    function Search(const buff: TKDT24DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT24DI16_Node; overload;
    function Search(const buff: TKDT24DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT24DI16_Node; overload;
    function Search(const buff: TKDT24DI16_Vec; var SearchedDistanceMin: Double): PKDT24DI16_Node; overload;
    function Search(const buff: TKDT24DI16_Vec): PKDT24DI16_Node; overload;
    function SearchToken(const buff: TKDT24DI16_Vec): TPascalString;
    { parallel search }
    procedure Search(const inBuff: TKDT24DI16_DynamicVecBuffer; var OutBuff: TKDT24DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;
    procedure Search(const inBuff: TKDT24DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);
    procedure SaveToFile(FileName: SystemString);
    procedure LoadFromFile(FileName: SystemString);
    procedure PrintNodeTree(const NodePtr: PKDT24DI16_Node);
    procedure PrintBuffer;
    class function Vec(const s: SystemString): TKDT24DI16_Vec; overload;
    class function Vec(const v: TKDT24DI16_Vec): SystemString; overload;
    class function Distance(const v1, v2: TKDT24DI16_Vec): Double;
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT24DI16_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT48DI16 = class(TCoreClassObject)
  public type
    // code split
    TKDT48DI16_Vec = array [0 .. KDT48DI16_Axis - 1] of TKDT48DI16_VecType;
    PKDT48DI16_Vec = ^TKDT48DI16_Vec;

    TKDT48DI16_DynamicVecBuffer = array of TKDT48DI16_Vec;
    PKDT48DI16_DynamicVecBuffer = ^TKDT48DI16_DynamicVecBuffer;

    TKDT48DI16_Source = record
      buff: TKDT48DI16_Vec;
      Index: Int64;
      Token: TPascalString;
    end;

    PKDT48DI16_Source = ^TKDT48DI16_Source;
    TKDT48DI16_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT48DI16_Source) - 1] of PKDT48DI16_Source;
    PKDT48DI16_SourceBuffer = ^TKDT48DI16_SourceBuffer;

    TKDT48DI16_DyanmicSourceBuffer = array of PKDT48DI16_Source;
    PKDT48DI16_DyanmicSourceBuffer = ^TKDT48DI16_DyanmicSourceBuffer;

    TKDT48DI16_DyanmicStoreBuffer = array of TKDT48DI16_Source;
    PKDT48DI16_DyanmicStoreBuffer = ^TKDT48DI16_DyanmicStoreBuffer;

    PKDT48DI16_Node = ^TKDT48DI16_Node;

    TKDT48DI16_Node = record
      Parent, Right, Left: PKDT48DI16_Node;
      Vec: PKDT48DI16_Source;
    end;

    TKDT48DI16_BuildCall = procedure(const IndexFor: NativeInt; var Source: TKDT48DI16_Source; const Data: Pointer);
    TKDT48DI16_BuildMethod = procedure(const IndexFor: NativeInt; var Source: TKDT48DI16_Source; const Data: Pointer) of object;
{$IFDEF FPC}
    TKDT48DI16_BuildProc = procedure(const IndexFor: NativeInt; var Source: TKDT48DI16_Source; const Data: Pointer) is nested;
{$ELSE FPC}
    TKDT48DI16_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT48DI16_Source; const Data: Pointer);
{$ENDIF FPC}
  private
    KDStoreBuff: TKDT48DI16_DyanmicStoreBuffer;
    KDBuff: TKDT48DI16_DyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes: array of PKDT48DI16_Node;
    TestBuff: TKDT48DI16_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT48DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT48DI16_Node;
    function GetData(const Index: NativeInt): PKDT48DI16_Source;
  public
    RootNode: PKDT48DI16_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT48DI16_DyanmicStoreBuffer;
    property SourceP[const Index: NativeInt]: PKDT48DI16_Source read GetData; default;

    { bakcall build }
    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT48DI16_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT48DI16_BuildMethod);
    procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT48DI16_BuildProc);
    { fill k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT48DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT48DI16_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT48DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT48DI16_BuildMethod); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT48DI16_BuildProc); overload;
    { search }
    function Search(const buff: TKDT48DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT48DI16_Node; overload;
    function Search(const buff: TKDT48DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT48DI16_Node; overload;
    function Search(const buff: TKDT48DI16_Vec; var SearchedDistanceMin: Double): PKDT48DI16_Node; overload;
    function Search(const buff: TKDT48DI16_Vec): PKDT48DI16_Node; overload;
    function SearchToken(const buff: TKDT48DI16_Vec): TPascalString;
    { parallel search }
    procedure Search(const inBuff: TKDT48DI16_DynamicVecBuffer; var OutBuff: TKDT48DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;
    procedure Search(const inBuff: TKDT48DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);
    procedure SaveToFile(FileName: SystemString);
    procedure LoadFromFile(FileName: SystemString);
    procedure PrintNodeTree(const NodePtr: PKDT48DI16_Node);
    procedure PrintBuffer;
    class function Vec(const s: SystemString): TKDT48DI16_Vec; overload;
    class function Vec(const v: TKDT48DI16_Vec): SystemString; overload;
    class function Distance(const v1, v2: TKDT48DI16_Vec): Double;
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT48DI16_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT52DI16 = class(TCoreClassObject)
  public type
    // code split
    TKDT52DI16_Vec = array [0 .. KDT52DI16_Axis - 1] of TKDT52DI16_VecType;
    PKDT52DI16_Vec = ^TKDT52DI16_Vec;

    TKDT52DI16_DynamicVecBuffer = array of TKDT52DI16_Vec;
    PKDT52DI16_DynamicVecBuffer = ^TKDT52DI16_DynamicVecBuffer;

    TKDT52DI16_Source = record
      buff: TKDT52DI16_Vec;
      Index: Int64;
      Token: TPascalString;
    end;

    PKDT52DI16_Source = ^TKDT52DI16_Source;
    TKDT52DI16_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT52DI16_Source) - 1] of PKDT52DI16_Source;
    PKDT52DI16_SourceBuffer = ^TKDT52DI16_SourceBuffer;

    TKDT52DI16_DyanmicSourceBuffer = array of PKDT52DI16_Source;
    PKDT52DI16_DyanmicSourceBuffer = ^TKDT52DI16_DyanmicSourceBuffer;

    TKDT52DI16_DyanmicStoreBuffer = array of TKDT52DI16_Source;
    PKDT52DI16_DyanmicStoreBuffer = ^TKDT52DI16_DyanmicStoreBuffer;

    PKDT52DI16_Node = ^TKDT52DI16_Node;

    TKDT52DI16_Node = record
      Parent, Right, Left: PKDT52DI16_Node;
      Vec: PKDT52DI16_Source;
    end;

    TKDT52DI16_BuildCall = procedure(const IndexFor: NativeInt; var Source: TKDT52DI16_Source; const Data: Pointer);
    TKDT52DI16_BuildMethod = procedure(const IndexFor: NativeInt; var Source: TKDT52DI16_Source; const Data: Pointer) of object;
{$IFDEF FPC}
    TKDT52DI16_BuildProc = procedure(const IndexFor: NativeInt; var Source: TKDT52DI16_Source; const Data: Pointer) is nested;
{$ELSE FPC}
    TKDT52DI16_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT52DI16_Source; const Data: Pointer);
{$ENDIF FPC}
  private
    KDStoreBuff: TKDT52DI16_DyanmicStoreBuffer;
    KDBuff: TKDT52DI16_DyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes: array of PKDT52DI16_Node;
    TestBuff: TKDT52DI16_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT52DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT52DI16_Node;
    function GetData(const Index: NativeInt): PKDT52DI16_Source;
  public
    RootNode: PKDT52DI16_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT52DI16_DyanmicStoreBuffer;
    property SourceP[const Index: NativeInt]: PKDT52DI16_Source read GetData; default;

    { bakcall build }
    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT52DI16_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT52DI16_BuildMethod);
    procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT52DI16_BuildProc);
    { fill k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT52DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT52DI16_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT52DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT52DI16_BuildMethod); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT52DI16_BuildProc); overload;
    { search }
    function Search(const buff: TKDT52DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT52DI16_Node; overload;
    function Search(const buff: TKDT52DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT52DI16_Node; overload;
    function Search(const buff: TKDT52DI16_Vec; var SearchedDistanceMin: Double): PKDT52DI16_Node; overload;
    function Search(const buff: TKDT52DI16_Vec): PKDT52DI16_Node; overload;
    function SearchToken(const buff: TKDT52DI16_Vec): TPascalString;
    { parallel search }
    procedure Search(const inBuff: TKDT52DI16_DynamicVecBuffer; var OutBuff: TKDT52DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;
    procedure Search(const inBuff: TKDT52DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);
    procedure SaveToFile(FileName: SystemString);
    procedure LoadFromFile(FileName: SystemString);
    procedure PrintNodeTree(const NodePtr: PKDT52DI16_Node);
    procedure PrintBuffer;
    class function Vec(const s: SystemString): TKDT52DI16_Vec; overload;
    class function Vec(const v: TKDT52DI16_Vec): SystemString; overload;
    class function Distance(const v1, v2: TKDT52DI16_Vec): Double;
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT52DI16_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT64DI16 = class(TCoreClassObject)
  public type
    // code split
    TKDT64DI16_Vec = array [0 .. KDT64DI16_Axis - 1] of TKDT64DI16_VecType;
    PKDT64DI16_Vec = ^TKDT64DI16_Vec;

    TKDT64DI16_DynamicVecBuffer = array of TKDT64DI16_Vec;
    PKDT64DI16_DynamicVecBuffer = ^TKDT64DI16_DynamicVecBuffer;

    TKDT64DI16_Source = record
      buff: TKDT64DI16_Vec;
      Index: Int64;
      Token: TPascalString;
    end;

    PKDT64DI16_Source = ^TKDT64DI16_Source;
    TKDT64DI16_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT64DI16_Source) - 1] of PKDT64DI16_Source;
    PKDT64DI16_SourceBuffer = ^TKDT64DI16_SourceBuffer;

    TKDT64DI16_DyanmicSourceBuffer = array of PKDT64DI16_Source;
    PKDT64DI16_DyanmicSourceBuffer = ^TKDT64DI16_DyanmicSourceBuffer;

    TKDT64DI16_DyanmicStoreBuffer = array of TKDT64DI16_Source;
    PKDT64DI16_DyanmicStoreBuffer = ^TKDT64DI16_DyanmicStoreBuffer;

    PKDT64DI16_Node = ^TKDT64DI16_Node;

    TKDT64DI16_Node = record
      Parent, Right, Left: PKDT64DI16_Node;
      Vec: PKDT64DI16_Source;
    end;

    TKDT64DI16_BuildCall = procedure(const IndexFor: NativeInt; var Source: TKDT64DI16_Source; const Data: Pointer);
    TKDT64DI16_BuildMethod = procedure(const IndexFor: NativeInt; var Source: TKDT64DI16_Source; const Data: Pointer) of object;
{$IFDEF FPC}
    TKDT64DI16_BuildProc = procedure(const IndexFor: NativeInt; var Source: TKDT64DI16_Source; const Data: Pointer) is nested;
{$ELSE FPC}
    TKDT64DI16_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT64DI16_Source; const Data: Pointer);
{$ENDIF FPC}
  private
    KDStoreBuff: TKDT64DI16_DyanmicStoreBuffer;
    KDBuff: TKDT64DI16_DyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes: array of PKDT64DI16_Node;
    TestBuff: TKDT64DI16_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT64DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT64DI16_Node;
    function GetData(const Index: NativeInt): PKDT64DI16_Source;
  public
    RootNode: PKDT64DI16_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT64DI16_DyanmicStoreBuffer;
    property SourceP[const Index: NativeInt]: PKDT64DI16_Source read GetData; default;

    { bakcall build }
    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT64DI16_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT64DI16_BuildMethod);
    procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT64DI16_BuildProc);
    { fill k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT64DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT64DI16_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT64DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT64DI16_BuildMethod); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT64DI16_BuildProc); overload;
    { search }
    function Search(const buff: TKDT64DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT64DI16_Node; overload;
    function Search(const buff: TKDT64DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT64DI16_Node; overload;
    function Search(const buff: TKDT64DI16_Vec; var SearchedDistanceMin: Double): PKDT64DI16_Node; overload;
    function Search(const buff: TKDT64DI16_Vec): PKDT64DI16_Node; overload;
    function SearchToken(const buff: TKDT64DI16_Vec): TPascalString;
    { parallel search }
    procedure Search(const inBuff: TKDT64DI16_DynamicVecBuffer; var OutBuff: TKDT64DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;
    procedure Search(const inBuff: TKDT64DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);
    procedure SaveToFile(FileName: SystemString);
    procedure LoadFromFile(FileName: SystemString);
    procedure PrintNodeTree(const NodePtr: PKDT64DI16_Node);
    procedure PrintBuffer;
    class function Vec(const s: SystemString): TKDT64DI16_Vec; overload;
    class function Vec(const v: TKDT64DI16_Vec): SystemString; overload;
    class function Distance(const v1, v2: TKDT64DI16_Vec): Double;
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT64DI16_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT96DI16 = class(TCoreClassObject)
  public type
    // code split
    TKDT96DI16_Vec = array [0 .. KDT96DI16_Axis - 1] of TKDT96DI16_VecType;
    PKDT96DI16_Vec = ^TKDT96DI16_Vec;

    TKDT96DI16_DynamicVecBuffer = array of TKDT96DI16_Vec;
    PKDT96DI16_DynamicVecBuffer = ^TKDT96DI16_DynamicVecBuffer;

    TKDT96DI16_Source = record
      buff: TKDT96DI16_Vec;
      Index: Int64;
      Token: TPascalString;
    end;

    PKDT96DI16_Source = ^TKDT96DI16_Source;
    TKDT96DI16_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT96DI16_Source) - 1] of PKDT96DI16_Source;
    PKDT96DI16_SourceBuffer = ^TKDT96DI16_SourceBuffer;

    TKDT96DI16_DyanmicSourceBuffer = array of PKDT96DI16_Source;
    PKDT96DI16_DyanmicSourceBuffer = ^TKDT96DI16_DyanmicSourceBuffer;

    TKDT96DI16_DyanmicStoreBuffer = array of TKDT96DI16_Source;
    PKDT96DI16_DyanmicStoreBuffer = ^TKDT96DI16_DyanmicStoreBuffer;

    PKDT96DI16_Node = ^TKDT96DI16_Node;

    TKDT96DI16_Node = record
      Parent, Right, Left: PKDT96DI16_Node;
      Vec: PKDT96DI16_Source;
    end;

    TKDT96DI16_BuildCall = procedure(const IndexFor: NativeInt; var Source: TKDT96DI16_Source; const Data: Pointer);
    TKDT96DI16_BuildMethod = procedure(const IndexFor: NativeInt; var Source: TKDT96DI16_Source; const Data: Pointer) of object;
{$IFDEF FPC}
    TKDT96DI16_BuildProc = procedure(const IndexFor: NativeInt; var Source: TKDT96DI16_Source; const Data: Pointer) is nested;
{$ELSE FPC}
    TKDT96DI16_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT96DI16_Source; const Data: Pointer);
{$ENDIF FPC}
  private
    KDStoreBuff: TKDT96DI16_DyanmicStoreBuffer;
    KDBuff: TKDT96DI16_DyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes: array of PKDT96DI16_Node;
    TestBuff: TKDT96DI16_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT96DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT96DI16_Node;
    function GetData(const Index: NativeInt): PKDT96DI16_Source;
  public
    RootNode: PKDT96DI16_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT96DI16_DyanmicStoreBuffer;
    property SourceP[const Index: NativeInt]: PKDT96DI16_Source read GetData; default;

    { bakcall build }
    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT96DI16_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT96DI16_BuildMethod);
    procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT96DI16_BuildProc);
    { fill k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT96DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT96DI16_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT96DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT96DI16_BuildMethod); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT96DI16_BuildProc); overload;
    { search }
    function Search(const buff: TKDT96DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT96DI16_Node; overload;
    function Search(const buff: TKDT96DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT96DI16_Node; overload;
    function Search(const buff: TKDT96DI16_Vec; var SearchedDistanceMin: Double): PKDT96DI16_Node; overload;
    function Search(const buff: TKDT96DI16_Vec): PKDT96DI16_Node; overload;
    function SearchToken(const buff: TKDT96DI16_Vec): TPascalString;
    { parallel search }
    procedure Search(const inBuff: TKDT96DI16_DynamicVecBuffer; var OutBuff: TKDT96DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;
    procedure Search(const inBuff: TKDT96DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);
    procedure SaveToFile(FileName: SystemString);
    procedure LoadFromFile(FileName: SystemString);
    procedure PrintNodeTree(const NodePtr: PKDT96DI16_Node);
    procedure PrintBuffer;
    class function Vec(const s: SystemString): TKDT96DI16_Vec; overload;
    class function Vec(const v: TKDT96DI16_Vec): SystemString; overload;
    class function Distance(const v1, v2: TKDT96DI16_Vec): Double;
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT96DI16_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT128DI16 = class(TCoreClassObject)
  public type
    // code split
    TKDT128DI16_Vec = array [0 .. KDT128DI16_Axis - 1] of TKDT128DI16_VecType;
    PKDT128DI16_Vec = ^TKDT128DI16_Vec;

    TKDT128DI16_DynamicVecBuffer = array of TKDT128DI16_Vec;
    PKDT128DI16_DynamicVecBuffer = ^TKDT128DI16_DynamicVecBuffer;

    TKDT128DI16_Source = record
      buff: TKDT128DI16_Vec;
      Index: Int64;
      Token: TPascalString;
    end;

    PKDT128DI16_Source = ^TKDT128DI16_Source;
    TKDT128DI16_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT128DI16_Source) - 1] of PKDT128DI16_Source;
    PKDT128DI16_SourceBuffer = ^TKDT128DI16_SourceBuffer;

    TKDT128DI16_DyanmicSourceBuffer = array of PKDT128DI16_Source;
    PKDT128DI16_DyanmicSourceBuffer = ^TKDT128DI16_DyanmicSourceBuffer;

    TKDT128DI16_DyanmicStoreBuffer = array of TKDT128DI16_Source;
    PKDT128DI16_DyanmicStoreBuffer = ^TKDT128DI16_DyanmicStoreBuffer;

    PKDT128DI16_Node = ^TKDT128DI16_Node;

    TKDT128DI16_Node = record
      Parent, Right, Left: PKDT128DI16_Node;
      Vec: PKDT128DI16_Source;
    end;

    TKDT128DI16_BuildCall = procedure(const IndexFor: NativeInt; var Source: TKDT128DI16_Source; const Data: Pointer);
    TKDT128DI16_BuildMethod = procedure(const IndexFor: NativeInt; var Source: TKDT128DI16_Source; const Data: Pointer) of object;
{$IFDEF FPC}
    TKDT128DI16_BuildProc = procedure(const IndexFor: NativeInt; var Source: TKDT128DI16_Source; const Data: Pointer) is nested;
{$ELSE FPC}
    TKDT128DI16_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT128DI16_Source; const Data: Pointer);
{$ENDIF FPC}
  private
    KDStoreBuff: TKDT128DI16_DyanmicStoreBuffer;
    KDBuff: TKDT128DI16_DyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes: array of PKDT128DI16_Node;
    TestBuff: TKDT128DI16_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT128DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT128DI16_Node;
    function GetData(const Index: NativeInt): PKDT128DI16_Source;
  public
    RootNode: PKDT128DI16_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT128DI16_DyanmicStoreBuffer;
    property SourceP[const Index: NativeInt]: PKDT128DI16_Source read GetData; default;

    { bakcall build }
    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT128DI16_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT128DI16_BuildMethod);
    procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT128DI16_BuildProc);
    { fill k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT128DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT128DI16_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT128DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT128DI16_BuildMethod); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT128DI16_BuildProc); overload;
    { search }
    function Search(const buff: TKDT128DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT128DI16_Node; overload;
    function Search(const buff: TKDT128DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT128DI16_Node; overload;
    function Search(const buff: TKDT128DI16_Vec; var SearchedDistanceMin: Double): PKDT128DI16_Node; overload;
    function Search(const buff: TKDT128DI16_Vec): PKDT128DI16_Node; overload;
    function SearchToken(const buff: TKDT128DI16_Vec): TPascalString;
    { parallel search }
    procedure Search(const inBuff: TKDT128DI16_DynamicVecBuffer; var OutBuff: TKDT128DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;
    procedure Search(const inBuff: TKDT128DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);
    procedure SaveToFile(FileName: SystemString);
    procedure LoadFromFile(FileName: SystemString);
    procedure PrintNodeTree(const NodePtr: PKDT128DI16_Node);
    procedure PrintBuffer;
    class function Vec(const s: SystemString): TKDT128DI16_Vec; overload;
    class function Vec(const v: TKDT128DI16_Vec): SystemString; overload;
    class function Distance(const v1, v2: TKDT128DI16_Vec): Double;
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT128DI16_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT156DI16 = class(TCoreClassObject)
  public type
    // code split
    TKDT156DI16_Vec = array [0 .. KDT156DI16_Axis - 1] of TKDT156DI16_VecType;
    PKDT156DI16_Vec = ^TKDT156DI16_Vec;

    TKDT156DI16_DynamicVecBuffer = array of TKDT156DI16_Vec;
    PKDT156DI16_DynamicVecBuffer = ^TKDT156DI16_DynamicVecBuffer;

    TKDT156DI16_Source = record
      buff: TKDT156DI16_Vec;
      Index: Int64;
      Token: TPascalString;
    end;

    PKDT156DI16_Source = ^TKDT156DI16_Source;
    TKDT156DI16_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT156DI16_Source) - 1] of PKDT156DI16_Source;
    PKDT156DI16_SourceBuffer = ^TKDT156DI16_SourceBuffer;

    TKDT156DI16_DyanmicSourceBuffer = array of PKDT156DI16_Source;
    PKDT156DI16_DyanmicSourceBuffer = ^TKDT156DI16_DyanmicSourceBuffer;

    TKDT156DI16_DyanmicStoreBuffer = array of TKDT156DI16_Source;
    PKDT156DI16_DyanmicStoreBuffer = ^TKDT156DI16_DyanmicStoreBuffer;

    PKDT156DI16_Node = ^TKDT156DI16_Node;

    TKDT156DI16_Node = record
      Parent, Right, Left: PKDT156DI16_Node;
      Vec: PKDT156DI16_Source;
    end;

    TKDT156DI16_BuildCall = procedure(const IndexFor: NativeInt; var Source: TKDT156DI16_Source; const Data: Pointer);
    TKDT156DI16_BuildMethod = procedure(const IndexFor: NativeInt; var Source: TKDT156DI16_Source; const Data: Pointer) of object;
{$IFDEF FPC}
    TKDT156DI16_BuildProc = procedure(const IndexFor: NativeInt; var Source: TKDT156DI16_Source; const Data: Pointer) is nested;
{$ELSE FPC}
    TKDT156DI16_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT156DI16_Source; const Data: Pointer);
{$ENDIF FPC}
  private
    KDStoreBuff: TKDT156DI16_DyanmicStoreBuffer;
    KDBuff: TKDT156DI16_DyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes: array of PKDT156DI16_Node;
    TestBuff: TKDT156DI16_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT156DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT156DI16_Node;
    function GetData(const Index: NativeInt): PKDT156DI16_Source;
  public
    RootNode: PKDT156DI16_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT156DI16_DyanmicStoreBuffer;
    property SourceP[const Index: NativeInt]: PKDT156DI16_Source read GetData; default;

    { bakcall build }
    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT156DI16_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT156DI16_BuildMethod);
    procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT156DI16_BuildProc);
    { fill k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT156DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT156DI16_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT156DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT156DI16_BuildMethod); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT156DI16_BuildProc); overload;
    { search }
    function Search(const buff: TKDT156DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT156DI16_Node; overload;
    function Search(const buff: TKDT156DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT156DI16_Node; overload;
    function Search(const buff: TKDT156DI16_Vec; var SearchedDistanceMin: Double): PKDT156DI16_Node; overload;
    function Search(const buff: TKDT156DI16_Vec): PKDT156DI16_Node; overload;
    function SearchToken(const buff: TKDT156DI16_Vec): TPascalString;
    { parallel search }
    procedure Search(const inBuff: TKDT156DI16_DynamicVecBuffer; var OutBuff: TKDT156DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;
    procedure Search(const inBuff: TKDT156DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);
    procedure SaveToFile(FileName: SystemString);
    procedure LoadFromFile(FileName: SystemString);
    procedure PrintNodeTree(const NodePtr: PKDT156DI16_Node);
    procedure PrintBuffer;
    class function Vec(const s: SystemString): TKDT156DI16_Vec; overload;
    class function Vec(const v: TKDT156DI16_Vec): SystemString; overload;
    class function Distance(const v1, v2: TKDT156DI16_Vec): Double;
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT156DI16_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT192DI16 = class(TCoreClassObject)
  public type
    // code split
    TKDT192DI16_Vec = array [0 .. KDT192DI16_Axis - 1] of TKDT192DI16_VecType;
    PKDT192DI16_Vec = ^TKDT192DI16_Vec;

    TKDT192DI16_DynamicVecBuffer = array of TKDT192DI16_Vec;
    PKDT192DI16_DynamicVecBuffer = ^TKDT192DI16_DynamicVecBuffer;

    TKDT192DI16_Source = record
      buff: TKDT192DI16_Vec;
      Index: Int64;
      Token: TPascalString;
    end;

    PKDT192DI16_Source = ^TKDT192DI16_Source;
    TKDT192DI16_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT192DI16_Source) - 1] of PKDT192DI16_Source;
    PKDT192DI16_SourceBuffer = ^TKDT192DI16_SourceBuffer;

    TKDT192DI16_DyanmicSourceBuffer = array of PKDT192DI16_Source;
    PKDT192DI16_DyanmicSourceBuffer = ^TKDT192DI16_DyanmicSourceBuffer;

    TKDT192DI16_DyanmicStoreBuffer = array of TKDT192DI16_Source;
    PKDT192DI16_DyanmicStoreBuffer = ^TKDT192DI16_DyanmicStoreBuffer;

    PKDT192DI16_Node = ^TKDT192DI16_Node;

    TKDT192DI16_Node = record
      Parent, Right, Left: PKDT192DI16_Node;
      Vec: PKDT192DI16_Source;
    end;

    TKDT192DI16_BuildCall = procedure(const IndexFor: NativeInt; var Source: TKDT192DI16_Source; const Data: Pointer);
    TKDT192DI16_BuildMethod = procedure(const IndexFor: NativeInt; var Source: TKDT192DI16_Source; const Data: Pointer) of object;
{$IFDEF FPC}
    TKDT192DI16_BuildProc = procedure(const IndexFor: NativeInt; var Source: TKDT192DI16_Source; const Data: Pointer) is nested;
{$ELSE FPC}
    TKDT192DI16_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT192DI16_Source; const Data: Pointer);
{$ENDIF FPC}
  private
    KDStoreBuff: TKDT192DI16_DyanmicStoreBuffer;
    KDBuff: TKDT192DI16_DyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes: array of PKDT192DI16_Node;
    TestBuff: TKDT192DI16_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT192DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT192DI16_Node;
    function GetData(const Index: NativeInt): PKDT192DI16_Source;
  public
    RootNode: PKDT192DI16_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT192DI16_DyanmicStoreBuffer;
    property SourceP[const Index: NativeInt]: PKDT192DI16_Source read GetData; default;

    { bakcall build }
    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT192DI16_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT192DI16_BuildMethod);
    procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT192DI16_BuildProc);
    { fill k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT192DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT192DI16_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT192DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT192DI16_BuildMethod); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT192DI16_BuildProc); overload;
    { search }
    function Search(const buff: TKDT192DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT192DI16_Node; overload;
    function Search(const buff: TKDT192DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT192DI16_Node; overload;
    function Search(const buff: TKDT192DI16_Vec; var SearchedDistanceMin: Double): PKDT192DI16_Node; overload;
    function Search(const buff: TKDT192DI16_Vec): PKDT192DI16_Node; overload;
    function SearchToken(const buff: TKDT192DI16_Vec): TPascalString;
    { parallel search }
    procedure Search(const inBuff: TKDT192DI16_DynamicVecBuffer; var OutBuff: TKDT192DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;
    procedure Search(const inBuff: TKDT192DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);
    procedure SaveToFile(FileName: SystemString);
    procedure LoadFromFile(FileName: SystemString);
    procedure PrintNodeTree(const NodePtr: PKDT192DI16_Node);
    procedure PrintBuffer;
    class function Vec(const s: SystemString): TKDT192DI16_Vec; overload;
    class function Vec(const v: TKDT192DI16_Vec): SystemString; overload;
    class function Distance(const v1, v2: TKDT192DI16_Vec): Double;
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT192DI16_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT256DI16 = class(TCoreClassObject)
  public type
    // code split
    TKDT256DI16_Vec = array [0 .. KDT256DI16_Axis - 1] of TKDT256DI16_VecType;
    PKDT256DI16_Vec = ^TKDT256DI16_Vec;

    TKDT256DI16_DynamicVecBuffer = array of TKDT256DI16_Vec;
    PKDT256DI16_DynamicVecBuffer = ^TKDT256DI16_DynamicVecBuffer;

    TKDT256DI16_Source = record
      buff: TKDT256DI16_Vec;
      Index: Int64;
      Token: TPascalString;
    end;

    PKDT256DI16_Source = ^TKDT256DI16_Source;
    TKDT256DI16_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT256DI16_Source) - 1] of PKDT256DI16_Source;
    PKDT256DI16_SourceBuffer = ^TKDT256DI16_SourceBuffer;

    TKDT256DI16_DyanmicSourceBuffer = array of PKDT256DI16_Source;
    PKDT256DI16_DyanmicSourceBuffer = ^TKDT256DI16_DyanmicSourceBuffer;

    TKDT256DI16_DyanmicStoreBuffer = array of TKDT256DI16_Source;
    PKDT256DI16_DyanmicStoreBuffer = ^TKDT256DI16_DyanmicStoreBuffer;

    PKDT256DI16_Node = ^TKDT256DI16_Node;

    TKDT256DI16_Node = record
      Parent, Right, Left: PKDT256DI16_Node;
      Vec: PKDT256DI16_Source;
    end;

    TKDT256DI16_BuildCall = procedure(const IndexFor: NativeInt; var Source: TKDT256DI16_Source; const Data: Pointer);
    TKDT256DI16_BuildMethod = procedure(const IndexFor: NativeInt; var Source: TKDT256DI16_Source; const Data: Pointer) of object;
{$IFDEF FPC}
    TKDT256DI16_BuildProc = procedure(const IndexFor: NativeInt; var Source: TKDT256DI16_Source; const Data: Pointer) is nested;
{$ELSE FPC}
    TKDT256DI16_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT256DI16_Source; const Data: Pointer);
{$ENDIF FPC}
  private
    KDStoreBuff: TKDT256DI16_DyanmicStoreBuffer;
    KDBuff: TKDT256DI16_DyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes: array of PKDT256DI16_Node;
    TestBuff: TKDT256DI16_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT256DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT256DI16_Node;
    function GetData(const Index: NativeInt): PKDT256DI16_Source;
  public
    RootNode: PKDT256DI16_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT256DI16_DyanmicStoreBuffer;
    property SourceP[const Index: NativeInt]: PKDT256DI16_Source read GetData; default;

    { bakcall build }
    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT256DI16_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT256DI16_BuildMethod);
    procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT256DI16_BuildProc);
    { fill k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT256DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT256DI16_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT256DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT256DI16_BuildMethod); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT256DI16_BuildProc); overload;
    { search }
    function Search(const buff: TKDT256DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT256DI16_Node; overload;
    function Search(const buff: TKDT256DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT256DI16_Node; overload;
    function Search(const buff: TKDT256DI16_Vec; var SearchedDistanceMin: Double): PKDT256DI16_Node; overload;
    function Search(const buff: TKDT256DI16_Vec): PKDT256DI16_Node; overload;
    function SearchToken(const buff: TKDT256DI16_Vec): TPascalString;
    { parallel search }
    procedure Search(const inBuff: TKDT256DI16_DynamicVecBuffer; var OutBuff: TKDT256DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;
    procedure Search(const inBuff: TKDT256DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);
    procedure SaveToFile(FileName: SystemString);
    procedure LoadFromFile(FileName: SystemString);
    procedure PrintNodeTree(const NodePtr: PKDT256DI16_Node);
    procedure PrintBuffer;
    class function Vec(const s: SystemString): TKDT256DI16_Vec; overload;
    class function Vec(const v: TKDT256DI16_Vec): SystemString; overload;
    class function Distance(const v1, v2: TKDT256DI16_Vec): Double;
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT256DI16_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT384DI16 = class(TCoreClassObject)
  public type
    // code split
    TKDT384DI16_Vec = array [0 .. KDT384DI16_Axis - 1] of TKDT384DI16_VecType;
    PKDT384DI16_Vec = ^TKDT384DI16_Vec;

    TKDT384DI16_DynamicVecBuffer = array of TKDT384DI16_Vec;
    PKDT384DI16_DynamicVecBuffer = ^TKDT384DI16_DynamicVecBuffer;

    TKDT384DI16_Source = record
      buff: TKDT384DI16_Vec;
      Index: Int64;
      Token: TPascalString;
    end;

    PKDT384DI16_Source = ^TKDT384DI16_Source;
    TKDT384DI16_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT384DI16_Source) - 1] of PKDT384DI16_Source;
    PKDT384DI16_SourceBuffer = ^TKDT384DI16_SourceBuffer;

    TKDT384DI16_DyanmicSourceBuffer = array of PKDT384DI16_Source;
    PKDT384DI16_DyanmicSourceBuffer = ^TKDT384DI16_DyanmicSourceBuffer;

    TKDT384DI16_DyanmicStoreBuffer = array of TKDT384DI16_Source;
    PKDT384DI16_DyanmicStoreBuffer = ^TKDT384DI16_DyanmicStoreBuffer;

    PKDT384DI16_Node = ^TKDT384DI16_Node;

    TKDT384DI16_Node = record
      Parent, Right, Left: PKDT384DI16_Node;
      Vec: PKDT384DI16_Source;
    end;

    TKDT384DI16_BuildCall = procedure(const IndexFor: NativeInt; var Source: TKDT384DI16_Source; const Data: Pointer);
    TKDT384DI16_BuildMethod = procedure(const IndexFor: NativeInt; var Source: TKDT384DI16_Source; const Data: Pointer) of object;
{$IFDEF FPC}
    TKDT384DI16_BuildProc = procedure(const IndexFor: NativeInt; var Source: TKDT384DI16_Source; const Data: Pointer) is nested;
{$ELSE FPC}
    TKDT384DI16_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT384DI16_Source; const Data: Pointer);
{$ENDIF FPC}
  private
    KDStoreBuff: TKDT384DI16_DyanmicStoreBuffer;
    KDBuff: TKDT384DI16_DyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes: array of PKDT384DI16_Node;
    TestBuff: TKDT384DI16_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT384DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT384DI16_Node;
    function GetData(const Index: NativeInt): PKDT384DI16_Source;
  public
    RootNode: PKDT384DI16_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT384DI16_DyanmicStoreBuffer;
    property SourceP[const Index: NativeInt]: PKDT384DI16_Source read GetData; default;

    { bakcall build }
    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT384DI16_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT384DI16_BuildMethod);
    procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT384DI16_BuildProc);
    { fill k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT384DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT384DI16_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT384DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT384DI16_BuildMethod); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT384DI16_BuildProc); overload;
    { search }
    function Search(const buff: TKDT384DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT384DI16_Node; overload;
    function Search(const buff: TKDT384DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT384DI16_Node; overload;
    function Search(const buff: TKDT384DI16_Vec; var SearchedDistanceMin: Double): PKDT384DI16_Node; overload;
    function Search(const buff: TKDT384DI16_Vec): PKDT384DI16_Node; overload;
    function SearchToken(const buff: TKDT384DI16_Vec): TPascalString;
    { parallel search }
    procedure Search(const inBuff: TKDT384DI16_DynamicVecBuffer; var OutBuff: TKDT384DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;
    procedure Search(const inBuff: TKDT384DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);
    procedure SaveToFile(FileName: SystemString);
    procedure LoadFromFile(FileName: SystemString);
    procedure PrintNodeTree(const NodePtr: PKDT384DI16_Node);
    procedure PrintBuffer;
    class function Vec(const s: SystemString): TKDT384DI16_Vec; overload;
    class function Vec(const v: TKDT384DI16_Vec): SystemString; overload;
    class function Distance(const v1, v2: TKDT384DI16_Vec): Double;
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT384DI16_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT512DI16 = class(TCoreClassObject)
  public type
    // code split
    TKDT512DI16_Vec = array [0 .. KDT512DI16_Axis - 1] of TKDT512DI16_VecType;
    PKDT512DI16_Vec = ^TKDT512DI16_Vec;

    TKDT512DI16_DynamicVecBuffer = array of TKDT512DI16_Vec;
    PKDT512DI16_DynamicVecBuffer = ^TKDT512DI16_DynamicVecBuffer;

    TKDT512DI16_Source = record
      buff: TKDT512DI16_Vec;
      Index: Int64;
      Token: TPascalString;
    end;

    PKDT512DI16_Source = ^TKDT512DI16_Source;
    TKDT512DI16_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT512DI16_Source) - 1] of PKDT512DI16_Source;
    PKDT512DI16_SourceBuffer = ^TKDT512DI16_SourceBuffer;

    TKDT512DI16_DyanmicSourceBuffer = array of PKDT512DI16_Source;
    PKDT512DI16_DyanmicSourceBuffer = ^TKDT512DI16_DyanmicSourceBuffer;

    TKDT512DI16_DyanmicStoreBuffer = array of TKDT512DI16_Source;
    PKDT512DI16_DyanmicStoreBuffer = ^TKDT512DI16_DyanmicStoreBuffer;

    PKDT512DI16_Node = ^TKDT512DI16_Node;

    TKDT512DI16_Node = record
      Parent, Right, Left: PKDT512DI16_Node;
      Vec: PKDT512DI16_Source;
    end;

    TKDT512DI16_BuildCall = procedure(const IndexFor: NativeInt; var Source: TKDT512DI16_Source; const Data: Pointer);
    TKDT512DI16_BuildMethod = procedure(const IndexFor: NativeInt; var Source: TKDT512DI16_Source; const Data: Pointer) of object;
{$IFDEF FPC}
    TKDT512DI16_BuildProc = procedure(const IndexFor: NativeInt; var Source: TKDT512DI16_Source; const Data: Pointer) is nested;
{$ELSE FPC}
    TKDT512DI16_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT512DI16_Source; const Data: Pointer);
{$ENDIF FPC}
  private
    KDStoreBuff: TKDT512DI16_DyanmicStoreBuffer;
    KDBuff: TKDT512DI16_DyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes: array of PKDT512DI16_Node;
    TestBuff: TKDT512DI16_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT512DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT512DI16_Node;
    function GetData(const Index: NativeInt): PKDT512DI16_Source;
  public
    RootNode: PKDT512DI16_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT512DI16_DyanmicStoreBuffer;
    property SourceP[const Index: NativeInt]: PKDT512DI16_Source read GetData; default;

    { bakcall build }
    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT512DI16_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT512DI16_BuildMethod);
    procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT512DI16_BuildProc);
    { fill k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT512DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT512DI16_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT512DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT512DI16_BuildMethod); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT512DI16_BuildProc); overload;
    { search }
    function Search(const buff: TKDT512DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT512DI16_Node; overload;
    function Search(const buff: TKDT512DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT512DI16_Node; overload;
    function Search(const buff: TKDT512DI16_Vec; var SearchedDistanceMin: Double): PKDT512DI16_Node; overload;
    function Search(const buff: TKDT512DI16_Vec): PKDT512DI16_Node; overload;
    function SearchToken(const buff: TKDT512DI16_Vec): TPascalString;
    { parallel search }
    procedure Search(const inBuff: TKDT512DI16_DynamicVecBuffer; var OutBuff: TKDT512DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;
    procedure Search(const inBuff: TKDT512DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);
    procedure SaveToFile(FileName: SystemString);
    procedure LoadFromFile(FileName: SystemString);
    procedure PrintNodeTree(const NodePtr: PKDT512DI16_Node);
    procedure PrintBuffer;
    class function Vec(const s: SystemString): TKDT512DI16_Vec; overload;
    class function Vec(const v: TKDT512DI16_Vec): SystemString; overload;
    class function Distance(const v1, v2: TKDT512DI16_Vec): Double;
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT512DI16_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT800DI16 = class(TCoreClassObject)
  public type
    // code split
    TKDT800DI16_Vec = array [0 .. KDT800DI16_Axis - 1] of TKDT800DI16_VecType;
    PKDT800DI16_Vec = ^TKDT800DI16_Vec;

    TKDT800DI16_DynamicVecBuffer = array of TKDT800DI16_Vec;
    PKDT800DI16_DynamicVecBuffer = ^TKDT800DI16_DynamicVecBuffer;

    TKDT800DI16_Source = record
      buff: TKDT800DI16_Vec;
      Index: Int64;
      Token: TPascalString;
    end;

    PKDT800DI16_Source = ^TKDT800DI16_Source;
    TKDT800DI16_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT800DI16_Source) - 1] of PKDT800DI16_Source;
    PKDT800DI16_SourceBuffer = ^TKDT800DI16_SourceBuffer;

    TKDT800DI16_DyanmicSourceBuffer = array of PKDT800DI16_Source;
    PKDT800DI16_DyanmicSourceBuffer = ^TKDT800DI16_DyanmicSourceBuffer;

    TKDT800DI16_DyanmicStoreBuffer = array of TKDT800DI16_Source;
    PKDT800DI16_DyanmicStoreBuffer = ^TKDT800DI16_DyanmicStoreBuffer;

    PKDT800DI16_Node = ^TKDT800DI16_Node;

    TKDT800DI16_Node = record
      Parent, Right, Left: PKDT800DI16_Node;
      Vec: PKDT800DI16_Source;
    end;

    TKDT800DI16_BuildCall = procedure(const IndexFor: NativeInt; var Source: TKDT800DI16_Source; const Data: Pointer);
    TKDT800DI16_BuildMethod = procedure(const IndexFor: NativeInt; var Source: TKDT800DI16_Source; const Data: Pointer) of object;
{$IFDEF FPC}
    TKDT800DI16_BuildProc = procedure(const IndexFor: NativeInt; var Source: TKDT800DI16_Source; const Data: Pointer) is nested;
{$ELSE FPC}
    TKDT800DI16_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT800DI16_Source; const Data: Pointer);
{$ENDIF FPC}
  private
    KDStoreBuff: TKDT800DI16_DyanmicStoreBuffer;
    KDBuff: TKDT800DI16_DyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes: array of PKDT800DI16_Node;
    TestBuff: TKDT800DI16_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT800DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT800DI16_Node;
    function GetData(const Index: NativeInt): PKDT800DI16_Source;
  public
    RootNode: PKDT800DI16_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT800DI16_DyanmicStoreBuffer;
    property SourceP[const Index: NativeInt]: PKDT800DI16_Source read GetData; default;

    { bakcall build }
    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT800DI16_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT800DI16_BuildMethod);
    procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT800DI16_BuildProc);
    { fill k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT800DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT800DI16_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT800DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT800DI16_BuildMethod); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT800DI16_BuildProc); overload;
    { search }
    function Search(const buff: TKDT800DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT800DI16_Node; overload;
    function Search(const buff: TKDT800DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT800DI16_Node; overload;
    function Search(const buff: TKDT800DI16_Vec; var SearchedDistanceMin: Double): PKDT800DI16_Node; overload;
    function Search(const buff: TKDT800DI16_Vec): PKDT800DI16_Node; overload;
    function SearchToken(const buff: TKDT800DI16_Vec): TPascalString;
    { parallel search }
    procedure Search(const inBuff: TKDT800DI16_DynamicVecBuffer; var OutBuff: TKDT800DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;
    procedure Search(const inBuff: TKDT800DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);
    procedure SaveToFile(FileName: SystemString);
    procedure LoadFromFile(FileName: SystemString);
    procedure PrintNodeTree(const NodePtr: PKDT800DI16_Node);
    procedure PrintBuffer;
    class function Vec(const s: SystemString): TKDT800DI16_Vec; overload;
    class function Vec(const v: TKDT800DI16_Vec): SystemString; overload;
    class function Distance(const v1, v2: TKDT800DI16_Vec): Double;
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT800DI16_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT1024DI16 = class(TCoreClassObject)
  public type
    // code split
    TKDT1024DI16_Vec = array [0 .. KDT1024DI16_Axis - 1] of TKDT1024DI16_VecType;
    PKDT1024DI16_Vec = ^TKDT1024DI16_Vec;

    TKDT1024DI16_DynamicVecBuffer = array of TKDT1024DI16_Vec;
    PKDT1024DI16_DynamicVecBuffer = ^TKDT1024DI16_DynamicVecBuffer;

    TKDT1024DI16_Source = record
      buff: TKDT1024DI16_Vec;
      Index: Int64;
      Token: TPascalString;
    end;

    PKDT1024DI16_Source = ^TKDT1024DI16_Source;
    TKDT1024DI16_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT1024DI16_Source) - 1] of PKDT1024DI16_Source;
    PKDT1024DI16_SourceBuffer = ^TKDT1024DI16_SourceBuffer;

    TKDT1024DI16_DyanmicSourceBuffer = array of PKDT1024DI16_Source;
    PKDT1024DI16_DyanmicSourceBuffer = ^TKDT1024DI16_DyanmicSourceBuffer;

    TKDT1024DI16_DyanmicStoreBuffer = array of TKDT1024DI16_Source;
    PKDT1024DI16_DyanmicStoreBuffer = ^TKDT1024DI16_DyanmicStoreBuffer;

    PKDT1024DI16_Node = ^TKDT1024DI16_Node;

    TKDT1024DI16_Node = record
      Parent, Right, Left: PKDT1024DI16_Node;
      Vec: PKDT1024DI16_Source;
    end;

    TKDT1024DI16_BuildCall = procedure(const IndexFor: NativeInt; var Source: TKDT1024DI16_Source; const Data: Pointer);
    TKDT1024DI16_BuildMethod = procedure(const IndexFor: NativeInt; var Source: TKDT1024DI16_Source; const Data: Pointer) of object;
{$IFDEF FPC}
    TKDT1024DI16_BuildProc = procedure(const IndexFor: NativeInt; var Source: TKDT1024DI16_Source; const Data: Pointer) is nested;
{$ELSE FPC}
    TKDT1024DI16_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT1024DI16_Source; const Data: Pointer);
{$ENDIF FPC}
  private
    KDStoreBuff: TKDT1024DI16_DyanmicStoreBuffer;
    KDBuff: TKDT1024DI16_DyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes: array of PKDT1024DI16_Node;
    TestBuff: TKDT1024DI16_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT1024DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1024DI16_Node;
    function GetData(const Index: NativeInt): PKDT1024DI16_Source;
  public
    RootNode: PKDT1024DI16_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT1024DI16_DyanmicStoreBuffer;
    property SourceP[const Index: NativeInt]: PKDT1024DI16_Source read GetData; default;

    { bakcall build }
    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1024DI16_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1024DI16_BuildMethod);
    procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1024DI16_BuildProc);
    { fill k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1024DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1024DI16_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT1024DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT1024DI16_BuildMethod); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT1024DI16_BuildProc); overload;
    { search }
    function Search(const buff: TKDT1024DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1024DI16_Node; overload;
    function Search(const buff: TKDT1024DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1024DI16_Node; overload;
    function Search(const buff: TKDT1024DI16_Vec; var SearchedDistanceMin: Double): PKDT1024DI16_Node; overload;
    function Search(const buff: TKDT1024DI16_Vec): PKDT1024DI16_Node; overload;
    function SearchToken(const buff: TKDT1024DI16_Vec): TPascalString;
    { parallel search }
    procedure Search(const inBuff: TKDT1024DI16_DynamicVecBuffer; var OutBuff: TKDT1024DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;
    procedure Search(const inBuff: TKDT1024DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);
    procedure SaveToFile(FileName: SystemString);
    procedure LoadFromFile(FileName: SystemString);
    procedure PrintNodeTree(const NodePtr: PKDT1024DI16_Node);
    procedure PrintBuffer;
    class function Vec(const s: SystemString): TKDT1024DI16_Vec; overload;
    class function Vec(const v: TKDT1024DI16_Vec): SystemString; overload;
    class function Distance(const v1, v2: TKDT1024DI16_Vec): Double;
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT1024DI16_Source; const Data: Pointer);
    class procedure Test;
  end;






procedure Test_All;



implementation

uses
  TextParsing, MemoryStream64, DoStatusIO;





const
  SaveToken = $77;


function TKDT1DI16.InternalBuildKdTree(const KDSourceBufferPtr: PKDT1DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1DI16_Node;
  function SortCompare(const p1, p2: PKDT1DI16_Source; const axis: NativeInt): ShortInt;
  begin
    if p1^.buff[axis] = p2^.buff[axis] then
      begin
        if p1^.Index = p2^.Index then
            Result := 0
        else if p1^.Index < p2^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.buff[axis] < p2^.buff[axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT1DI16_SourceBuffer; L, R: NativeInt; const axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT1DI16_Source;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer^[(L + R) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, axis) < 0 do
            Inc(i);
        while SortCompare(SortBuffer^[j], p, axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, axis);
      L := i;
    until i >= R;
  end;

var
  M: NativeInt;
  axis: NativeInt;
  kdBuffPtr: PKDT1DI16_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      new(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.Vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);
    end
  else
    begin
      axis := Depth mod KDT1DI16_Axis;
      M := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr^[0], 0, PlanCount - 1, axis);

      new(Result);
      Result^.Parent := nil;
      Result^.Vec := kdBuffPtr^[M];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], M, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[M + 1], PlanCount - (M + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT1DI16.GetData(const Index: NativeInt): PKDT1DI16_Source;
begin
  Result := @KDStoreBuff[Index];
end;

constructor TKDT1DI16.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT1DI16.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT1DI16.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT1DI16_Node(KDNodes[i]));
      Inc(i);
    end;

  for i := 0 to length(KDStoreBuff) - 1 do
      KDStoreBuff[i].Token := '';

  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT1DI16.StoreBuffPtr: PKDT1DI16_DyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT1DI16.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1DI16_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT1DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT1DI16.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1DI16_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT1DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT1DI16.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1DI16_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT1DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{ k-means++ clusterization }
procedure TKDT1DI16.BuildKDTreeWithCluster(const inBuff: TKDT1DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  SetLength(Source, length(inBuff), KDT1DI16_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT1DI16_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT1DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT1DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT1DI16.BuildKDTreeWithCluster(const inBuff: TKDT1DI16_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TKMIntegerArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT1DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT1DI16_BuildCall);
var
  TempStoreBuff: TKDT1DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT1DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT1DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT1DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT1DI16_BuildMethod);
var
  TempStoreBuff: TKDT1DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT1DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT1DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT1DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT1DI16_BuildProc);
var
  TempStoreBuff: TKDT1DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT1DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT1DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT1DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

function TKDT1DI16.Search(const buff: TKDT1DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1DI16_Node;

var
  NearestNeighbour: PKDT1DI16_Node;

  function FindParentNode(const buffPtr: PKDT1DI16_Vec; NodePtr: PKDT1DI16_Node): PKDT1DI16_Node;
  var
    Next: PKDT1DI16_Node;
    Depth, axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        axis := Depth mod KDT1DI16_Axis;
        if buffPtr^[axis] > Next^.Vec^.buff[axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT1DI16_Node; const buffPtr: PKDT1DI16_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    Inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := Distance(buffPtr^, NodePtr^.Vec^.buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.Vec^.Index < NearestNeighbour^.Vec^.Index) then
        NearestNeighbour := NodePtr;

    axis := Depth mod KDT1DI16_Axis;
    Dist := NodePtr^.Vec^.buff[axis] - buffPtr^[axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.Vec^.buff[axis] > buffPtr^[axis] then
            ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const buffPtr: PKDT1DI16_Vec; const p1, p2: PKDT1DI16_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := Distance(buffPtr^, p1^.Vec^.buff);
    d2 := Distance(buffPtr^, p2^.Vec^.buff);
    if d1 = d2 then
      begin
        if p1^.Vec^.Index = p2^.Vec^.Index then
            Result := 0
        else if p1^.Vec^.Index < p2^.Vec^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; L, R: NativeInt; const buffPtr: PKDT1DI16_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT1DI16_Node;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer[(L + R) shr 1];
      repeat
        while SortCompare(buffPtr, SortBuffer[i], p) < 0 do
            Inc(i);
        while SortCompare(buffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, buffPtr);
      L := i;
    until i >= R;
  end;

var
  Parent: PKDT1DI16_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := Distance(buff, Parent^.Vec^.buff);

  ScanSubtree(RootNode, @buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT1DI16_Node(NearestNodes[0]);
    end;
end;

function TKDT1DI16.Search(const buff: TKDT1DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1DI16_Node;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT1DI16.Search(const buff: TKDT1DI16_Vec; var SearchedDistanceMin: Double): PKDT1DI16_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT1DI16.Search(const buff: TKDT1DI16_Vec): PKDT1DI16_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT1DI16.SearchToken(const buff: TKDT1DI16_Vec): TPascalString;
var
  p: PKDT1DI16_Node;
begin
  p := Search(buff);
  if p <> nil then
      Result := p^.Vec^.Token
  else
      Result := '';
end;

procedure TKDT1DI16.Search(const inBuff: TKDT1DI16_DynamicVecBuffer; var OutBuff: TKDT1DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT1DI16_DynamicVecBuffer;
  outBuffPtr: PKDT1DI16_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT1DI16_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outBuffPtr^[pass] := p^.Vec^.buff;
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT1DI16_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outBuffPtr^[pass] := p^.Vec^.buff;
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1DI16_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.Vec^.buff;
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1DI16.Search(const inBuff: TKDT1DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT1DI16_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT1DI16_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT1DI16_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1DI16_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1DI16.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  ID := KDT1DI16_Axis;

  stream.write(st, 4);
  stream.write(ID, 4);

  stream.write(cnt, 8);

  i := 0;
  while i < cnt do
    begin
      stream.write(KDStoreBuff[i].buff[0], SizeOf(TKDT1DI16_Vec));
      stream.write(KDStoreBuff[i].Index, 8);
      token_B := KDStoreBuff[i].Token.Bytes;
      token_L := length(token_B);
      stream.write(token_L, 4);
      if token_L > 0 then
        begin
          stream.write(token_B[0], token_L);
          SetLength(token_B, 0);
        end;
      Inc(i);
    end;
end;

procedure TKDT1DI16.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  Clear;

  stream.read(st, 4);
  stream.read(ID, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if ID <> KDT1DI16_Axis then
      RaiseInfo('kdtree axis error!');

  stream.read(cnt, 8);

  SetLength(KDStoreBuff, cnt);

  i := 0;
  try
    while i < cnt do
      begin
        if stream.read(KDStoreBuff[i].buff[0], SizeOf(TKDT1DI16_Vec)) <> SizeOf(TKDT1DI16_Vec) then
          begin
            Clear;
            Exit;
          end;
        if stream.read(KDStoreBuff[i].Index, 8) <> 8 then
          begin
            Clear;
            Exit;
          end;
        if stream.read(token_L, 4) <> 4 then
          begin
            Clear;
            Exit;
          end;
        if token_L > 0 then
          begin
            SetLength(token_B, token_L);
            if stream.read(token_B[0], token_L) <> token_L then
              begin
                Clear;
                Exit;
              end;
            KDStoreBuff[i].Token.Bytes := token_B;
            SetLength(token_B, 0);
          end
        else
            KDStoreBuff[i].Token := '';
        Inc(i);
      end;
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      Inc(i);
    end;

  if cnt > 0 then
      RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT1DI16.SaveToFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(FileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1DI16.LoadFromFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1DI16.PrintNodeTree(const NodePtr: PKDT1DI16_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT1DI16_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.Vec^.Index, Vec(p^.Vec^.buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT1DI16.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d - %d : %s ', [i, KDStoreBuff[i].Index, Vec(KDStoreBuff[i].buff)]);
end;

class function TKDT1DI16.Vec(const s: SystemString): TKDT1DI16_Vec;
var
  t: TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j: NativeInt;
begin
  for i := 0 to KDT1DI16_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            Inc(j);
            if j >= KDT1DI16_Axis then
                Break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT1DI16.Vec(const v: TKDT1DI16_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT1DI16_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT1DI16.Distance(const v1, v2: TKDT1DI16_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT1DI16_Axis - 1 do
      Result := Result + (v2[i] - v1[i]) * (v2[i] - v1[i]);
end;

procedure TKDT1DI16.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT1DI16_Source; const Data: Pointer);
begin
  Source.buff := TestBuff[IndexFor];
  Source.Token := umlIntToStr(IndexFor);
end;

class procedure TKDT1DI16.Test;
var
  TKDT1DI16_Test: TKDT1DI16;
  t: TTimeTick;
  i, j: NativeInt;
  TestResultBuff: TKDT1DI16_DynamicVecBuffer;
  TestResultIndex: TKMIntegerArray;
  KMeanOutIndex: TKMIntegerArray;
  errored: Boolean;
  m64: TMemoryStream64;
  p: PKDT1DI16_Node;
  n: TPascalString;
begin
  errored := False;
  n := PFormat('test %s...', [ClassName]);
  t := GetTimeTick;

  n.Append('...build');
  TKDT1DI16_Test := TKDT1DI16.Create;

  n.Append('...');
  SetLength(TKDT1DI16_Test.TestBuff, 1000);
  for i := 0 to length(TKDT1DI16_Test.TestBuff) - 1 do
    for j := 0 to KDT1DI16_Axis - 1 do
        TKDT1DI16_Test.TestBuff[i][j] := i * KDT1DI16_Axis + j;

{$IFDEF FPC}
  TKDT1DI16_Test.BuildKDTreeM(length(TKDT1DI16_Test.TestBuff), nil, @TKDT1DI16_Test.Test_BuildM);
{$ELSE FPC}
  TKDT1DI16_Test.BuildKDTreeM(length(TKDT1DI16_Test.TestBuff), nil, TKDT1DI16_Test.Test_BuildM);
{$ENDIF FPC}
  { save/load test }
  n.Append('...save/load');
  m64 := TMemoryStream64.CustomCreate(1024 * 1024);
  TKDT1DI16_Test.SaveToStream(m64);
  m64.Position := 0;
  TKDT1DI16_Test.LoadFromStream(m64);
  for i := 0 to length(TKDT1DI16_Test.TestBuff) - 1 do
    begin
      p := TKDT1DI16_Test.Search(TKDT1DI16_Test.TestBuff[i]);
      if p^.Vec^.Index <> i then
          errored := True;
      if not p^.Vec^.Token.Same(umlIntToStr(i)) then
          errored := True;
      if errored then
          Break;
    end;
  DisposeObject(m64);

  if not errored then
    begin
      { parallel search test }
      n.Append('...parallel');
      SetLength(TestResultBuff, length(TKDT1DI16_Test.TestBuff));
      SetLength(TestResultIndex, length(TKDT1DI16_Test.TestBuff));
      TKDT1DI16_Test.Search(TKDT1DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if Distance(TKDT1DI16_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
            errored := True;
    end;

  if not errored then
    begin
      n.Append('...kMean');
      TKDT1DI16_Test.Clear;
      { kMean test }
      TKDT1DI16_Test.BuildKDTreeWithCluster(TKDT1DI16_Test.TestBuff, 10, 1, KMeanOutIndex);
      { parallel search test }
      TKDT1DI16_Test.Search(TKDT1DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if TestResultIndex[i] <> KMeanOutIndex[i] then
            errored := True;
    end;

  SetLength(TKDT1DI16_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT1DI16_Test.Clear;

  n.Append('...');
  if errored then
      n.Append('error!')
  else
      n.Append('passed ok %dms', [GetTimeTick - t]);
  DisposeObject(TKDT1DI16_Test);
  DoStatus(n);
  n := '';
end;

function TKDT2DI16.InternalBuildKdTree(const KDSourceBufferPtr: PKDT2DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT2DI16_Node;
  function SortCompare(const p1, p2: PKDT2DI16_Source; const axis: NativeInt): ShortInt;
  begin
    if p1^.buff[axis] = p2^.buff[axis] then
      begin
        if p1^.Index = p2^.Index then
            Result := 0
        else if p1^.Index < p2^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.buff[axis] < p2^.buff[axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT2DI16_SourceBuffer; L, R: NativeInt; const axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT2DI16_Source;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer^[(L + R) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, axis) < 0 do
            Inc(i);
        while SortCompare(SortBuffer^[j], p, axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, axis);
      L := i;
    until i >= R;
  end;

var
  M: NativeInt;
  axis: NativeInt;
  kdBuffPtr: PKDT2DI16_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      new(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.Vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);
    end
  else
    begin
      axis := Depth mod KDT2DI16_Axis;
      M := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr^[0], 0, PlanCount - 1, axis);

      new(Result);
      Result^.Parent := nil;
      Result^.Vec := kdBuffPtr^[M];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], M, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[M + 1], PlanCount - (M + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT2DI16.GetData(const Index: NativeInt): PKDT2DI16_Source;
begin
  Result := @KDStoreBuff[Index];
end;

constructor TKDT2DI16.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT2DI16.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT2DI16.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT2DI16_Node(KDNodes[i]));
      Inc(i);
    end;

  for i := 0 to length(KDStoreBuff) - 1 do
      KDStoreBuff[i].Token := '';

  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT2DI16.StoreBuffPtr: PKDT2DI16_DyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT2DI16.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT2DI16_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT2DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT2DI16.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT2DI16_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT2DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT2DI16.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT2DI16_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT2DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{ k-means++ clusterization }
procedure TKDT2DI16.BuildKDTreeWithCluster(const inBuff: TKDT2DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  SetLength(Source, length(inBuff), KDT2DI16_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT2DI16_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT2DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT2DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT2DI16.BuildKDTreeWithCluster(const inBuff: TKDT2DI16_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TKMIntegerArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT2DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT2DI16_BuildCall);
var
  TempStoreBuff: TKDT2DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT2DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT2DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT2DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT2DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT2DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT2DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT2DI16_BuildMethod);
var
  TempStoreBuff: TKDT2DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT2DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT2DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT2DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT2DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT2DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT2DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT2DI16_BuildProc);
var
  TempStoreBuff: TKDT2DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT2DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT2DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT2DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT2DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT2DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

function TKDT2DI16.Search(const buff: TKDT2DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT2DI16_Node;

var
  NearestNeighbour: PKDT2DI16_Node;

  function FindParentNode(const buffPtr: PKDT2DI16_Vec; NodePtr: PKDT2DI16_Node): PKDT2DI16_Node;
  var
    Next: PKDT2DI16_Node;
    Depth, axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        axis := Depth mod KDT2DI16_Axis;
        if buffPtr^[axis] > Next^.Vec^.buff[axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT2DI16_Node; const buffPtr: PKDT2DI16_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    Inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := Distance(buffPtr^, NodePtr^.Vec^.buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.Vec^.Index < NearestNeighbour^.Vec^.Index) then
        NearestNeighbour := NodePtr;

    axis := Depth mod KDT2DI16_Axis;
    Dist := NodePtr^.Vec^.buff[axis] - buffPtr^[axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.Vec^.buff[axis] > buffPtr^[axis] then
            ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const buffPtr: PKDT2DI16_Vec; const p1, p2: PKDT2DI16_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := Distance(buffPtr^, p1^.Vec^.buff);
    d2 := Distance(buffPtr^, p2^.Vec^.buff);
    if d1 = d2 then
      begin
        if p1^.Vec^.Index = p2^.Vec^.Index then
            Result := 0
        else if p1^.Vec^.Index < p2^.Vec^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; L, R: NativeInt; const buffPtr: PKDT2DI16_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT2DI16_Node;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer[(L + R) shr 1];
      repeat
        while SortCompare(buffPtr, SortBuffer[i], p) < 0 do
            Inc(i);
        while SortCompare(buffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, buffPtr);
      L := i;
    until i >= R;
  end;

var
  Parent: PKDT2DI16_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := Distance(buff, Parent^.Vec^.buff);

  ScanSubtree(RootNode, @buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT2DI16_Node(NearestNodes[0]);
    end;
end;

function TKDT2DI16.Search(const buff: TKDT2DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT2DI16_Node;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT2DI16.Search(const buff: TKDT2DI16_Vec; var SearchedDistanceMin: Double): PKDT2DI16_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT2DI16.Search(const buff: TKDT2DI16_Vec): PKDT2DI16_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT2DI16.SearchToken(const buff: TKDT2DI16_Vec): TPascalString;
var
  p: PKDT2DI16_Node;
begin
  p := Search(buff);
  if p <> nil then
      Result := p^.Vec^.Token
  else
      Result := '';
end;

procedure TKDT2DI16.Search(const inBuff: TKDT2DI16_DynamicVecBuffer; var OutBuff: TKDT2DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT2DI16_DynamicVecBuffer;
  outBuffPtr: PKDT2DI16_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT2DI16_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outBuffPtr^[pass] := p^.Vec^.buff;
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT2DI16_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outBuffPtr^[pass] := p^.Vec^.buff;
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT2DI16_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.Vec^.buff;
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT2DI16.Search(const inBuff: TKDT2DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT2DI16_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT2DI16_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT2DI16_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT2DI16_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT2DI16.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  ID := KDT2DI16_Axis;

  stream.write(st, 4);
  stream.write(ID, 4);

  stream.write(cnt, 8);

  i := 0;
  while i < cnt do
    begin
      stream.write(KDStoreBuff[i].buff[0], SizeOf(TKDT2DI16_Vec));
      stream.write(KDStoreBuff[i].Index, 8);
      token_B := KDStoreBuff[i].Token.Bytes;
      token_L := length(token_B);
      stream.write(token_L, 4);
      if token_L > 0 then
        begin
          stream.write(token_B[0], token_L);
          SetLength(token_B, 0);
        end;
      Inc(i);
    end;
end;

procedure TKDT2DI16.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  Clear;

  stream.read(st, 4);
  stream.read(ID, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if ID <> KDT2DI16_Axis then
      RaiseInfo('kdtree axis error!');

  stream.read(cnt, 8);

  SetLength(KDStoreBuff, cnt);

  i := 0;
  try
    while i < cnt do
      begin
        if stream.read(KDStoreBuff[i].buff[0], SizeOf(TKDT2DI16_Vec)) <> SizeOf(TKDT2DI16_Vec) then
          begin
            Clear;
            Exit;
          end;
        if stream.read(KDStoreBuff[i].Index, 8) <> 8 then
          begin
            Clear;
            Exit;
          end;
        if stream.read(token_L, 4) <> 4 then
          begin
            Clear;
            Exit;
          end;
        if token_L > 0 then
          begin
            SetLength(token_B, token_L);
            if stream.read(token_B[0], token_L) <> token_L then
              begin
                Clear;
                Exit;
              end;
            KDStoreBuff[i].Token.Bytes := token_B;
            SetLength(token_B, 0);
          end
        else
            KDStoreBuff[i].Token := '';
        Inc(i);
      end;
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      Inc(i);
    end;

  if cnt > 0 then
      RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT2DI16.SaveToFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(FileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT2DI16.LoadFromFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT2DI16.PrintNodeTree(const NodePtr: PKDT2DI16_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT2DI16_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.Vec^.Index, Vec(p^.Vec^.buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT2DI16.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d - %d : %s ', [i, KDStoreBuff[i].Index, Vec(KDStoreBuff[i].buff)]);
end;

class function TKDT2DI16.Vec(const s: SystemString): TKDT2DI16_Vec;
var
  t: TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j: NativeInt;
begin
  for i := 0 to KDT2DI16_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            Inc(j);
            if j >= KDT2DI16_Axis then
                Break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT2DI16.Vec(const v: TKDT2DI16_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT2DI16_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT2DI16.Distance(const v1, v2: TKDT2DI16_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT2DI16_Axis - 1 do
      Result := Result + (v2[i] - v1[i]) * (v2[i] - v1[i]);
end;

procedure TKDT2DI16.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT2DI16_Source; const Data: Pointer);
begin
  Source.buff := TestBuff[IndexFor];
  Source.Token := umlIntToStr(IndexFor);
end;

class procedure TKDT2DI16.Test;
var
  TKDT2DI16_Test: TKDT2DI16;
  t: TTimeTick;
  i, j: NativeInt;
  TestResultBuff: TKDT2DI16_DynamicVecBuffer;
  TestResultIndex: TKMIntegerArray;
  KMeanOutIndex: TKMIntegerArray;
  errored: Boolean;
  m64: TMemoryStream64;
  p: PKDT2DI16_Node;
  n: TPascalString;
begin
  errored := False;
  n := PFormat('test %s...', [ClassName]);
  t := GetTimeTick;

  n.Append('...build');
  TKDT2DI16_Test := TKDT2DI16.Create;

  n.Append('...');
  SetLength(TKDT2DI16_Test.TestBuff, 1000);
  for i := 0 to length(TKDT2DI16_Test.TestBuff) - 1 do
    for j := 0 to KDT2DI16_Axis - 1 do
        TKDT2DI16_Test.TestBuff[i][j] := i * KDT2DI16_Axis + j;

{$IFDEF FPC}
  TKDT2DI16_Test.BuildKDTreeM(length(TKDT2DI16_Test.TestBuff), nil, @TKDT2DI16_Test.Test_BuildM);
{$ELSE FPC}
  TKDT2DI16_Test.BuildKDTreeM(length(TKDT2DI16_Test.TestBuff), nil, TKDT2DI16_Test.Test_BuildM);
{$ENDIF FPC}
  { save/load test }
  n.Append('...save/load');
  m64 := TMemoryStream64.CustomCreate(1024 * 1024);
  TKDT2DI16_Test.SaveToStream(m64);
  m64.Position := 0;
  TKDT2DI16_Test.LoadFromStream(m64);
  for i := 0 to length(TKDT2DI16_Test.TestBuff) - 1 do
    begin
      p := TKDT2DI16_Test.Search(TKDT2DI16_Test.TestBuff[i]);
      if p^.Vec^.Index <> i then
          errored := True;
      if not p^.Vec^.Token.Same(umlIntToStr(i)) then
          errored := True;
      if errored then
          Break;
    end;
  DisposeObject(m64);

  if not errored then
    begin
      { parallel search test }
      n.Append('...parallel');
      SetLength(TestResultBuff, length(TKDT2DI16_Test.TestBuff));
      SetLength(TestResultIndex, length(TKDT2DI16_Test.TestBuff));
      TKDT2DI16_Test.Search(TKDT2DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if Distance(TKDT2DI16_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
            errored := True;
    end;

  if not errored then
    begin
      n.Append('...kMean');
      TKDT2DI16_Test.Clear;
      { kMean test }
      TKDT2DI16_Test.BuildKDTreeWithCluster(TKDT2DI16_Test.TestBuff, 10, 1, KMeanOutIndex);
      { parallel search test }
      TKDT2DI16_Test.Search(TKDT2DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if TestResultIndex[i] <> KMeanOutIndex[i] then
            errored := True;
    end;

  SetLength(TKDT2DI16_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT2DI16_Test.Clear;

  n.Append('...');
  if errored then
      n.Append('error!')
  else
      n.Append('passed ok %dms', [GetTimeTick - t]);
  DisposeObject(TKDT2DI16_Test);
  DoStatus(n);
  n := '';
end;

function TKDT3DI16.InternalBuildKdTree(const KDSourceBufferPtr: PKDT3DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT3DI16_Node;
  function SortCompare(const p1, p2: PKDT3DI16_Source; const axis: NativeInt): ShortInt;
  begin
    if p1^.buff[axis] = p2^.buff[axis] then
      begin
        if p1^.Index = p2^.Index then
            Result := 0
        else if p1^.Index < p2^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.buff[axis] < p2^.buff[axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT3DI16_SourceBuffer; L, R: NativeInt; const axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT3DI16_Source;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer^[(L + R) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, axis) < 0 do
            Inc(i);
        while SortCompare(SortBuffer^[j], p, axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, axis);
      L := i;
    until i >= R;
  end;

var
  M: NativeInt;
  axis: NativeInt;
  kdBuffPtr: PKDT3DI16_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      new(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.Vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);
    end
  else
    begin
      axis := Depth mod KDT3DI16_Axis;
      M := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr^[0], 0, PlanCount - 1, axis);

      new(Result);
      Result^.Parent := nil;
      Result^.Vec := kdBuffPtr^[M];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], M, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[M + 1], PlanCount - (M + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT3DI16.GetData(const Index: NativeInt): PKDT3DI16_Source;
begin
  Result := @KDStoreBuff[Index];
end;

constructor TKDT3DI16.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT3DI16.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT3DI16.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT3DI16_Node(KDNodes[i]));
      Inc(i);
    end;

  for i := 0 to length(KDStoreBuff) - 1 do
      KDStoreBuff[i].Token := '';

  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT3DI16.StoreBuffPtr: PKDT3DI16_DyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT3DI16.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3DI16_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT3DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT3DI16.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3DI16_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT3DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT3DI16.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3DI16_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT3DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{ k-means++ clusterization }
procedure TKDT3DI16.BuildKDTreeWithCluster(const inBuff: TKDT3DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  SetLength(Source, length(inBuff), KDT3DI16_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT3DI16_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT3DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT3DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT3DI16.BuildKDTreeWithCluster(const inBuff: TKDT3DI16_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TKMIntegerArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT3DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT3DI16_BuildCall);
var
  TempStoreBuff: TKDT3DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT3DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT3DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT3DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT3DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT3DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT3DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT3DI16_BuildMethod);
var
  TempStoreBuff: TKDT3DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT3DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT3DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT3DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT3DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT3DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT3DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT3DI16_BuildProc);
var
  TempStoreBuff: TKDT3DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT3DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT3DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT3DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT3DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT3DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

function TKDT3DI16.Search(const buff: TKDT3DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT3DI16_Node;

var
  NearestNeighbour: PKDT3DI16_Node;

  function FindParentNode(const buffPtr: PKDT3DI16_Vec; NodePtr: PKDT3DI16_Node): PKDT3DI16_Node;
  var
    Next: PKDT3DI16_Node;
    Depth, axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        axis := Depth mod KDT3DI16_Axis;
        if buffPtr^[axis] > Next^.Vec^.buff[axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT3DI16_Node; const buffPtr: PKDT3DI16_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    Inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := Distance(buffPtr^, NodePtr^.Vec^.buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.Vec^.Index < NearestNeighbour^.Vec^.Index) then
        NearestNeighbour := NodePtr;

    axis := Depth mod KDT3DI16_Axis;
    Dist := NodePtr^.Vec^.buff[axis] - buffPtr^[axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.Vec^.buff[axis] > buffPtr^[axis] then
            ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const buffPtr: PKDT3DI16_Vec; const p1, p2: PKDT3DI16_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := Distance(buffPtr^, p1^.Vec^.buff);
    d2 := Distance(buffPtr^, p2^.Vec^.buff);
    if d1 = d2 then
      begin
        if p1^.Vec^.Index = p2^.Vec^.Index then
            Result := 0
        else if p1^.Vec^.Index < p2^.Vec^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; L, R: NativeInt; const buffPtr: PKDT3DI16_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT3DI16_Node;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer[(L + R) shr 1];
      repeat
        while SortCompare(buffPtr, SortBuffer[i], p) < 0 do
            Inc(i);
        while SortCompare(buffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, buffPtr);
      L := i;
    until i >= R;
  end;

var
  Parent: PKDT3DI16_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := Distance(buff, Parent^.Vec^.buff);

  ScanSubtree(RootNode, @buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT3DI16_Node(NearestNodes[0]);
    end;
end;

function TKDT3DI16.Search(const buff: TKDT3DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT3DI16_Node;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT3DI16.Search(const buff: TKDT3DI16_Vec; var SearchedDistanceMin: Double): PKDT3DI16_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT3DI16.Search(const buff: TKDT3DI16_Vec): PKDT3DI16_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT3DI16.SearchToken(const buff: TKDT3DI16_Vec): TPascalString;
var
  p: PKDT3DI16_Node;
begin
  p := Search(buff);
  if p <> nil then
      Result := p^.Vec^.Token
  else
      Result := '';
end;

procedure TKDT3DI16.Search(const inBuff: TKDT3DI16_DynamicVecBuffer; var OutBuff: TKDT3DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT3DI16_DynamicVecBuffer;
  outBuffPtr: PKDT3DI16_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT3DI16_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outBuffPtr^[pass] := p^.Vec^.buff;
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT3DI16_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outBuffPtr^[pass] := p^.Vec^.buff;
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT3DI16_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.Vec^.buff;
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT3DI16.Search(const inBuff: TKDT3DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT3DI16_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT3DI16_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT3DI16_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT3DI16_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT3DI16.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  ID := KDT3DI16_Axis;

  stream.write(st, 4);
  stream.write(ID, 4);

  stream.write(cnt, 8);

  i := 0;
  while i < cnt do
    begin
      stream.write(KDStoreBuff[i].buff[0], SizeOf(TKDT3DI16_Vec));
      stream.write(KDStoreBuff[i].Index, 8);
      token_B := KDStoreBuff[i].Token.Bytes;
      token_L := length(token_B);
      stream.write(token_L, 4);
      if token_L > 0 then
        begin
          stream.write(token_B[0], token_L);
          SetLength(token_B, 0);
        end;
      Inc(i);
    end;
end;

procedure TKDT3DI16.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  Clear;

  stream.read(st, 4);
  stream.read(ID, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if ID <> KDT3DI16_Axis then
      RaiseInfo('kdtree axis error!');

  stream.read(cnt, 8);

  SetLength(KDStoreBuff, cnt);

  i := 0;
  try
    while i < cnt do
      begin
        if stream.read(KDStoreBuff[i].buff[0], SizeOf(TKDT3DI16_Vec)) <> SizeOf(TKDT3DI16_Vec) then
          begin
            Clear;
            Exit;
          end;
        if stream.read(KDStoreBuff[i].Index, 8) <> 8 then
          begin
            Clear;
            Exit;
          end;
        if stream.read(token_L, 4) <> 4 then
          begin
            Clear;
            Exit;
          end;
        if token_L > 0 then
          begin
            SetLength(token_B, token_L);
            if stream.read(token_B[0], token_L) <> token_L then
              begin
                Clear;
                Exit;
              end;
            KDStoreBuff[i].Token.Bytes := token_B;
            SetLength(token_B, 0);
          end
        else
            KDStoreBuff[i].Token := '';
        Inc(i);
      end;
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      Inc(i);
    end;

  if cnt > 0 then
      RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT3DI16.SaveToFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(FileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT3DI16.LoadFromFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT3DI16.PrintNodeTree(const NodePtr: PKDT3DI16_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT3DI16_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.Vec^.Index, Vec(p^.Vec^.buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT3DI16.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d - %d : %s ', [i, KDStoreBuff[i].Index, Vec(KDStoreBuff[i].buff)]);
end;

class function TKDT3DI16.Vec(const s: SystemString): TKDT3DI16_Vec;
var
  t: TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j: NativeInt;
begin
  for i := 0 to KDT3DI16_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            Inc(j);
            if j >= KDT3DI16_Axis then
                Break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT3DI16.Vec(const v: TKDT3DI16_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT3DI16_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT3DI16.Distance(const v1, v2: TKDT3DI16_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT3DI16_Axis - 1 do
      Result := Result + (v2[i] - v1[i]) * (v2[i] - v1[i]);
end;

procedure TKDT3DI16.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT3DI16_Source; const Data: Pointer);
begin
  Source.buff := TestBuff[IndexFor];
  Source.Token := umlIntToStr(IndexFor);
end;

class procedure TKDT3DI16.Test;
var
  TKDT3DI16_Test: TKDT3DI16;
  t: TTimeTick;
  i, j: NativeInt;
  TestResultBuff: TKDT3DI16_DynamicVecBuffer;
  TestResultIndex: TKMIntegerArray;
  KMeanOutIndex: TKMIntegerArray;
  errored: Boolean;
  m64: TMemoryStream64;
  p: PKDT3DI16_Node;
  n: TPascalString;
begin
  errored := False;
  n := PFormat('test %s...', [ClassName]);
  t := GetTimeTick;

  n.Append('...build');
  TKDT3DI16_Test := TKDT3DI16.Create;

  n.Append('...');
  SetLength(TKDT3DI16_Test.TestBuff, 1000);
  for i := 0 to length(TKDT3DI16_Test.TestBuff) - 1 do
    for j := 0 to KDT3DI16_Axis - 1 do
        TKDT3DI16_Test.TestBuff[i][j] := i * KDT3DI16_Axis + j;

{$IFDEF FPC}
  TKDT3DI16_Test.BuildKDTreeM(length(TKDT3DI16_Test.TestBuff), nil, @TKDT3DI16_Test.Test_BuildM);
{$ELSE FPC}
  TKDT3DI16_Test.BuildKDTreeM(length(TKDT3DI16_Test.TestBuff), nil, TKDT3DI16_Test.Test_BuildM);
{$ENDIF FPC}
  { save/load test }
  n.Append('...save/load');
  m64 := TMemoryStream64.CustomCreate(1024 * 1024);
  TKDT3DI16_Test.SaveToStream(m64);
  m64.Position := 0;
  TKDT3DI16_Test.LoadFromStream(m64);
  for i := 0 to length(TKDT3DI16_Test.TestBuff) - 1 do
    begin
      p := TKDT3DI16_Test.Search(TKDT3DI16_Test.TestBuff[i]);
      if p^.Vec^.Index <> i then
          errored := True;
      if not p^.Vec^.Token.Same(umlIntToStr(i)) then
          errored := True;
      if errored then
          Break;
    end;
  DisposeObject(m64);

  if not errored then
    begin
      { parallel search test }
      n.Append('...parallel');
      SetLength(TestResultBuff, length(TKDT3DI16_Test.TestBuff));
      SetLength(TestResultIndex, length(TKDT3DI16_Test.TestBuff));
      TKDT3DI16_Test.Search(TKDT3DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if Distance(TKDT3DI16_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
            errored := True;
    end;

  if not errored then
    begin
      n.Append('...kMean');
      TKDT3DI16_Test.Clear;
      { kMean test }
      TKDT3DI16_Test.BuildKDTreeWithCluster(TKDT3DI16_Test.TestBuff, 10, 1, KMeanOutIndex);
      { parallel search test }
      TKDT3DI16_Test.Search(TKDT3DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if TestResultIndex[i] <> KMeanOutIndex[i] then
            errored := True;
    end;

  SetLength(TKDT3DI16_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT3DI16_Test.Clear;

  n.Append('...');
  if errored then
      n.Append('error!')
  else
      n.Append('passed ok %dms', [GetTimeTick - t]);
  DisposeObject(TKDT3DI16_Test);
  DoStatus(n);
  n := '';
end;

function TKDT4DI16.InternalBuildKdTree(const KDSourceBufferPtr: PKDT4DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT4DI16_Node;
  function SortCompare(const p1, p2: PKDT4DI16_Source; const axis: NativeInt): ShortInt;
  begin
    if p1^.buff[axis] = p2^.buff[axis] then
      begin
        if p1^.Index = p2^.Index then
            Result := 0
        else if p1^.Index < p2^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.buff[axis] < p2^.buff[axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT4DI16_SourceBuffer; L, R: NativeInt; const axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT4DI16_Source;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer^[(L + R) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, axis) < 0 do
            Inc(i);
        while SortCompare(SortBuffer^[j], p, axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, axis);
      L := i;
    until i >= R;
  end;

var
  M: NativeInt;
  axis: NativeInt;
  kdBuffPtr: PKDT4DI16_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      new(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.Vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);
    end
  else
    begin
      axis := Depth mod KDT4DI16_Axis;
      M := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr^[0], 0, PlanCount - 1, axis);

      new(Result);
      Result^.Parent := nil;
      Result^.Vec := kdBuffPtr^[M];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], M, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[M + 1], PlanCount - (M + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT4DI16.GetData(const Index: NativeInt): PKDT4DI16_Source;
begin
  Result := @KDStoreBuff[Index];
end;

constructor TKDT4DI16.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT4DI16.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT4DI16.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT4DI16_Node(KDNodes[i]));
      Inc(i);
    end;

  for i := 0 to length(KDStoreBuff) - 1 do
      KDStoreBuff[i].Token := '';

  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT4DI16.StoreBuffPtr: PKDT4DI16_DyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT4DI16.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT4DI16_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT4DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT4DI16.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT4DI16_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT4DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT4DI16.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT4DI16_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT4DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{ k-means++ clusterization }
procedure TKDT4DI16.BuildKDTreeWithCluster(const inBuff: TKDT4DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  SetLength(Source, length(inBuff), KDT4DI16_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT4DI16_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT4DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT4DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT4DI16.BuildKDTreeWithCluster(const inBuff: TKDT4DI16_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TKMIntegerArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT4DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT4DI16_BuildCall);
var
  TempStoreBuff: TKDT4DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT4DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT4DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT4DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT4DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT4DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT4DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT4DI16_BuildMethod);
var
  TempStoreBuff: TKDT4DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT4DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT4DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT4DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT4DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT4DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT4DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT4DI16_BuildProc);
var
  TempStoreBuff: TKDT4DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT4DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT4DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT4DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT4DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT4DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

function TKDT4DI16.Search(const buff: TKDT4DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT4DI16_Node;

var
  NearestNeighbour: PKDT4DI16_Node;

  function FindParentNode(const buffPtr: PKDT4DI16_Vec; NodePtr: PKDT4DI16_Node): PKDT4DI16_Node;
  var
    Next: PKDT4DI16_Node;
    Depth, axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        axis := Depth mod KDT4DI16_Axis;
        if buffPtr^[axis] > Next^.Vec^.buff[axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT4DI16_Node; const buffPtr: PKDT4DI16_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    Inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := Distance(buffPtr^, NodePtr^.Vec^.buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.Vec^.Index < NearestNeighbour^.Vec^.Index) then
        NearestNeighbour := NodePtr;

    axis := Depth mod KDT4DI16_Axis;
    Dist := NodePtr^.Vec^.buff[axis] - buffPtr^[axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.Vec^.buff[axis] > buffPtr^[axis] then
            ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const buffPtr: PKDT4DI16_Vec; const p1, p2: PKDT4DI16_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := Distance(buffPtr^, p1^.Vec^.buff);
    d2 := Distance(buffPtr^, p2^.Vec^.buff);
    if d1 = d2 then
      begin
        if p1^.Vec^.Index = p2^.Vec^.Index then
            Result := 0
        else if p1^.Vec^.Index < p2^.Vec^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; L, R: NativeInt; const buffPtr: PKDT4DI16_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT4DI16_Node;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer[(L + R) shr 1];
      repeat
        while SortCompare(buffPtr, SortBuffer[i], p) < 0 do
            Inc(i);
        while SortCompare(buffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, buffPtr);
      L := i;
    until i >= R;
  end;

var
  Parent: PKDT4DI16_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := Distance(buff, Parent^.Vec^.buff);

  ScanSubtree(RootNode, @buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT4DI16_Node(NearestNodes[0]);
    end;
end;

function TKDT4DI16.Search(const buff: TKDT4DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT4DI16_Node;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT4DI16.Search(const buff: TKDT4DI16_Vec; var SearchedDistanceMin: Double): PKDT4DI16_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT4DI16.Search(const buff: TKDT4DI16_Vec): PKDT4DI16_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT4DI16.SearchToken(const buff: TKDT4DI16_Vec): TPascalString;
var
  p: PKDT4DI16_Node;
begin
  p := Search(buff);
  if p <> nil then
      Result := p^.Vec^.Token
  else
      Result := '';
end;

procedure TKDT4DI16.Search(const inBuff: TKDT4DI16_DynamicVecBuffer; var OutBuff: TKDT4DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT4DI16_DynamicVecBuffer;
  outBuffPtr: PKDT4DI16_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT4DI16_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outBuffPtr^[pass] := p^.Vec^.buff;
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT4DI16_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outBuffPtr^[pass] := p^.Vec^.buff;
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT4DI16_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.Vec^.buff;
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT4DI16.Search(const inBuff: TKDT4DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT4DI16_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT4DI16_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT4DI16_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT4DI16_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT4DI16.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  ID := KDT4DI16_Axis;

  stream.write(st, 4);
  stream.write(ID, 4);

  stream.write(cnt, 8);

  i := 0;
  while i < cnt do
    begin
      stream.write(KDStoreBuff[i].buff[0], SizeOf(TKDT4DI16_Vec));
      stream.write(KDStoreBuff[i].Index, 8);
      token_B := KDStoreBuff[i].Token.Bytes;
      token_L := length(token_B);
      stream.write(token_L, 4);
      if token_L > 0 then
        begin
          stream.write(token_B[0], token_L);
          SetLength(token_B, 0);
        end;
      Inc(i);
    end;
end;

procedure TKDT4DI16.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  Clear;

  stream.read(st, 4);
  stream.read(ID, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if ID <> KDT4DI16_Axis then
      RaiseInfo('kdtree axis error!');

  stream.read(cnt, 8);

  SetLength(KDStoreBuff, cnt);

  i := 0;
  try
    while i < cnt do
      begin
        if stream.read(KDStoreBuff[i].buff[0], SizeOf(TKDT4DI16_Vec)) <> SizeOf(TKDT4DI16_Vec) then
          begin
            Clear;
            Exit;
          end;
        if stream.read(KDStoreBuff[i].Index, 8) <> 8 then
          begin
            Clear;
            Exit;
          end;
        if stream.read(token_L, 4) <> 4 then
          begin
            Clear;
            Exit;
          end;
        if token_L > 0 then
          begin
            SetLength(token_B, token_L);
            if stream.read(token_B[0], token_L) <> token_L then
              begin
                Clear;
                Exit;
              end;
            KDStoreBuff[i].Token.Bytes := token_B;
            SetLength(token_B, 0);
          end
        else
            KDStoreBuff[i].Token := '';
        Inc(i);
      end;
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      Inc(i);
    end;

  if cnt > 0 then
      RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT4DI16.SaveToFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(FileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT4DI16.LoadFromFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT4DI16.PrintNodeTree(const NodePtr: PKDT4DI16_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT4DI16_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.Vec^.Index, Vec(p^.Vec^.buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT4DI16.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d - %d : %s ', [i, KDStoreBuff[i].Index, Vec(KDStoreBuff[i].buff)]);
end;

class function TKDT4DI16.Vec(const s: SystemString): TKDT4DI16_Vec;
var
  t: TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j: NativeInt;
begin
  for i := 0 to KDT4DI16_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            Inc(j);
            if j >= KDT4DI16_Axis then
                Break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT4DI16.Vec(const v: TKDT4DI16_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT4DI16_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT4DI16.Distance(const v1, v2: TKDT4DI16_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT4DI16_Axis - 1 do
      Result := Result + (v2[i] - v1[i]) * (v2[i] - v1[i]);
end;

procedure TKDT4DI16.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT4DI16_Source; const Data: Pointer);
begin
  Source.buff := TestBuff[IndexFor];
  Source.Token := umlIntToStr(IndexFor);
end;

class procedure TKDT4DI16.Test;
var
  TKDT4DI16_Test: TKDT4DI16;
  t: TTimeTick;
  i, j: NativeInt;
  TestResultBuff: TKDT4DI16_DynamicVecBuffer;
  TestResultIndex: TKMIntegerArray;
  KMeanOutIndex: TKMIntegerArray;
  errored: Boolean;
  m64: TMemoryStream64;
  p: PKDT4DI16_Node;
  n: TPascalString;
begin
  errored := False;
  n := PFormat('test %s...', [ClassName]);
  t := GetTimeTick;

  n.Append('...build');
  TKDT4DI16_Test := TKDT4DI16.Create;

  n.Append('...');
  SetLength(TKDT4DI16_Test.TestBuff, 1000);
  for i := 0 to length(TKDT4DI16_Test.TestBuff) - 1 do
    for j := 0 to KDT4DI16_Axis - 1 do
        TKDT4DI16_Test.TestBuff[i][j] := i * KDT4DI16_Axis + j;

{$IFDEF FPC}
  TKDT4DI16_Test.BuildKDTreeM(length(TKDT4DI16_Test.TestBuff), nil, @TKDT4DI16_Test.Test_BuildM);
{$ELSE FPC}
  TKDT4DI16_Test.BuildKDTreeM(length(TKDT4DI16_Test.TestBuff), nil, TKDT4DI16_Test.Test_BuildM);
{$ENDIF FPC}
  { save/load test }
  n.Append('...save/load');
  m64 := TMemoryStream64.CustomCreate(1024 * 1024);
  TKDT4DI16_Test.SaveToStream(m64);
  m64.Position := 0;
  TKDT4DI16_Test.LoadFromStream(m64);
  for i := 0 to length(TKDT4DI16_Test.TestBuff) - 1 do
    begin
      p := TKDT4DI16_Test.Search(TKDT4DI16_Test.TestBuff[i]);
      if p^.Vec^.Index <> i then
          errored := True;
      if not p^.Vec^.Token.Same(umlIntToStr(i)) then
          errored := True;
      if errored then
          Break;
    end;
  DisposeObject(m64);

  if not errored then
    begin
      { parallel search test }
      n.Append('...parallel');
      SetLength(TestResultBuff, length(TKDT4DI16_Test.TestBuff));
      SetLength(TestResultIndex, length(TKDT4DI16_Test.TestBuff));
      TKDT4DI16_Test.Search(TKDT4DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if Distance(TKDT4DI16_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
            errored := True;
    end;

  if not errored then
    begin
      n.Append('...kMean');
      TKDT4DI16_Test.Clear;
      { kMean test }
      TKDT4DI16_Test.BuildKDTreeWithCluster(TKDT4DI16_Test.TestBuff, 10, 1, KMeanOutIndex);
      { parallel search test }
      TKDT4DI16_Test.Search(TKDT4DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if TestResultIndex[i] <> KMeanOutIndex[i] then
            errored := True;
    end;

  SetLength(TKDT4DI16_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT4DI16_Test.Clear;

  n.Append('...');
  if errored then
      n.Append('error!')
  else
      n.Append('passed ok %dms', [GetTimeTick - t]);
  DisposeObject(TKDT4DI16_Test);
  DoStatus(n);
  n := '';
end;

function TKDT5DI16.InternalBuildKdTree(const KDSourceBufferPtr: PKDT5DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT5DI16_Node;
  function SortCompare(const p1, p2: PKDT5DI16_Source; const axis: NativeInt): ShortInt;
  begin
    if p1^.buff[axis] = p2^.buff[axis] then
      begin
        if p1^.Index = p2^.Index then
            Result := 0
        else if p1^.Index < p2^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.buff[axis] < p2^.buff[axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT5DI16_SourceBuffer; L, R: NativeInt; const axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT5DI16_Source;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer^[(L + R) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, axis) < 0 do
            Inc(i);
        while SortCompare(SortBuffer^[j], p, axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, axis);
      L := i;
    until i >= R;
  end;

var
  M: NativeInt;
  axis: NativeInt;
  kdBuffPtr: PKDT5DI16_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      new(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.Vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);
    end
  else
    begin
      axis := Depth mod KDT5DI16_Axis;
      M := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr^[0], 0, PlanCount - 1, axis);

      new(Result);
      Result^.Parent := nil;
      Result^.Vec := kdBuffPtr^[M];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], M, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[M + 1], PlanCount - (M + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT5DI16.GetData(const Index: NativeInt): PKDT5DI16_Source;
begin
  Result := @KDStoreBuff[Index];
end;

constructor TKDT5DI16.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT5DI16.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT5DI16.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT5DI16_Node(KDNodes[i]));
      Inc(i);
    end;

  for i := 0 to length(KDStoreBuff) - 1 do
      KDStoreBuff[i].Token := '';

  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT5DI16.StoreBuffPtr: PKDT5DI16_DyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT5DI16.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT5DI16_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT5DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT5DI16.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT5DI16_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT5DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT5DI16.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT5DI16_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT5DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{ k-means++ clusterization }
procedure TKDT5DI16.BuildKDTreeWithCluster(const inBuff: TKDT5DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  SetLength(Source, length(inBuff), KDT5DI16_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT5DI16_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT5DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT5DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT5DI16.BuildKDTreeWithCluster(const inBuff: TKDT5DI16_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TKMIntegerArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT5DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT5DI16_BuildCall);
var
  TempStoreBuff: TKDT5DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT5DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT5DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT5DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT5DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT5DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT5DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT5DI16_BuildMethod);
var
  TempStoreBuff: TKDT5DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT5DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT5DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT5DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT5DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT5DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT5DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT5DI16_BuildProc);
var
  TempStoreBuff: TKDT5DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT5DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT5DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT5DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT5DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT5DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

function TKDT5DI16.Search(const buff: TKDT5DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT5DI16_Node;

var
  NearestNeighbour: PKDT5DI16_Node;

  function FindParentNode(const buffPtr: PKDT5DI16_Vec; NodePtr: PKDT5DI16_Node): PKDT5DI16_Node;
  var
    Next: PKDT5DI16_Node;
    Depth, axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        axis := Depth mod KDT5DI16_Axis;
        if buffPtr^[axis] > Next^.Vec^.buff[axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT5DI16_Node; const buffPtr: PKDT5DI16_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    Inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := Distance(buffPtr^, NodePtr^.Vec^.buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.Vec^.Index < NearestNeighbour^.Vec^.Index) then
        NearestNeighbour := NodePtr;

    axis := Depth mod KDT5DI16_Axis;
    Dist := NodePtr^.Vec^.buff[axis] - buffPtr^[axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.Vec^.buff[axis] > buffPtr^[axis] then
            ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const buffPtr: PKDT5DI16_Vec; const p1, p2: PKDT5DI16_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := Distance(buffPtr^, p1^.Vec^.buff);
    d2 := Distance(buffPtr^, p2^.Vec^.buff);
    if d1 = d2 then
      begin
        if p1^.Vec^.Index = p2^.Vec^.Index then
            Result := 0
        else if p1^.Vec^.Index < p2^.Vec^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; L, R: NativeInt; const buffPtr: PKDT5DI16_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT5DI16_Node;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer[(L + R) shr 1];
      repeat
        while SortCompare(buffPtr, SortBuffer[i], p) < 0 do
            Inc(i);
        while SortCompare(buffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, buffPtr);
      L := i;
    until i >= R;
  end;

var
  Parent: PKDT5DI16_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := Distance(buff, Parent^.Vec^.buff);

  ScanSubtree(RootNode, @buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT5DI16_Node(NearestNodes[0]);
    end;
end;

function TKDT5DI16.Search(const buff: TKDT5DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT5DI16_Node;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT5DI16.Search(const buff: TKDT5DI16_Vec; var SearchedDistanceMin: Double): PKDT5DI16_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT5DI16.Search(const buff: TKDT5DI16_Vec): PKDT5DI16_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT5DI16.SearchToken(const buff: TKDT5DI16_Vec): TPascalString;
var
  p: PKDT5DI16_Node;
begin
  p := Search(buff);
  if p <> nil then
      Result := p^.Vec^.Token
  else
      Result := '';
end;

procedure TKDT5DI16.Search(const inBuff: TKDT5DI16_DynamicVecBuffer; var OutBuff: TKDT5DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT5DI16_DynamicVecBuffer;
  outBuffPtr: PKDT5DI16_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT5DI16_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outBuffPtr^[pass] := p^.Vec^.buff;
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT5DI16_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outBuffPtr^[pass] := p^.Vec^.buff;
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT5DI16_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.Vec^.buff;
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT5DI16.Search(const inBuff: TKDT5DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT5DI16_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT5DI16_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT5DI16_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT5DI16_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT5DI16.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  ID := KDT5DI16_Axis;

  stream.write(st, 4);
  stream.write(ID, 4);

  stream.write(cnt, 8);

  i := 0;
  while i < cnt do
    begin
      stream.write(KDStoreBuff[i].buff[0], SizeOf(TKDT5DI16_Vec));
      stream.write(KDStoreBuff[i].Index, 8);
      token_B := KDStoreBuff[i].Token.Bytes;
      token_L := length(token_B);
      stream.write(token_L, 4);
      if token_L > 0 then
        begin
          stream.write(token_B[0], token_L);
          SetLength(token_B, 0);
        end;
      Inc(i);
    end;
end;

procedure TKDT5DI16.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  Clear;

  stream.read(st, 4);
  stream.read(ID, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if ID <> KDT5DI16_Axis then
      RaiseInfo('kdtree axis error!');

  stream.read(cnt, 8);

  SetLength(KDStoreBuff, cnt);

  i := 0;
  try
    while i < cnt do
      begin
        if stream.read(KDStoreBuff[i].buff[0], SizeOf(TKDT5DI16_Vec)) <> SizeOf(TKDT5DI16_Vec) then
          begin
            Clear;
            Exit;
          end;
        if stream.read(KDStoreBuff[i].Index, 8) <> 8 then
          begin
            Clear;
            Exit;
          end;
        if stream.read(token_L, 4) <> 4 then
          begin
            Clear;
            Exit;
          end;
        if token_L > 0 then
          begin
            SetLength(token_B, token_L);
            if stream.read(token_B[0], token_L) <> token_L then
              begin
                Clear;
                Exit;
              end;
            KDStoreBuff[i].Token.Bytes := token_B;
            SetLength(token_B, 0);
          end
        else
            KDStoreBuff[i].Token := '';
        Inc(i);
      end;
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      Inc(i);
    end;

  if cnt > 0 then
      RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT5DI16.SaveToFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(FileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT5DI16.LoadFromFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT5DI16.PrintNodeTree(const NodePtr: PKDT5DI16_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT5DI16_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.Vec^.Index, Vec(p^.Vec^.buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT5DI16.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d - %d : %s ', [i, KDStoreBuff[i].Index, Vec(KDStoreBuff[i].buff)]);
end;

class function TKDT5DI16.Vec(const s: SystemString): TKDT5DI16_Vec;
var
  t: TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j: NativeInt;
begin
  for i := 0 to KDT5DI16_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            Inc(j);
            if j >= KDT5DI16_Axis then
                Break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT5DI16.Vec(const v: TKDT5DI16_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT5DI16_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT5DI16.Distance(const v1, v2: TKDT5DI16_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT5DI16_Axis - 1 do
      Result := Result + (v2[i] - v1[i]) * (v2[i] - v1[i]);
end;

procedure TKDT5DI16.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT5DI16_Source; const Data: Pointer);
begin
  Source.buff := TestBuff[IndexFor];
  Source.Token := umlIntToStr(IndexFor);
end;

class procedure TKDT5DI16.Test;
var
  TKDT5DI16_Test: TKDT5DI16;
  t: TTimeTick;
  i, j: NativeInt;
  TestResultBuff: TKDT5DI16_DynamicVecBuffer;
  TestResultIndex: TKMIntegerArray;
  KMeanOutIndex: TKMIntegerArray;
  errored: Boolean;
  m64: TMemoryStream64;
  p: PKDT5DI16_Node;
  n: TPascalString;
begin
  errored := False;
  n := PFormat('test %s...', [ClassName]);
  t := GetTimeTick;

  n.Append('...build');
  TKDT5DI16_Test := TKDT5DI16.Create;

  n.Append('...');
  SetLength(TKDT5DI16_Test.TestBuff, 1000);
  for i := 0 to length(TKDT5DI16_Test.TestBuff) - 1 do
    for j := 0 to KDT5DI16_Axis - 1 do
        TKDT5DI16_Test.TestBuff[i][j] := i * KDT5DI16_Axis + j;

{$IFDEF FPC}
  TKDT5DI16_Test.BuildKDTreeM(length(TKDT5DI16_Test.TestBuff), nil, @TKDT5DI16_Test.Test_BuildM);
{$ELSE FPC}
  TKDT5DI16_Test.BuildKDTreeM(length(TKDT5DI16_Test.TestBuff), nil, TKDT5DI16_Test.Test_BuildM);
{$ENDIF FPC}
  { save/load test }
  n.Append('...save/load');
  m64 := TMemoryStream64.CustomCreate(1024 * 1024);
  TKDT5DI16_Test.SaveToStream(m64);
  m64.Position := 0;
  TKDT5DI16_Test.LoadFromStream(m64);
  for i := 0 to length(TKDT5DI16_Test.TestBuff) - 1 do
    begin
      p := TKDT5DI16_Test.Search(TKDT5DI16_Test.TestBuff[i]);
      if p^.Vec^.Index <> i then
          errored := True;
      if not p^.Vec^.Token.Same(umlIntToStr(i)) then
          errored := True;
      if errored then
          Break;
    end;
  DisposeObject(m64);

  if not errored then
    begin
      { parallel search test }
      n.Append('...parallel');
      SetLength(TestResultBuff, length(TKDT5DI16_Test.TestBuff));
      SetLength(TestResultIndex, length(TKDT5DI16_Test.TestBuff));
      TKDT5DI16_Test.Search(TKDT5DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if Distance(TKDT5DI16_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
            errored := True;
    end;

  if not errored then
    begin
      n.Append('...kMean');
      TKDT5DI16_Test.Clear;
      { kMean test }
      TKDT5DI16_Test.BuildKDTreeWithCluster(TKDT5DI16_Test.TestBuff, 10, 1, KMeanOutIndex);
      { parallel search test }
      TKDT5DI16_Test.Search(TKDT5DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if TestResultIndex[i] <> KMeanOutIndex[i] then
            errored := True;
    end;

  SetLength(TKDT5DI16_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT5DI16_Test.Clear;

  n.Append('...');
  if errored then
      n.Append('error!')
  else
      n.Append('passed ok %dms', [GetTimeTick - t]);
  DisposeObject(TKDT5DI16_Test);
  DoStatus(n);
  n := '';
end;

function TKDT6DI16.InternalBuildKdTree(const KDSourceBufferPtr: PKDT6DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT6DI16_Node;
  function SortCompare(const p1, p2: PKDT6DI16_Source; const axis: NativeInt): ShortInt;
  begin
    if p1^.buff[axis] = p2^.buff[axis] then
      begin
        if p1^.Index = p2^.Index then
            Result := 0
        else if p1^.Index < p2^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.buff[axis] < p2^.buff[axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT6DI16_SourceBuffer; L, R: NativeInt; const axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT6DI16_Source;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer^[(L + R) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, axis) < 0 do
            Inc(i);
        while SortCompare(SortBuffer^[j], p, axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, axis);
      L := i;
    until i >= R;
  end;

var
  M: NativeInt;
  axis: NativeInt;
  kdBuffPtr: PKDT6DI16_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      new(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.Vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);
    end
  else
    begin
      axis := Depth mod KDT6DI16_Axis;
      M := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr^[0], 0, PlanCount - 1, axis);

      new(Result);
      Result^.Parent := nil;
      Result^.Vec := kdBuffPtr^[M];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], M, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[M + 1], PlanCount - (M + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT6DI16.GetData(const Index: NativeInt): PKDT6DI16_Source;
begin
  Result := @KDStoreBuff[Index];
end;

constructor TKDT6DI16.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT6DI16.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT6DI16.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT6DI16_Node(KDNodes[i]));
      Inc(i);
    end;

  for i := 0 to length(KDStoreBuff) - 1 do
      KDStoreBuff[i].Token := '';

  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT6DI16.StoreBuffPtr: PKDT6DI16_DyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT6DI16.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT6DI16_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT6DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT6DI16.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT6DI16_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT6DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT6DI16.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT6DI16_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT6DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{ k-means++ clusterization }
procedure TKDT6DI16.BuildKDTreeWithCluster(const inBuff: TKDT6DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  SetLength(Source, length(inBuff), KDT6DI16_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT6DI16_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT6DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT6DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT6DI16.BuildKDTreeWithCluster(const inBuff: TKDT6DI16_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TKMIntegerArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT6DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT6DI16_BuildCall);
var
  TempStoreBuff: TKDT6DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT6DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT6DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT6DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT6DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT6DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT6DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT6DI16_BuildMethod);
var
  TempStoreBuff: TKDT6DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT6DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT6DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT6DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT6DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT6DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT6DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT6DI16_BuildProc);
var
  TempStoreBuff: TKDT6DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT6DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT6DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT6DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT6DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT6DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

function TKDT6DI16.Search(const buff: TKDT6DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT6DI16_Node;

var
  NearestNeighbour: PKDT6DI16_Node;

  function FindParentNode(const buffPtr: PKDT6DI16_Vec; NodePtr: PKDT6DI16_Node): PKDT6DI16_Node;
  var
    Next: PKDT6DI16_Node;
    Depth, axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        axis := Depth mod KDT6DI16_Axis;
        if buffPtr^[axis] > Next^.Vec^.buff[axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT6DI16_Node; const buffPtr: PKDT6DI16_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    Inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := Distance(buffPtr^, NodePtr^.Vec^.buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.Vec^.Index < NearestNeighbour^.Vec^.Index) then
        NearestNeighbour := NodePtr;

    axis := Depth mod KDT6DI16_Axis;
    Dist := NodePtr^.Vec^.buff[axis] - buffPtr^[axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.Vec^.buff[axis] > buffPtr^[axis] then
            ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const buffPtr: PKDT6DI16_Vec; const p1, p2: PKDT6DI16_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := Distance(buffPtr^, p1^.Vec^.buff);
    d2 := Distance(buffPtr^, p2^.Vec^.buff);
    if d1 = d2 then
      begin
        if p1^.Vec^.Index = p2^.Vec^.Index then
            Result := 0
        else if p1^.Vec^.Index < p2^.Vec^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; L, R: NativeInt; const buffPtr: PKDT6DI16_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT6DI16_Node;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer[(L + R) shr 1];
      repeat
        while SortCompare(buffPtr, SortBuffer[i], p) < 0 do
            Inc(i);
        while SortCompare(buffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, buffPtr);
      L := i;
    until i >= R;
  end;

var
  Parent: PKDT6DI16_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := Distance(buff, Parent^.Vec^.buff);

  ScanSubtree(RootNode, @buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT6DI16_Node(NearestNodes[0]);
    end;
end;

function TKDT6DI16.Search(const buff: TKDT6DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT6DI16_Node;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT6DI16.Search(const buff: TKDT6DI16_Vec; var SearchedDistanceMin: Double): PKDT6DI16_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT6DI16.Search(const buff: TKDT6DI16_Vec): PKDT6DI16_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT6DI16.SearchToken(const buff: TKDT6DI16_Vec): TPascalString;
var
  p: PKDT6DI16_Node;
begin
  p := Search(buff);
  if p <> nil then
      Result := p^.Vec^.Token
  else
      Result := '';
end;

procedure TKDT6DI16.Search(const inBuff: TKDT6DI16_DynamicVecBuffer; var OutBuff: TKDT6DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT6DI16_DynamicVecBuffer;
  outBuffPtr: PKDT6DI16_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT6DI16_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outBuffPtr^[pass] := p^.Vec^.buff;
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT6DI16_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outBuffPtr^[pass] := p^.Vec^.buff;
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT6DI16_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.Vec^.buff;
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT6DI16.Search(const inBuff: TKDT6DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT6DI16_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT6DI16_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT6DI16_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT6DI16_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT6DI16.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  ID := KDT6DI16_Axis;

  stream.write(st, 4);
  stream.write(ID, 4);

  stream.write(cnt, 8);

  i := 0;
  while i < cnt do
    begin
      stream.write(KDStoreBuff[i].buff[0], SizeOf(TKDT6DI16_Vec));
      stream.write(KDStoreBuff[i].Index, 8);
      token_B := KDStoreBuff[i].Token.Bytes;
      token_L := length(token_B);
      stream.write(token_L, 4);
      if token_L > 0 then
        begin
          stream.write(token_B[0], token_L);
          SetLength(token_B, 0);
        end;
      Inc(i);
    end;
end;

procedure TKDT6DI16.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  Clear;

  stream.read(st, 4);
  stream.read(ID, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if ID <> KDT6DI16_Axis then
      RaiseInfo('kdtree axis error!');

  stream.read(cnt, 8);

  SetLength(KDStoreBuff, cnt);

  i := 0;
  try
    while i < cnt do
      begin
        if stream.read(KDStoreBuff[i].buff[0], SizeOf(TKDT6DI16_Vec)) <> SizeOf(TKDT6DI16_Vec) then
          begin
            Clear;
            Exit;
          end;
        if stream.read(KDStoreBuff[i].Index, 8) <> 8 then
          begin
            Clear;
            Exit;
          end;
        if stream.read(token_L, 4) <> 4 then
          begin
            Clear;
            Exit;
          end;
        if token_L > 0 then
          begin
            SetLength(token_B, token_L);
            if stream.read(token_B[0], token_L) <> token_L then
              begin
                Clear;
                Exit;
              end;
            KDStoreBuff[i].Token.Bytes := token_B;
            SetLength(token_B, 0);
          end
        else
            KDStoreBuff[i].Token := '';
        Inc(i);
      end;
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      Inc(i);
    end;

  if cnt > 0 then
      RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT6DI16.SaveToFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(FileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT6DI16.LoadFromFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT6DI16.PrintNodeTree(const NodePtr: PKDT6DI16_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT6DI16_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.Vec^.Index, Vec(p^.Vec^.buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT6DI16.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d - %d : %s ', [i, KDStoreBuff[i].Index, Vec(KDStoreBuff[i].buff)]);
end;

class function TKDT6DI16.Vec(const s: SystemString): TKDT6DI16_Vec;
var
  t: TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j: NativeInt;
begin
  for i := 0 to KDT6DI16_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            Inc(j);
            if j >= KDT6DI16_Axis then
                Break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT6DI16.Vec(const v: TKDT6DI16_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT6DI16_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT6DI16.Distance(const v1, v2: TKDT6DI16_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT6DI16_Axis - 1 do
      Result := Result + (v2[i] - v1[i]) * (v2[i] - v1[i]);
end;

procedure TKDT6DI16.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT6DI16_Source; const Data: Pointer);
begin
  Source.buff := TestBuff[IndexFor];
  Source.Token := umlIntToStr(IndexFor);
end;

class procedure TKDT6DI16.Test;
var
  TKDT6DI16_Test: TKDT6DI16;
  t: TTimeTick;
  i, j: NativeInt;
  TestResultBuff: TKDT6DI16_DynamicVecBuffer;
  TestResultIndex: TKMIntegerArray;
  KMeanOutIndex: TKMIntegerArray;
  errored: Boolean;
  m64: TMemoryStream64;
  p: PKDT6DI16_Node;
  n: TPascalString;
begin
  errored := False;
  n := PFormat('test %s...', [ClassName]);
  t := GetTimeTick;

  n.Append('...build');
  TKDT6DI16_Test := TKDT6DI16.Create;

  n.Append('...');
  SetLength(TKDT6DI16_Test.TestBuff, 1000);
  for i := 0 to length(TKDT6DI16_Test.TestBuff) - 1 do
    for j := 0 to KDT6DI16_Axis - 1 do
        TKDT6DI16_Test.TestBuff[i][j] := i * KDT6DI16_Axis + j;

{$IFDEF FPC}
  TKDT6DI16_Test.BuildKDTreeM(length(TKDT6DI16_Test.TestBuff), nil, @TKDT6DI16_Test.Test_BuildM);
{$ELSE FPC}
  TKDT6DI16_Test.BuildKDTreeM(length(TKDT6DI16_Test.TestBuff), nil, TKDT6DI16_Test.Test_BuildM);
{$ENDIF FPC}
  { save/load test }
  n.Append('...save/load');
  m64 := TMemoryStream64.CustomCreate(1024 * 1024);
  TKDT6DI16_Test.SaveToStream(m64);
  m64.Position := 0;
  TKDT6DI16_Test.LoadFromStream(m64);
  for i := 0 to length(TKDT6DI16_Test.TestBuff) - 1 do
    begin
      p := TKDT6DI16_Test.Search(TKDT6DI16_Test.TestBuff[i]);
      if p^.Vec^.Index <> i then
          errored := True;
      if not p^.Vec^.Token.Same(umlIntToStr(i)) then
          errored := True;
      if errored then
          Break;
    end;
  DisposeObject(m64);

  if not errored then
    begin
      { parallel search test }
      n.Append('...parallel');
      SetLength(TestResultBuff, length(TKDT6DI16_Test.TestBuff));
      SetLength(TestResultIndex, length(TKDT6DI16_Test.TestBuff));
      TKDT6DI16_Test.Search(TKDT6DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if Distance(TKDT6DI16_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
            errored := True;
    end;

  if not errored then
    begin
      n.Append('...kMean');
      TKDT6DI16_Test.Clear;
      { kMean test }
      TKDT6DI16_Test.BuildKDTreeWithCluster(TKDT6DI16_Test.TestBuff, 10, 1, KMeanOutIndex);
      { parallel search test }
      TKDT6DI16_Test.Search(TKDT6DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if TestResultIndex[i] <> KMeanOutIndex[i] then
            errored := True;
    end;

  SetLength(TKDT6DI16_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT6DI16_Test.Clear;

  n.Append('...');
  if errored then
      n.Append('error!')
  else
      n.Append('passed ok %dms', [GetTimeTick - t]);
  DisposeObject(TKDT6DI16_Test);
  DoStatus(n);
  n := '';
end;

function TKDT7DI16.InternalBuildKdTree(const KDSourceBufferPtr: PKDT7DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT7DI16_Node;
  function SortCompare(const p1, p2: PKDT7DI16_Source; const axis: NativeInt): ShortInt;
  begin
    if p1^.buff[axis] = p2^.buff[axis] then
      begin
        if p1^.Index = p2^.Index then
            Result := 0
        else if p1^.Index < p2^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.buff[axis] < p2^.buff[axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT7DI16_SourceBuffer; L, R: NativeInt; const axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT7DI16_Source;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer^[(L + R) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, axis) < 0 do
            Inc(i);
        while SortCompare(SortBuffer^[j], p, axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, axis);
      L := i;
    until i >= R;
  end;

var
  M: NativeInt;
  axis: NativeInt;
  kdBuffPtr: PKDT7DI16_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      new(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.Vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);
    end
  else
    begin
      axis := Depth mod KDT7DI16_Axis;
      M := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr^[0], 0, PlanCount - 1, axis);

      new(Result);
      Result^.Parent := nil;
      Result^.Vec := kdBuffPtr^[M];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], M, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[M + 1], PlanCount - (M + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT7DI16.GetData(const Index: NativeInt): PKDT7DI16_Source;
begin
  Result := @KDStoreBuff[Index];
end;

constructor TKDT7DI16.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT7DI16.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT7DI16.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT7DI16_Node(KDNodes[i]));
      Inc(i);
    end;

  for i := 0 to length(KDStoreBuff) - 1 do
      KDStoreBuff[i].Token := '';

  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT7DI16.StoreBuffPtr: PKDT7DI16_DyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT7DI16.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT7DI16_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT7DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT7DI16.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT7DI16_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT7DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT7DI16.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT7DI16_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT7DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{ k-means++ clusterization }
procedure TKDT7DI16.BuildKDTreeWithCluster(const inBuff: TKDT7DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  SetLength(Source, length(inBuff), KDT7DI16_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT7DI16_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT7DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT7DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT7DI16.BuildKDTreeWithCluster(const inBuff: TKDT7DI16_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TKMIntegerArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT7DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT7DI16_BuildCall);
var
  TempStoreBuff: TKDT7DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT7DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT7DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT7DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT7DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT7DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT7DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT7DI16_BuildMethod);
var
  TempStoreBuff: TKDT7DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT7DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT7DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT7DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT7DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT7DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT7DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT7DI16_BuildProc);
var
  TempStoreBuff: TKDT7DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT7DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT7DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT7DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT7DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT7DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

function TKDT7DI16.Search(const buff: TKDT7DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT7DI16_Node;

var
  NearestNeighbour: PKDT7DI16_Node;

  function FindParentNode(const buffPtr: PKDT7DI16_Vec; NodePtr: PKDT7DI16_Node): PKDT7DI16_Node;
  var
    Next: PKDT7DI16_Node;
    Depth, axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        axis := Depth mod KDT7DI16_Axis;
        if buffPtr^[axis] > Next^.Vec^.buff[axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT7DI16_Node; const buffPtr: PKDT7DI16_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    Inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := Distance(buffPtr^, NodePtr^.Vec^.buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.Vec^.Index < NearestNeighbour^.Vec^.Index) then
        NearestNeighbour := NodePtr;

    axis := Depth mod KDT7DI16_Axis;
    Dist := NodePtr^.Vec^.buff[axis] - buffPtr^[axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.Vec^.buff[axis] > buffPtr^[axis] then
            ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const buffPtr: PKDT7DI16_Vec; const p1, p2: PKDT7DI16_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := Distance(buffPtr^, p1^.Vec^.buff);
    d2 := Distance(buffPtr^, p2^.Vec^.buff);
    if d1 = d2 then
      begin
        if p1^.Vec^.Index = p2^.Vec^.Index then
            Result := 0
        else if p1^.Vec^.Index < p2^.Vec^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; L, R: NativeInt; const buffPtr: PKDT7DI16_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT7DI16_Node;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer[(L + R) shr 1];
      repeat
        while SortCompare(buffPtr, SortBuffer[i], p) < 0 do
            Inc(i);
        while SortCompare(buffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, buffPtr);
      L := i;
    until i >= R;
  end;

var
  Parent: PKDT7DI16_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := Distance(buff, Parent^.Vec^.buff);

  ScanSubtree(RootNode, @buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT7DI16_Node(NearestNodes[0]);
    end;
end;

function TKDT7DI16.Search(const buff: TKDT7DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT7DI16_Node;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT7DI16.Search(const buff: TKDT7DI16_Vec; var SearchedDistanceMin: Double): PKDT7DI16_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT7DI16.Search(const buff: TKDT7DI16_Vec): PKDT7DI16_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT7DI16.SearchToken(const buff: TKDT7DI16_Vec): TPascalString;
var
  p: PKDT7DI16_Node;
begin
  p := Search(buff);
  if p <> nil then
      Result := p^.Vec^.Token
  else
      Result := '';
end;

procedure TKDT7DI16.Search(const inBuff: TKDT7DI16_DynamicVecBuffer; var OutBuff: TKDT7DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT7DI16_DynamicVecBuffer;
  outBuffPtr: PKDT7DI16_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT7DI16_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outBuffPtr^[pass] := p^.Vec^.buff;
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT7DI16_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outBuffPtr^[pass] := p^.Vec^.buff;
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT7DI16_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.Vec^.buff;
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT7DI16.Search(const inBuff: TKDT7DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT7DI16_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT7DI16_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT7DI16_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT7DI16_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT7DI16.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  ID := KDT7DI16_Axis;

  stream.write(st, 4);
  stream.write(ID, 4);

  stream.write(cnt, 8);

  i := 0;
  while i < cnt do
    begin
      stream.write(KDStoreBuff[i].buff[0], SizeOf(TKDT7DI16_Vec));
      stream.write(KDStoreBuff[i].Index, 8);
      token_B := KDStoreBuff[i].Token.Bytes;
      token_L := length(token_B);
      stream.write(token_L, 4);
      if token_L > 0 then
        begin
          stream.write(token_B[0], token_L);
          SetLength(token_B, 0);
        end;
      Inc(i);
    end;
end;

procedure TKDT7DI16.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  Clear;

  stream.read(st, 4);
  stream.read(ID, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if ID <> KDT7DI16_Axis then
      RaiseInfo('kdtree axis error!');

  stream.read(cnt, 8);

  SetLength(KDStoreBuff, cnt);

  i := 0;
  try
    while i < cnt do
      begin
        if stream.read(KDStoreBuff[i].buff[0], SizeOf(TKDT7DI16_Vec)) <> SizeOf(TKDT7DI16_Vec) then
          begin
            Clear;
            Exit;
          end;
        if stream.read(KDStoreBuff[i].Index, 8) <> 8 then
          begin
            Clear;
            Exit;
          end;
        if stream.read(token_L, 4) <> 4 then
          begin
            Clear;
            Exit;
          end;
        if token_L > 0 then
          begin
            SetLength(token_B, token_L);
            if stream.read(token_B[0], token_L) <> token_L then
              begin
                Clear;
                Exit;
              end;
            KDStoreBuff[i].Token.Bytes := token_B;
            SetLength(token_B, 0);
          end
        else
            KDStoreBuff[i].Token := '';
        Inc(i);
      end;
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      Inc(i);
    end;

  if cnt > 0 then
      RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT7DI16.SaveToFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(FileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT7DI16.LoadFromFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT7DI16.PrintNodeTree(const NodePtr: PKDT7DI16_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT7DI16_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.Vec^.Index, Vec(p^.Vec^.buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT7DI16.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d - %d : %s ', [i, KDStoreBuff[i].Index, Vec(KDStoreBuff[i].buff)]);
end;

class function TKDT7DI16.Vec(const s: SystemString): TKDT7DI16_Vec;
var
  t: TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j: NativeInt;
begin
  for i := 0 to KDT7DI16_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            Inc(j);
            if j >= KDT7DI16_Axis then
                Break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT7DI16.Vec(const v: TKDT7DI16_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT7DI16_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT7DI16.Distance(const v1, v2: TKDT7DI16_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT7DI16_Axis - 1 do
      Result := Result + (v2[i] - v1[i]) * (v2[i] - v1[i]);
end;

procedure TKDT7DI16.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT7DI16_Source; const Data: Pointer);
begin
  Source.buff := TestBuff[IndexFor];
  Source.Token := umlIntToStr(IndexFor);
end;

class procedure TKDT7DI16.Test;
var
  TKDT7DI16_Test: TKDT7DI16;
  t: TTimeTick;
  i, j: NativeInt;
  TestResultBuff: TKDT7DI16_DynamicVecBuffer;
  TestResultIndex: TKMIntegerArray;
  KMeanOutIndex: TKMIntegerArray;
  errored: Boolean;
  m64: TMemoryStream64;
  p: PKDT7DI16_Node;
  n: TPascalString;
begin
  errored := False;
  n := PFormat('test %s...', [ClassName]);
  t := GetTimeTick;

  n.Append('...build');
  TKDT7DI16_Test := TKDT7DI16.Create;

  n.Append('...');
  SetLength(TKDT7DI16_Test.TestBuff, 1000);
  for i := 0 to length(TKDT7DI16_Test.TestBuff) - 1 do
    for j := 0 to KDT7DI16_Axis - 1 do
        TKDT7DI16_Test.TestBuff[i][j] := i * KDT7DI16_Axis + j;

{$IFDEF FPC}
  TKDT7DI16_Test.BuildKDTreeM(length(TKDT7DI16_Test.TestBuff), nil, @TKDT7DI16_Test.Test_BuildM);
{$ELSE FPC}
  TKDT7DI16_Test.BuildKDTreeM(length(TKDT7DI16_Test.TestBuff), nil, TKDT7DI16_Test.Test_BuildM);
{$ENDIF FPC}
  { save/load test }
  n.Append('...save/load');
  m64 := TMemoryStream64.CustomCreate(1024 * 1024);
  TKDT7DI16_Test.SaveToStream(m64);
  m64.Position := 0;
  TKDT7DI16_Test.LoadFromStream(m64);
  for i := 0 to length(TKDT7DI16_Test.TestBuff) - 1 do
    begin
      p := TKDT7DI16_Test.Search(TKDT7DI16_Test.TestBuff[i]);
      if p^.Vec^.Index <> i then
          errored := True;
      if not p^.Vec^.Token.Same(umlIntToStr(i)) then
          errored := True;
      if errored then
          Break;
    end;
  DisposeObject(m64);

  if not errored then
    begin
      { parallel search test }
      n.Append('...parallel');
      SetLength(TestResultBuff, length(TKDT7DI16_Test.TestBuff));
      SetLength(TestResultIndex, length(TKDT7DI16_Test.TestBuff));
      TKDT7DI16_Test.Search(TKDT7DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if Distance(TKDT7DI16_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
            errored := True;
    end;

  if not errored then
    begin
      n.Append('...kMean');
      TKDT7DI16_Test.Clear;
      { kMean test }
      TKDT7DI16_Test.BuildKDTreeWithCluster(TKDT7DI16_Test.TestBuff, 10, 1, KMeanOutIndex);
      { parallel search test }
      TKDT7DI16_Test.Search(TKDT7DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if TestResultIndex[i] <> KMeanOutIndex[i] then
            errored := True;
    end;

  SetLength(TKDT7DI16_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT7DI16_Test.Clear;

  n.Append('...');
  if errored then
      n.Append('error!')
  else
      n.Append('passed ok %dms', [GetTimeTick - t]);
  DisposeObject(TKDT7DI16_Test);
  DoStatus(n);
  n := '';
end;

function TKDT8DI16.InternalBuildKdTree(const KDSourceBufferPtr: PKDT8DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT8DI16_Node;
  function SortCompare(const p1, p2: PKDT8DI16_Source; const axis: NativeInt): ShortInt;
  begin
    if p1^.buff[axis] = p2^.buff[axis] then
      begin
        if p1^.Index = p2^.Index then
            Result := 0
        else if p1^.Index < p2^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.buff[axis] < p2^.buff[axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT8DI16_SourceBuffer; L, R: NativeInt; const axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT8DI16_Source;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer^[(L + R) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, axis) < 0 do
            Inc(i);
        while SortCompare(SortBuffer^[j], p, axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, axis);
      L := i;
    until i >= R;
  end;

var
  M: NativeInt;
  axis: NativeInt;
  kdBuffPtr: PKDT8DI16_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      new(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.Vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);
    end
  else
    begin
      axis := Depth mod KDT8DI16_Axis;
      M := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr^[0], 0, PlanCount - 1, axis);

      new(Result);
      Result^.Parent := nil;
      Result^.Vec := kdBuffPtr^[M];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], M, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[M + 1], PlanCount - (M + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT8DI16.GetData(const Index: NativeInt): PKDT8DI16_Source;
begin
  Result := @KDStoreBuff[Index];
end;

constructor TKDT8DI16.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT8DI16.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT8DI16.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT8DI16_Node(KDNodes[i]));
      Inc(i);
    end;

  for i := 0 to length(KDStoreBuff) - 1 do
      KDStoreBuff[i].Token := '';

  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT8DI16.StoreBuffPtr: PKDT8DI16_DyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT8DI16.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT8DI16_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT8DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT8DI16.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT8DI16_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT8DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT8DI16.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT8DI16_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT8DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{ k-means++ clusterization }
procedure TKDT8DI16.BuildKDTreeWithCluster(const inBuff: TKDT8DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  SetLength(Source, length(inBuff), KDT8DI16_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT8DI16_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT8DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT8DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT8DI16.BuildKDTreeWithCluster(const inBuff: TKDT8DI16_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TKMIntegerArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT8DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT8DI16_BuildCall);
var
  TempStoreBuff: TKDT8DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT8DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT8DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT8DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT8DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT8DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT8DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT8DI16_BuildMethod);
var
  TempStoreBuff: TKDT8DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT8DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT8DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT8DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT8DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT8DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT8DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT8DI16_BuildProc);
var
  TempStoreBuff: TKDT8DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT8DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT8DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT8DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT8DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT8DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

function TKDT8DI16.Search(const buff: TKDT8DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT8DI16_Node;

var
  NearestNeighbour: PKDT8DI16_Node;

  function FindParentNode(const buffPtr: PKDT8DI16_Vec; NodePtr: PKDT8DI16_Node): PKDT8DI16_Node;
  var
    Next: PKDT8DI16_Node;
    Depth, axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        axis := Depth mod KDT8DI16_Axis;
        if buffPtr^[axis] > Next^.Vec^.buff[axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT8DI16_Node; const buffPtr: PKDT8DI16_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    Inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := Distance(buffPtr^, NodePtr^.Vec^.buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.Vec^.Index < NearestNeighbour^.Vec^.Index) then
        NearestNeighbour := NodePtr;

    axis := Depth mod KDT8DI16_Axis;
    Dist := NodePtr^.Vec^.buff[axis] - buffPtr^[axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.Vec^.buff[axis] > buffPtr^[axis] then
            ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const buffPtr: PKDT8DI16_Vec; const p1, p2: PKDT8DI16_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := Distance(buffPtr^, p1^.Vec^.buff);
    d2 := Distance(buffPtr^, p2^.Vec^.buff);
    if d1 = d2 then
      begin
        if p1^.Vec^.Index = p2^.Vec^.Index then
            Result := 0
        else if p1^.Vec^.Index < p2^.Vec^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; L, R: NativeInt; const buffPtr: PKDT8DI16_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT8DI16_Node;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer[(L + R) shr 1];
      repeat
        while SortCompare(buffPtr, SortBuffer[i], p) < 0 do
            Inc(i);
        while SortCompare(buffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, buffPtr);
      L := i;
    until i >= R;
  end;

var
  Parent: PKDT8DI16_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := Distance(buff, Parent^.Vec^.buff);

  ScanSubtree(RootNode, @buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT8DI16_Node(NearestNodes[0]);
    end;
end;

function TKDT8DI16.Search(const buff: TKDT8DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT8DI16_Node;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT8DI16.Search(const buff: TKDT8DI16_Vec; var SearchedDistanceMin: Double): PKDT8DI16_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT8DI16.Search(const buff: TKDT8DI16_Vec): PKDT8DI16_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT8DI16.SearchToken(const buff: TKDT8DI16_Vec): TPascalString;
var
  p: PKDT8DI16_Node;
begin
  p := Search(buff);
  if p <> nil then
      Result := p^.Vec^.Token
  else
      Result := '';
end;

procedure TKDT8DI16.Search(const inBuff: TKDT8DI16_DynamicVecBuffer; var OutBuff: TKDT8DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT8DI16_DynamicVecBuffer;
  outBuffPtr: PKDT8DI16_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT8DI16_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outBuffPtr^[pass] := p^.Vec^.buff;
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT8DI16_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outBuffPtr^[pass] := p^.Vec^.buff;
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT8DI16_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.Vec^.buff;
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT8DI16.Search(const inBuff: TKDT8DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT8DI16_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT8DI16_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT8DI16_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT8DI16_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT8DI16.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  ID := KDT8DI16_Axis;

  stream.write(st, 4);
  stream.write(ID, 4);

  stream.write(cnt, 8);

  i := 0;
  while i < cnt do
    begin
      stream.write(KDStoreBuff[i].buff[0], SizeOf(TKDT8DI16_Vec));
      stream.write(KDStoreBuff[i].Index, 8);
      token_B := KDStoreBuff[i].Token.Bytes;
      token_L := length(token_B);
      stream.write(token_L, 4);
      if token_L > 0 then
        begin
          stream.write(token_B[0], token_L);
          SetLength(token_B, 0);
        end;
      Inc(i);
    end;
end;

procedure TKDT8DI16.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  Clear;

  stream.read(st, 4);
  stream.read(ID, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if ID <> KDT8DI16_Axis then
      RaiseInfo('kdtree axis error!');

  stream.read(cnt, 8);

  SetLength(KDStoreBuff, cnt);

  i := 0;
  try
    while i < cnt do
      begin
        if stream.read(KDStoreBuff[i].buff[0], SizeOf(TKDT8DI16_Vec)) <> SizeOf(TKDT8DI16_Vec) then
          begin
            Clear;
            Exit;
          end;
        if stream.read(KDStoreBuff[i].Index, 8) <> 8 then
          begin
            Clear;
            Exit;
          end;
        if stream.read(token_L, 4) <> 4 then
          begin
            Clear;
            Exit;
          end;
        if token_L > 0 then
          begin
            SetLength(token_B, token_L);
            if stream.read(token_B[0], token_L) <> token_L then
              begin
                Clear;
                Exit;
              end;
            KDStoreBuff[i].Token.Bytes := token_B;
            SetLength(token_B, 0);
          end
        else
            KDStoreBuff[i].Token := '';
        Inc(i);
      end;
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      Inc(i);
    end;

  if cnt > 0 then
      RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT8DI16.SaveToFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(FileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT8DI16.LoadFromFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT8DI16.PrintNodeTree(const NodePtr: PKDT8DI16_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT8DI16_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.Vec^.Index, Vec(p^.Vec^.buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT8DI16.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d - %d : %s ', [i, KDStoreBuff[i].Index, Vec(KDStoreBuff[i].buff)]);
end;

class function TKDT8DI16.Vec(const s: SystemString): TKDT8DI16_Vec;
var
  t: TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j: NativeInt;
begin
  for i := 0 to KDT8DI16_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            Inc(j);
            if j >= KDT8DI16_Axis then
                Break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT8DI16.Vec(const v: TKDT8DI16_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT8DI16_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT8DI16.Distance(const v1, v2: TKDT8DI16_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT8DI16_Axis - 1 do
      Result := Result + (v2[i] - v1[i]) * (v2[i] - v1[i]);
end;

procedure TKDT8DI16.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT8DI16_Source; const Data: Pointer);
begin
  Source.buff := TestBuff[IndexFor];
  Source.Token := umlIntToStr(IndexFor);
end;

class procedure TKDT8DI16.Test;
var
  TKDT8DI16_Test: TKDT8DI16;
  t: TTimeTick;
  i, j: NativeInt;
  TestResultBuff: TKDT8DI16_DynamicVecBuffer;
  TestResultIndex: TKMIntegerArray;
  KMeanOutIndex: TKMIntegerArray;
  errored: Boolean;
  m64: TMemoryStream64;
  p: PKDT8DI16_Node;
  n: TPascalString;
begin
  errored := False;
  n := PFormat('test %s...', [ClassName]);
  t := GetTimeTick;

  n.Append('...build');
  TKDT8DI16_Test := TKDT8DI16.Create;

  n.Append('...');
  SetLength(TKDT8DI16_Test.TestBuff, 1000);
  for i := 0 to length(TKDT8DI16_Test.TestBuff) - 1 do
    for j := 0 to KDT8DI16_Axis - 1 do
        TKDT8DI16_Test.TestBuff[i][j] := i * KDT8DI16_Axis + j;

{$IFDEF FPC}
  TKDT8DI16_Test.BuildKDTreeM(length(TKDT8DI16_Test.TestBuff), nil, @TKDT8DI16_Test.Test_BuildM);
{$ELSE FPC}
  TKDT8DI16_Test.BuildKDTreeM(length(TKDT8DI16_Test.TestBuff), nil, TKDT8DI16_Test.Test_BuildM);
{$ENDIF FPC}
  { save/load test }
  n.Append('...save/load');
  m64 := TMemoryStream64.CustomCreate(1024 * 1024);
  TKDT8DI16_Test.SaveToStream(m64);
  m64.Position := 0;
  TKDT8DI16_Test.LoadFromStream(m64);
  for i := 0 to length(TKDT8DI16_Test.TestBuff) - 1 do
    begin
      p := TKDT8DI16_Test.Search(TKDT8DI16_Test.TestBuff[i]);
      if p^.Vec^.Index <> i then
          errored := True;
      if not p^.Vec^.Token.Same(umlIntToStr(i)) then
          errored := True;
      if errored then
          Break;
    end;
  DisposeObject(m64);

  if not errored then
    begin
      { parallel search test }
      n.Append('...parallel');
      SetLength(TestResultBuff, length(TKDT8DI16_Test.TestBuff));
      SetLength(TestResultIndex, length(TKDT8DI16_Test.TestBuff));
      TKDT8DI16_Test.Search(TKDT8DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if Distance(TKDT8DI16_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
            errored := True;
    end;

  if not errored then
    begin
      n.Append('...kMean');
      TKDT8DI16_Test.Clear;
      { kMean test }
      TKDT8DI16_Test.BuildKDTreeWithCluster(TKDT8DI16_Test.TestBuff, 10, 1, KMeanOutIndex);
      { parallel search test }
      TKDT8DI16_Test.Search(TKDT8DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if TestResultIndex[i] <> KMeanOutIndex[i] then
            errored := True;
    end;

  SetLength(TKDT8DI16_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT8DI16_Test.Clear;

  n.Append('...');
  if errored then
      n.Append('error!')
  else
      n.Append('passed ok %dms', [GetTimeTick - t]);
  DisposeObject(TKDT8DI16_Test);
  DoStatus(n);
  n := '';
end;

function TKDT9DI16.InternalBuildKdTree(const KDSourceBufferPtr: PKDT9DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT9DI16_Node;
  function SortCompare(const p1, p2: PKDT9DI16_Source; const axis: NativeInt): ShortInt;
  begin
    if p1^.buff[axis] = p2^.buff[axis] then
      begin
        if p1^.Index = p2^.Index then
            Result := 0
        else if p1^.Index < p2^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.buff[axis] < p2^.buff[axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT9DI16_SourceBuffer; L, R: NativeInt; const axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT9DI16_Source;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer^[(L + R) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, axis) < 0 do
            Inc(i);
        while SortCompare(SortBuffer^[j], p, axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, axis);
      L := i;
    until i >= R;
  end;

var
  M: NativeInt;
  axis: NativeInt;
  kdBuffPtr: PKDT9DI16_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      new(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.Vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);
    end
  else
    begin
      axis := Depth mod KDT9DI16_Axis;
      M := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr^[0], 0, PlanCount - 1, axis);

      new(Result);
      Result^.Parent := nil;
      Result^.Vec := kdBuffPtr^[M];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], M, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[M + 1], PlanCount - (M + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT9DI16.GetData(const Index: NativeInt): PKDT9DI16_Source;
begin
  Result := @KDStoreBuff[Index];
end;

constructor TKDT9DI16.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT9DI16.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT9DI16.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT9DI16_Node(KDNodes[i]));
      Inc(i);
    end;

  for i := 0 to length(KDStoreBuff) - 1 do
      KDStoreBuff[i].Token := '';

  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT9DI16.StoreBuffPtr: PKDT9DI16_DyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT9DI16.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT9DI16_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT9DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT9DI16.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT9DI16_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT9DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT9DI16.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT9DI16_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT9DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{ k-means++ clusterization }
procedure TKDT9DI16.BuildKDTreeWithCluster(const inBuff: TKDT9DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  SetLength(Source, length(inBuff), KDT9DI16_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT9DI16_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT9DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT9DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT9DI16.BuildKDTreeWithCluster(const inBuff: TKDT9DI16_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TKMIntegerArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT9DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT9DI16_BuildCall);
var
  TempStoreBuff: TKDT9DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT9DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT9DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT9DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT9DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT9DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT9DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT9DI16_BuildMethod);
var
  TempStoreBuff: TKDT9DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT9DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT9DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT9DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT9DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT9DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT9DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT9DI16_BuildProc);
var
  TempStoreBuff: TKDT9DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT9DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT9DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT9DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT9DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT9DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

function TKDT9DI16.Search(const buff: TKDT9DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT9DI16_Node;

var
  NearestNeighbour: PKDT9DI16_Node;

  function FindParentNode(const buffPtr: PKDT9DI16_Vec; NodePtr: PKDT9DI16_Node): PKDT9DI16_Node;
  var
    Next: PKDT9DI16_Node;
    Depth, axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        axis := Depth mod KDT9DI16_Axis;
        if buffPtr^[axis] > Next^.Vec^.buff[axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT9DI16_Node; const buffPtr: PKDT9DI16_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    Inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := Distance(buffPtr^, NodePtr^.Vec^.buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.Vec^.Index < NearestNeighbour^.Vec^.Index) then
        NearestNeighbour := NodePtr;

    axis := Depth mod KDT9DI16_Axis;
    Dist := NodePtr^.Vec^.buff[axis] - buffPtr^[axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.Vec^.buff[axis] > buffPtr^[axis] then
            ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const buffPtr: PKDT9DI16_Vec; const p1, p2: PKDT9DI16_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := Distance(buffPtr^, p1^.Vec^.buff);
    d2 := Distance(buffPtr^, p2^.Vec^.buff);
    if d1 = d2 then
      begin
        if p1^.Vec^.Index = p2^.Vec^.Index then
            Result := 0
        else if p1^.Vec^.Index < p2^.Vec^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; L, R: NativeInt; const buffPtr: PKDT9DI16_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT9DI16_Node;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer[(L + R) shr 1];
      repeat
        while SortCompare(buffPtr, SortBuffer[i], p) < 0 do
            Inc(i);
        while SortCompare(buffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, buffPtr);
      L := i;
    until i >= R;
  end;

var
  Parent: PKDT9DI16_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := Distance(buff, Parent^.Vec^.buff);

  ScanSubtree(RootNode, @buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT9DI16_Node(NearestNodes[0]);
    end;
end;

function TKDT9DI16.Search(const buff: TKDT9DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT9DI16_Node;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT9DI16.Search(const buff: TKDT9DI16_Vec; var SearchedDistanceMin: Double): PKDT9DI16_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT9DI16.Search(const buff: TKDT9DI16_Vec): PKDT9DI16_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT9DI16.SearchToken(const buff: TKDT9DI16_Vec): TPascalString;
var
  p: PKDT9DI16_Node;
begin
  p := Search(buff);
  if p <> nil then
      Result := p^.Vec^.Token
  else
      Result := '';
end;

procedure TKDT9DI16.Search(const inBuff: TKDT9DI16_DynamicVecBuffer; var OutBuff: TKDT9DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT9DI16_DynamicVecBuffer;
  outBuffPtr: PKDT9DI16_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT9DI16_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outBuffPtr^[pass] := p^.Vec^.buff;
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT9DI16_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outBuffPtr^[pass] := p^.Vec^.buff;
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT9DI16_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.Vec^.buff;
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT9DI16.Search(const inBuff: TKDT9DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT9DI16_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT9DI16_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT9DI16_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT9DI16_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT9DI16.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  ID := KDT9DI16_Axis;

  stream.write(st, 4);
  stream.write(ID, 4);

  stream.write(cnt, 8);

  i := 0;
  while i < cnt do
    begin
      stream.write(KDStoreBuff[i].buff[0], SizeOf(TKDT9DI16_Vec));
      stream.write(KDStoreBuff[i].Index, 8);
      token_B := KDStoreBuff[i].Token.Bytes;
      token_L := length(token_B);
      stream.write(token_L, 4);
      if token_L > 0 then
        begin
          stream.write(token_B[0], token_L);
          SetLength(token_B, 0);
        end;
      Inc(i);
    end;
end;

procedure TKDT9DI16.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  Clear;

  stream.read(st, 4);
  stream.read(ID, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if ID <> KDT9DI16_Axis then
      RaiseInfo('kdtree axis error!');

  stream.read(cnt, 8);

  SetLength(KDStoreBuff, cnt);

  i := 0;
  try
    while i < cnt do
      begin
        if stream.read(KDStoreBuff[i].buff[0], SizeOf(TKDT9DI16_Vec)) <> SizeOf(TKDT9DI16_Vec) then
          begin
            Clear;
            Exit;
          end;
        if stream.read(KDStoreBuff[i].Index, 8) <> 8 then
          begin
            Clear;
            Exit;
          end;
        if stream.read(token_L, 4) <> 4 then
          begin
            Clear;
            Exit;
          end;
        if token_L > 0 then
          begin
            SetLength(token_B, token_L);
            if stream.read(token_B[0], token_L) <> token_L then
              begin
                Clear;
                Exit;
              end;
            KDStoreBuff[i].Token.Bytes := token_B;
            SetLength(token_B, 0);
          end
        else
            KDStoreBuff[i].Token := '';
        Inc(i);
      end;
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      Inc(i);
    end;

  if cnt > 0 then
      RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT9DI16.SaveToFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(FileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT9DI16.LoadFromFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT9DI16.PrintNodeTree(const NodePtr: PKDT9DI16_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT9DI16_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.Vec^.Index, Vec(p^.Vec^.buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT9DI16.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d - %d : %s ', [i, KDStoreBuff[i].Index, Vec(KDStoreBuff[i].buff)]);
end;

class function TKDT9DI16.Vec(const s: SystemString): TKDT9DI16_Vec;
var
  t: TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j: NativeInt;
begin
  for i := 0 to KDT9DI16_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            Inc(j);
            if j >= KDT9DI16_Axis then
                Break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT9DI16.Vec(const v: TKDT9DI16_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT9DI16_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT9DI16.Distance(const v1, v2: TKDT9DI16_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT9DI16_Axis - 1 do
      Result := Result + (v2[i] - v1[i]) * (v2[i] - v1[i]);
end;

procedure TKDT9DI16.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT9DI16_Source; const Data: Pointer);
begin
  Source.buff := TestBuff[IndexFor];
  Source.Token := umlIntToStr(IndexFor);
end;

class procedure TKDT9DI16.Test;
var
  TKDT9DI16_Test: TKDT9DI16;
  t: TTimeTick;
  i, j: NativeInt;
  TestResultBuff: TKDT9DI16_DynamicVecBuffer;
  TestResultIndex: TKMIntegerArray;
  KMeanOutIndex: TKMIntegerArray;
  errored: Boolean;
  m64: TMemoryStream64;
  p: PKDT9DI16_Node;
  n: TPascalString;
begin
  errored := False;
  n := PFormat('test %s...', [ClassName]);
  t := GetTimeTick;

  n.Append('...build');
  TKDT9DI16_Test := TKDT9DI16.Create;

  n.Append('...');
  SetLength(TKDT9DI16_Test.TestBuff, 1000);
  for i := 0 to length(TKDT9DI16_Test.TestBuff) - 1 do
    for j := 0 to KDT9DI16_Axis - 1 do
        TKDT9DI16_Test.TestBuff[i][j] := i * KDT9DI16_Axis + j;

{$IFDEF FPC}
  TKDT9DI16_Test.BuildKDTreeM(length(TKDT9DI16_Test.TestBuff), nil, @TKDT9DI16_Test.Test_BuildM);
{$ELSE FPC}
  TKDT9DI16_Test.BuildKDTreeM(length(TKDT9DI16_Test.TestBuff), nil, TKDT9DI16_Test.Test_BuildM);
{$ENDIF FPC}
  { save/load test }
  n.Append('...save/load');
  m64 := TMemoryStream64.CustomCreate(1024 * 1024);
  TKDT9DI16_Test.SaveToStream(m64);
  m64.Position := 0;
  TKDT9DI16_Test.LoadFromStream(m64);
  for i := 0 to length(TKDT9DI16_Test.TestBuff) - 1 do
    begin
      p := TKDT9DI16_Test.Search(TKDT9DI16_Test.TestBuff[i]);
      if p^.Vec^.Index <> i then
          errored := True;
      if not p^.Vec^.Token.Same(umlIntToStr(i)) then
          errored := True;
      if errored then
          Break;
    end;
  DisposeObject(m64);

  if not errored then
    begin
      { parallel search test }
      n.Append('...parallel');
      SetLength(TestResultBuff, length(TKDT9DI16_Test.TestBuff));
      SetLength(TestResultIndex, length(TKDT9DI16_Test.TestBuff));
      TKDT9DI16_Test.Search(TKDT9DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if Distance(TKDT9DI16_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
            errored := True;
    end;

  if not errored then
    begin
      n.Append('...kMean');
      TKDT9DI16_Test.Clear;
      { kMean test }
      TKDT9DI16_Test.BuildKDTreeWithCluster(TKDT9DI16_Test.TestBuff, 10, 1, KMeanOutIndex);
      { parallel search test }
      TKDT9DI16_Test.Search(TKDT9DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if TestResultIndex[i] <> KMeanOutIndex[i] then
            errored := True;
    end;

  SetLength(TKDT9DI16_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT9DI16_Test.Clear;

  n.Append('...');
  if errored then
      n.Append('error!')
  else
      n.Append('passed ok %dms', [GetTimeTick - t]);
  DisposeObject(TKDT9DI16_Test);
  DoStatus(n);
  n := '';
end;

function TKDT10DI16.InternalBuildKdTree(const KDSourceBufferPtr: PKDT10DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT10DI16_Node;
  function SortCompare(const p1, p2: PKDT10DI16_Source; const axis: NativeInt): ShortInt;
  begin
    if p1^.buff[axis] = p2^.buff[axis] then
      begin
        if p1^.Index = p2^.Index then
            Result := 0
        else if p1^.Index < p2^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.buff[axis] < p2^.buff[axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT10DI16_SourceBuffer; L, R: NativeInt; const axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT10DI16_Source;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer^[(L + R) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, axis) < 0 do
            Inc(i);
        while SortCompare(SortBuffer^[j], p, axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, axis);
      L := i;
    until i >= R;
  end;

var
  M: NativeInt;
  axis: NativeInt;
  kdBuffPtr: PKDT10DI16_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      new(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.Vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);
    end
  else
    begin
      axis := Depth mod KDT10DI16_Axis;
      M := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr^[0], 0, PlanCount - 1, axis);

      new(Result);
      Result^.Parent := nil;
      Result^.Vec := kdBuffPtr^[M];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], M, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[M + 1], PlanCount - (M + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT10DI16.GetData(const Index: NativeInt): PKDT10DI16_Source;
begin
  Result := @KDStoreBuff[Index];
end;

constructor TKDT10DI16.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT10DI16.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT10DI16.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT10DI16_Node(KDNodes[i]));
      Inc(i);
    end;

  for i := 0 to length(KDStoreBuff) - 1 do
      KDStoreBuff[i].Token := '';

  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT10DI16.StoreBuffPtr: PKDT10DI16_DyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT10DI16.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT10DI16_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT10DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT10DI16.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT10DI16_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT10DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT10DI16.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT10DI16_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT10DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{ k-means++ clusterization }
procedure TKDT10DI16.BuildKDTreeWithCluster(const inBuff: TKDT10DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  SetLength(Source, length(inBuff), KDT10DI16_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT10DI16_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT10DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT10DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT10DI16.BuildKDTreeWithCluster(const inBuff: TKDT10DI16_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TKMIntegerArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT10DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT10DI16_BuildCall);
var
  TempStoreBuff: TKDT10DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT10DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT10DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT10DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT10DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT10DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT10DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT10DI16_BuildMethod);
var
  TempStoreBuff: TKDT10DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT10DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT10DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT10DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT10DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT10DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT10DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT10DI16_BuildProc);
var
  TempStoreBuff: TKDT10DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT10DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT10DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT10DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT10DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT10DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

function TKDT10DI16.Search(const buff: TKDT10DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT10DI16_Node;

var
  NearestNeighbour: PKDT10DI16_Node;

  function FindParentNode(const buffPtr: PKDT10DI16_Vec; NodePtr: PKDT10DI16_Node): PKDT10DI16_Node;
  var
    Next: PKDT10DI16_Node;
    Depth, axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        axis := Depth mod KDT10DI16_Axis;
        if buffPtr^[axis] > Next^.Vec^.buff[axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT10DI16_Node; const buffPtr: PKDT10DI16_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    Inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := Distance(buffPtr^, NodePtr^.Vec^.buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.Vec^.Index < NearestNeighbour^.Vec^.Index) then
        NearestNeighbour := NodePtr;

    axis := Depth mod KDT10DI16_Axis;
    Dist := NodePtr^.Vec^.buff[axis] - buffPtr^[axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.Vec^.buff[axis] > buffPtr^[axis] then
            ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const buffPtr: PKDT10DI16_Vec; const p1, p2: PKDT10DI16_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := Distance(buffPtr^, p1^.Vec^.buff);
    d2 := Distance(buffPtr^, p2^.Vec^.buff);
    if d1 = d2 then
      begin
        if p1^.Vec^.Index = p2^.Vec^.Index then
            Result := 0
        else if p1^.Vec^.Index < p2^.Vec^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; L, R: NativeInt; const buffPtr: PKDT10DI16_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT10DI16_Node;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer[(L + R) shr 1];
      repeat
        while SortCompare(buffPtr, SortBuffer[i], p) < 0 do
            Inc(i);
        while SortCompare(buffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, buffPtr);
      L := i;
    until i >= R;
  end;

var
  Parent: PKDT10DI16_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := Distance(buff, Parent^.Vec^.buff);

  ScanSubtree(RootNode, @buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT10DI16_Node(NearestNodes[0]);
    end;
end;

function TKDT10DI16.Search(const buff: TKDT10DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT10DI16_Node;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT10DI16.Search(const buff: TKDT10DI16_Vec; var SearchedDistanceMin: Double): PKDT10DI16_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT10DI16.Search(const buff: TKDT10DI16_Vec): PKDT10DI16_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT10DI16.SearchToken(const buff: TKDT10DI16_Vec): TPascalString;
var
  p: PKDT10DI16_Node;
begin
  p := Search(buff);
  if p <> nil then
      Result := p^.Vec^.Token
  else
      Result := '';
end;

procedure TKDT10DI16.Search(const inBuff: TKDT10DI16_DynamicVecBuffer; var OutBuff: TKDT10DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT10DI16_DynamicVecBuffer;
  outBuffPtr: PKDT10DI16_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT10DI16_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outBuffPtr^[pass] := p^.Vec^.buff;
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT10DI16_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outBuffPtr^[pass] := p^.Vec^.buff;
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT10DI16_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.Vec^.buff;
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT10DI16.Search(const inBuff: TKDT10DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT10DI16_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT10DI16_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT10DI16_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT10DI16_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT10DI16.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  ID := KDT10DI16_Axis;

  stream.write(st, 4);
  stream.write(ID, 4);

  stream.write(cnt, 8);

  i := 0;
  while i < cnt do
    begin
      stream.write(KDStoreBuff[i].buff[0], SizeOf(TKDT10DI16_Vec));
      stream.write(KDStoreBuff[i].Index, 8);
      token_B := KDStoreBuff[i].Token.Bytes;
      token_L := length(token_B);
      stream.write(token_L, 4);
      if token_L > 0 then
        begin
          stream.write(token_B[0], token_L);
          SetLength(token_B, 0);
        end;
      Inc(i);
    end;
end;

procedure TKDT10DI16.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  Clear;

  stream.read(st, 4);
  stream.read(ID, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if ID <> KDT10DI16_Axis then
      RaiseInfo('kdtree axis error!');

  stream.read(cnt, 8);

  SetLength(KDStoreBuff, cnt);

  i := 0;
  try
    while i < cnt do
      begin
        if stream.read(KDStoreBuff[i].buff[0], SizeOf(TKDT10DI16_Vec)) <> SizeOf(TKDT10DI16_Vec) then
          begin
            Clear;
            Exit;
          end;
        if stream.read(KDStoreBuff[i].Index, 8) <> 8 then
          begin
            Clear;
            Exit;
          end;
        if stream.read(token_L, 4) <> 4 then
          begin
            Clear;
            Exit;
          end;
        if token_L > 0 then
          begin
            SetLength(token_B, token_L);
            if stream.read(token_B[0], token_L) <> token_L then
              begin
                Clear;
                Exit;
              end;
            KDStoreBuff[i].Token.Bytes := token_B;
            SetLength(token_B, 0);
          end
        else
            KDStoreBuff[i].Token := '';
        Inc(i);
      end;
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      Inc(i);
    end;

  if cnt > 0 then
      RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT10DI16.SaveToFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(FileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT10DI16.LoadFromFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT10DI16.PrintNodeTree(const NodePtr: PKDT10DI16_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT10DI16_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.Vec^.Index, Vec(p^.Vec^.buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT10DI16.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d - %d : %s ', [i, KDStoreBuff[i].Index, Vec(KDStoreBuff[i].buff)]);
end;

class function TKDT10DI16.Vec(const s: SystemString): TKDT10DI16_Vec;
var
  t: TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j: NativeInt;
begin
  for i := 0 to KDT10DI16_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            Inc(j);
            if j >= KDT10DI16_Axis then
                Break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT10DI16.Vec(const v: TKDT10DI16_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT10DI16_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT10DI16.Distance(const v1, v2: TKDT10DI16_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT10DI16_Axis - 1 do
      Result := Result + (v2[i] - v1[i]) * (v2[i] - v1[i]);
end;

procedure TKDT10DI16.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT10DI16_Source; const Data: Pointer);
begin
  Source.buff := TestBuff[IndexFor];
  Source.Token := umlIntToStr(IndexFor);
end;

class procedure TKDT10DI16.Test;
var
  TKDT10DI16_Test: TKDT10DI16;
  t: TTimeTick;
  i, j: NativeInt;
  TestResultBuff: TKDT10DI16_DynamicVecBuffer;
  TestResultIndex: TKMIntegerArray;
  KMeanOutIndex: TKMIntegerArray;
  errored: Boolean;
  m64: TMemoryStream64;
  p: PKDT10DI16_Node;
  n: TPascalString;
begin
  errored := False;
  n := PFormat('test %s...', [ClassName]);
  t := GetTimeTick;

  n.Append('...build');
  TKDT10DI16_Test := TKDT10DI16.Create;

  n.Append('...');
  SetLength(TKDT10DI16_Test.TestBuff, 1000);
  for i := 0 to length(TKDT10DI16_Test.TestBuff) - 1 do
    for j := 0 to KDT10DI16_Axis - 1 do
        TKDT10DI16_Test.TestBuff[i][j] := i * KDT10DI16_Axis + j;

{$IFDEF FPC}
  TKDT10DI16_Test.BuildKDTreeM(length(TKDT10DI16_Test.TestBuff), nil, @TKDT10DI16_Test.Test_BuildM);
{$ELSE FPC}
  TKDT10DI16_Test.BuildKDTreeM(length(TKDT10DI16_Test.TestBuff), nil, TKDT10DI16_Test.Test_BuildM);
{$ENDIF FPC}
  { save/load test }
  n.Append('...save/load');
  m64 := TMemoryStream64.CustomCreate(1024 * 1024);
  TKDT10DI16_Test.SaveToStream(m64);
  m64.Position := 0;
  TKDT10DI16_Test.LoadFromStream(m64);
  for i := 0 to length(TKDT10DI16_Test.TestBuff) - 1 do
    begin
      p := TKDT10DI16_Test.Search(TKDT10DI16_Test.TestBuff[i]);
      if p^.Vec^.Index <> i then
          errored := True;
      if not p^.Vec^.Token.Same(umlIntToStr(i)) then
          errored := True;
      if errored then
          Break;
    end;
  DisposeObject(m64);

  if not errored then
    begin
      { parallel search test }
      n.Append('...parallel');
      SetLength(TestResultBuff, length(TKDT10DI16_Test.TestBuff));
      SetLength(TestResultIndex, length(TKDT10DI16_Test.TestBuff));
      TKDT10DI16_Test.Search(TKDT10DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if Distance(TKDT10DI16_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
            errored := True;
    end;

  if not errored then
    begin
      n.Append('...kMean');
      TKDT10DI16_Test.Clear;
      { kMean test }
      TKDT10DI16_Test.BuildKDTreeWithCluster(TKDT10DI16_Test.TestBuff, 10, 1, KMeanOutIndex);
      { parallel search test }
      TKDT10DI16_Test.Search(TKDT10DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if TestResultIndex[i] <> KMeanOutIndex[i] then
            errored := True;
    end;

  SetLength(TKDT10DI16_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT10DI16_Test.Clear;

  n.Append('...');
  if errored then
      n.Append('error!')
  else
      n.Append('passed ok %dms', [GetTimeTick - t]);
  DisposeObject(TKDT10DI16_Test);
  DoStatus(n);
  n := '';
end;

function TKDT11DI16.InternalBuildKdTree(const KDSourceBufferPtr: PKDT11DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT11DI16_Node;
  function SortCompare(const p1, p2: PKDT11DI16_Source; const axis: NativeInt): ShortInt;
  begin
    if p1^.buff[axis] = p2^.buff[axis] then
      begin
        if p1^.Index = p2^.Index then
            Result := 0
        else if p1^.Index < p2^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.buff[axis] < p2^.buff[axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT11DI16_SourceBuffer; L, R: NativeInt; const axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT11DI16_Source;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer^[(L + R) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, axis) < 0 do
            Inc(i);
        while SortCompare(SortBuffer^[j], p, axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, axis);
      L := i;
    until i >= R;
  end;

var
  M: NativeInt;
  axis: NativeInt;
  kdBuffPtr: PKDT11DI16_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      new(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.Vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);
    end
  else
    begin
      axis := Depth mod KDT11DI16_Axis;
      M := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr^[0], 0, PlanCount - 1, axis);

      new(Result);
      Result^.Parent := nil;
      Result^.Vec := kdBuffPtr^[M];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], M, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[M + 1], PlanCount - (M + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT11DI16.GetData(const Index: NativeInt): PKDT11DI16_Source;
begin
  Result := @KDStoreBuff[Index];
end;

constructor TKDT11DI16.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT11DI16.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT11DI16.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT11DI16_Node(KDNodes[i]));
      Inc(i);
    end;

  for i := 0 to length(KDStoreBuff) - 1 do
      KDStoreBuff[i].Token := '';

  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT11DI16.StoreBuffPtr: PKDT11DI16_DyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT11DI16.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT11DI16_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT11DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT11DI16.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT11DI16_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT11DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT11DI16.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT11DI16_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT11DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{ k-means++ clusterization }
procedure TKDT11DI16.BuildKDTreeWithCluster(const inBuff: TKDT11DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  SetLength(Source, length(inBuff), KDT11DI16_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT11DI16_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT11DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT11DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT11DI16.BuildKDTreeWithCluster(const inBuff: TKDT11DI16_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TKMIntegerArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT11DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT11DI16_BuildCall);
var
  TempStoreBuff: TKDT11DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT11DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT11DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT11DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT11DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT11DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT11DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT11DI16_BuildMethod);
var
  TempStoreBuff: TKDT11DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT11DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT11DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT11DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT11DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT11DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT11DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT11DI16_BuildProc);
var
  TempStoreBuff: TKDT11DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT11DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT11DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT11DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT11DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT11DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

function TKDT11DI16.Search(const buff: TKDT11DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT11DI16_Node;

var
  NearestNeighbour: PKDT11DI16_Node;

  function FindParentNode(const buffPtr: PKDT11DI16_Vec; NodePtr: PKDT11DI16_Node): PKDT11DI16_Node;
  var
    Next: PKDT11DI16_Node;
    Depth, axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        axis := Depth mod KDT11DI16_Axis;
        if buffPtr^[axis] > Next^.Vec^.buff[axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT11DI16_Node; const buffPtr: PKDT11DI16_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    Inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := Distance(buffPtr^, NodePtr^.Vec^.buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.Vec^.Index < NearestNeighbour^.Vec^.Index) then
        NearestNeighbour := NodePtr;

    axis := Depth mod KDT11DI16_Axis;
    Dist := NodePtr^.Vec^.buff[axis] - buffPtr^[axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.Vec^.buff[axis] > buffPtr^[axis] then
            ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const buffPtr: PKDT11DI16_Vec; const p1, p2: PKDT11DI16_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := Distance(buffPtr^, p1^.Vec^.buff);
    d2 := Distance(buffPtr^, p2^.Vec^.buff);
    if d1 = d2 then
      begin
        if p1^.Vec^.Index = p2^.Vec^.Index then
            Result := 0
        else if p1^.Vec^.Index < p2^.Vec^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; L, R: NativeInt; const buffPtr: PKDT11DI16_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT11DI16_Node;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer[(L + R) shr 1];
      repeat
        while SortCompare(buffPtr, SortBuffer[i], p) < 0 do
            Inc(i);
        while SortCompare(buffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, buffPtr);
      L := i;
    until i >= R;
  end;

var
  Parent: PKDT11DI16_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := Distance(buff, Parent^.Vec^.buff);

  ScanSubtree(RootNode, @buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT11DI16_Node(NearestNodes[0]);
    end;
end;

function TKDT11DI16.Search(const buff: TKDT11DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT11DI16_Node;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT11DI16.Search(const buff: TKDT11DI16_Vec; var SearchedDistanceMin: Double): PKDT11DI16_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT11DI16.Search(const buff: TKDT11DI16_Vec): PKDT11DI16_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT11DI16.SearchToken(const buff: TKDT11DI16_Vec): TPascalString;
var
  p: PKDT11DI16_Node;
begin
  p := Search(buff);
  if p <> nil then
      Result := p^.Vec^.Token
  else
      Result := '';
end;

procedure TKDT11DI16.Search(const inBuff: TKDT11DI16_DynamicVecBuffer; var OutBuff: TKDT11DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT11DI16_DynamicVecBuffer;
  outBuffPtr: PKDT11DI16_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT11DI16_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outBuffPtr^[pass] := p^.Vec^.buff;
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT11DI16_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outBuffPtr^[pass] := p^.Vec^.buff;
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT11DI16_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.Vec^.buff;
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT11DI16.Search(const inBuff: TKDT11DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT11DI16_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT11DI16_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT11DI16_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT11DI16_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT11DI16.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  ID := KDT11DI16_Axis;

  stream.write(st, 4);
  stream.write(ID, 4);

  stream.write(cnt, 8);

  i := 0;
  while i < cnt do
    begin
      stream.write(KDStoreBuff[i].buff[0], SizeOf(TKDT11DI16_Vec));
      stream.write(KDStoreBuff[i].Index, 8);
      token_B := KDStoreBuff[i].Token.Bytes;
      token_L := length(token_B);
      stream.write(token_L, 4);
      if token_L > 0 then
        begin
          stream.write(token_B[0], token_L);
          SetLength(token_B, 0);
        end;
      Inc(i);
    end;
end;

procedure TKDT11DI16.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  Clear;

  stream.read(st, 4);
  stream.read(ID, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if ID <> KDT11DI16_Axis then
      RaiseInfo('kdtree axis error!');

  stream.read(cnt, 8);

  SetLength(KDStoreBuff, cnt);

  i := 0;
  try
    while i < cnt do
      begin
        if stream.read(KDStoreBuff[i].buff[0], SizeOf(TKDT11DI16_Vec)) <> SizeOf(TKDT11DI16_Vec) then
          begin
            Clear;
            Exit;
          end;
        if stream.read(KDStoreBuff[i].Index, 8) <> 8 then
          begin
            Clear;
            Exit;
          end;
        if stream.read(token_L, 4) <> 4 then
          begin
            Clear;
            Exit;
          end;
        if token_L > 0 then
          begin
            SetLength(token_B, token_L);
            if stream.read(token_B[0], token_L) <> token_L then
              begin
                Clear;
                Exit;
              end;
            KDStoreBuff[i].Token.Bytes := token_B;
            SetLength(token_B, 0);
          end
        else
            KDStoreBuff[i].Token := '';
        Inc(i);
      end;
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      Inc(i);
    end;

  if cnt > 0 then
      RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT11DI16.SaveToFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(FileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT11DI16.LoadFromFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT11DI16.PrintNodeTree(const NodePtr: PKDT11DI16_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT11DI16_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.Vec^.Index, Vec(p^.Vec^.buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT11DI16.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d - %d : %s ', [i, KDStoreBuff[i].Index, Vec(KDStoreBuff[i].buff)]);
end;

class function TKDT11DI16.Vec(const s: SystemString): TKDT11DI16_Vec;
var
  t: TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j: NativeInt;
begin
  for i := 0 to KDT11DI16_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            Inc(j);
            if j >= KDT11DI16_Axis then
                Break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT11DI16.Vec(const v: TKDT11DI16_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT11DI16_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT11DI16.Distance(const v1, v2: TKDT11DI16_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT11DI16_Axis - 1 do
      Result := Result + (v2[i] - v1[i]) * (v2[i] - v1[i]);
end;

procedure TKDT11DI16.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT11DI16_Source; const Data: Pointer);
begin
  Source.buff := TestBuff[IndexFor];
  Source.Token := umlIntToStr(IndexFor);
end;

class procedure TKDT11DI16.Test;
var
  TKDT11DI16_Test: TKDT11DI16;
  t: TTimeTick;
  i, j: NativeInt;
  TestResultBuff: TKDT11DI16_DynamicVecBuffer;
  TestResultIndex: TKMIntegerArray;
  KMeanOutIndex: TKMIntegerArray;
  errored: Boolean;
  m64: TMemoryStream64;
  p: PKDT11DI16_Node;
  n: TPascalString;
begin
  errored := False;
  n := PFormat('test %s...', [ClassName]);
  t := GetTimeTick;

  n.Append('...build');
  TKDT11DI16_Test := TKDT11DI16.Create;

  n.Append('...');
  SetLength(TKDT11DI16_Test.TestBuff, 1000);
  for i := 0 to length(TKDT11DI16_Test.TestBuff) - 1 do
    for j := 0 to KDT11DI16_Axis - 1 do
        TKDT11DI16_Test.TestBuff[i][j] := i * KDT11DI16_Axis + j;

{$IFDEF FPC}
  TKDT11DI16_Test.BuildKDTreeM(length(TKDT11DI16_Test.TestBuff), nil, @TKDT11DI16_Test.Test_BuildM);
{$ELSE FPC}
  TKDT11DI16_Test.BuildKDTreeM(length(TKDT11DI16_Test.TestBuff), nil, TKDT11DI16_Test.Test_BuildM);
{$ENDIF FPC}
  { save/load test }
  n.Append('...save/load');
  m64 := TMemoryStream64.CustomCreate(1024 * 1024);
  TKDT11DI16_Test.SaveToStream(m64);
  m64.Position := 0;
  TKDT11DI16_Test.LoadFromStream(m64);
  for i := 0 to length(TKDT11DI16_Test.TestBuff) - 1 do
    begin
      p := TKDT11DI16_Test.Search(TKDT11DI16_Test.TestBuff[i]);
      if p^.Vec^.Index <> i then
          errored := True;
      if not p^.Vec^.Token.Same(umlIntToStr(i)) then
          errored := True;
      if errored then
          Break;
    end;
  DisposeObject(m64);

  if not errored then
    begin
      { parallel search test }
      n.Append('...parallel');
      SetLength(TestResultBuff, length(TKDT11DI16_Test.TestBuff));
      SetLength(TestResultIndex, length(TKDT11DI16_Test.TestBuff));
      TKDT11DI16_Test.Search(TKDT11DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if Distance(TKDT11DI16_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
            errored := True;
    end;

  if not errored then
    begin
      n.Append('...kMean');
      TKDT11DI16_Test.Clear;
      { kMean test }
      TKDT11DI16_Test.BuildKDTreeWithCluster(TKDT11DI16_Test.TestBuff, 10, 1, KMeanOutIndex);
      { parallel search test }
      TKDT11DI16_Test.Search(TKDT11DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if TestResultIndex[i] <> KMeanOutIndex[i] then
            errored := True;
    end;

  SetLength(TKDT11DI16_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT11DI16_Test.Clear;

  n.Append('...');
  if errored then
      n.Append('error!')
  else
      n.Append('passed ok %dms', [GetTimeTick - t]);
  DisposeObject(TKDT11DI16_Test);
  DoStatus(n);
  n := '';
end;

function TKDT12DI16.InternalBuildKdTree(const KDSourceBufferPtr: PKDT12DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT12DI16_Node;
  function SortCompare(const p1, p2: PKDT12DI16_Source; const axis: NativeInt): ShortInt;
  begin
    if p1^.buff[axis] = p2^.buff[axis] then
      begin
        if p1^.Index = p2^.Index then
            Result := 0
        else if p1^.Index < p2^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.buff[axis] < p2^.buff[axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT12DI16_SourceBuffer; L, R: NativeInt; const axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT12DI16_Source;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer^[(L + R) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, axis) < 0 do
            Inc(i);
        while SortCompare(SortBuffer^[j], p, axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, axis);
      L := i;
    until i >= R;
  end;

var
  M: NativeInt;
  axis: NativeInt;
  kdBuffPtr: PKDT12DI16_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      new(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.Vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);
    end
  else
    begin
      axis := Depth mod KDT12DI16_Axis;
      M := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr^[0], 0, PlanCount - 1, axis);

      new(Result);
      Result^.Parent := nil;
      Result^.Vec := kdBuffPtr^[M];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], M, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[M + 1], PlanCount - (M + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT12DI16.GetData(const Index: NativeInt): PKDT12DI16_Source;
begin
  Result := @KDStoreBuff[Index];
end;

constructor TKDT12DI16.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT12DI16.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT12DI16.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT12DI16_Node(KDNodes[i]));
      Inc(i);
    end;

  for i := 0 to length(KDStoreBuff) - 1 do
      KDStoreBuff[i].Token := '';

  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT12DI16.StoreBuffPtr: PKDT12DI16_DyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT12DI16.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT12DI16_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT12DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT12DI16.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT12DI16_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT12DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT12DI16.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT12DI16_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT12DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{ k-means++ clusterization }
procedure TKDT12DI16.BuildKDTreeWithCluster(const inBuff: TKDT12DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  SetLength(Source, length(inBuff), KDT12DI16_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT12DI16_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT12DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT12DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT12DI16.BuildKDTreeWithCluster(const inBuff: TKDT12DI16_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TKMIntegerArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT12DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT12DI16_BuildCall);
var
  TempStoreBuff: TKDT12DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT12DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT12DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT12DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT12DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT12DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT12DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT12DI16_BuildMethod);
var
  TempStoreBuff: TKDT12DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT12DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT12DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT12DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT12DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT12DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT12DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT12DI16_BuildProc);
var
  TempStoreBuff: TKDT12DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT12DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT12DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT12DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT12DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT12DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

function TKDT12DI16.Search(const buff: TKDT12DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT12DI16_Node;

var
  NearestNeighbour: PKDT12DI16_Node;

  function FindParentNode(const buffPtr: PKDT12DI16_Vec; NodePtr: PKDT12DI16_Node): PKDT12DI16_Node;
  var
    Next: PKDT12DI16_Node;
    Depth, axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        axis := Depth mod KDT12DI16_Axis;
        if buffPtr^[axis] > Next^.Vec^.buff[axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT12DI16_Node; const buffPtr: PKDT12DI16_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    Inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := Distance(buffPtr^, NodePtr^.Vec^.buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.Vec^.Index < NearestNeighbour^.Vec^.Index) then
        NearestNeighbour := NodePtr;

    axis := Depth mod KDT12DI16_Axis;
    Dist := NodePtr^.Vec^.buff[axis] - buffPtr^[axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.Vec^.buff[axis] > buffPtr^[axis] then
            ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const buffPtr: PKDT12DI16_Vec; const p1, p2: PKDT12DI16_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := Distance(buffPtr^, p1^.Vec^.buff);
    d2 := Distance(buffPtr^, p2^.Vec^.buff);
    if d1 = d2 then
      begin
        if p1^.Vec^.Index = p2^.Vec^.Index then
            Result := 0
        else if p1^.Vec^.Index < p2^.Vec^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; L, R: NativeInt; const buffPtr: PKDT12DI16_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT12DI16_Node;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer[(L + R) shr 1];
      repeat
        while SortCompare(buffPtr, SortBuffer[i], p) < 0 do
            Inc(i);
        while SortCompare(buffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, buffPtr);
      L := i;
    until i >= R;
  end;

var
  Parent: PKDT12DI16_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := Distance(buff, Parent^.Vec^.buff);

  ScanSubtree(RootNode, @buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT12DI16_Node(NearestNodes[0]);
    end;
end;

function TKDT12DI16.Search(const buff: TKDT12DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT12DI16_Node;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT12DI16.Search(const buff: TKDT12DI16_Vec; var SearchedDistanceMin: Double): PKDT12DI16_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT12DI16.Search(const buff: TKDT12DI16_Vec): PKDT12DI16_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT12DI16.SearchToken(const buff: TKDT12DI16_Vec): TPascalString;
var
  p: PKDT12DI16_Node;
begin
  p := Search(buff);
  if p <> nil then
      Result := p^.Vec^.Token
  else
      Result := '';
end;

procedure TKDT12DI16.Search(const inBuff: TKDT12DI16_DynamicVecBuffer; var OutBuff: TKDT12DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT12DI16_DynamicVecBuffer;
  outBuffPtr: PKDT12DI16_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT12DI16_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outBuffPtr^[pass] := p^.Vec^.buff;
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT12DI16_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outBuffPtr^[pass] := p^.Vec^.buff;
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT12DI16_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.Vec^.buff;
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT12DI16.Search(const inBuff: TKDT12DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT12DI16_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT12DI16_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT12DI16_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT12DI16_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT12DI16.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  ID := KDT12DI16_Axis;

  stream.write(st, 4);
  stream.write(ID, 4);

  stream.write(cnt, 8);

  i := 0;
  while i < cnt do
    begin
      stream.write(KDStoreBuff[i].buff[0], SizeOf(TKDT12DI16_Vec));
      stream.write(KDStoreBuff[i].Index, 8);
      token_B := KDStoreBuff[i].Token.Bytes;
      token_L := length(token_B);
      stream.write(token_L, 4);
      if token_L > 0 then
        begin
          stream.write(token_B[0], token_L);
          SetLength(token_B, 0);
        end;
      Inc(i);
    end;
end;

procedure TKDT12DI16.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  Clear;

  stream.read(st, 4);
  stream.read(ID, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if ID <> KDT12DI16_Axis then
      RaiseInfo('kdtree axis error!');

  stream.read(cnt, 8);

  SetLength(KDStoreBuff, cnt);

  i := 0;
  try
    while i < cnt do
      begin
        if stream.read(KDStoreBuff[i].buff[0], SizeOf(TKDT12DI16_Vec)) <> SizeOf(TKDT12DI16_Vec) then
          begin
            Clear;
            Exit;
          end;
        if stream.read(KDStoreBuff[i].Index, 8) <> 8 then
          begin
            Clear;
            Exit;
          end;
        if stream.read(token_L, 4) <> 4 then
          begin
            Clear;
            Exit;
          end;
        if token_L > 0 then
          begin
            SetLength(token_B, token_L);
            if stream.read(token_B[0], token_L) <> token_L then
              begin
                Clear;
                Exit;
              end;
            KDStoreBuff[i].Token.Bytes := token_B;
            SetLength(token_B, 0);
          end
        else
            KDStoreBuff[i].Token := '';
        Inc(i);
      end;
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      Inc(i);
    end;

  if cnt > 0 then
      RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT12DI16.SaveToFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(FileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT12DI16.LoadFromFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT12DI16.PrintNodeTree(const NodePtr: PKDT12DI16_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT12DI16_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.Vec^.Index, Vec(p^.Vec^.buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT12DI16.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d - %d : %s ', [i, KDStoreBuff[i].Index, Vec(KDStoreBuff[i].buff)]);
end;

class function TKDT12DI16.Vec(const s: SystemString): TKDT12DI16_Vec;
var
  t: TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j: NativeInt;
begin
  for i := 0 to KDT12DI16_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            Inc(j);
            if j >= KDT12DI16_Axis then
                Break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT12DI16.Vec(const v: TKDT12DI16_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT12DI16_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT12DI16.Distance(const v1, v2: TKDT12DI16_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT12DI16_Axis - 1 do
      Result := Result + (v2[i] - v1[i]) * (v2[i] - v1[i]);
end;

procedure TKDT12DI16.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT12DI16_Source; const Data: Pointer);
begin
  Source.buff := TestBuff[IndexFor];
  Source.Token := umlIntToStr(IndexFor);
end;

class procedure TKDT12DI16.Test;
var
  TKDT12DI16_Test: TKDT12DI16;
  t: TTimeTick;
  i, j: NativeInt;
  TestResultBuff: TKDT12DI16_DynamicVecBuffer;
  TestResultIndex: TKMIntegerArray;
  KMeanOutIndex: TKMIntegerArray;
  errored: Boolean;
  m64: TMemoryStream64;
  p: PKDT12DI16_Node;
  n: TPascalString;
begin
  errored := False;
  n := PFormat('test %s...', [ClassName]);
  t := GetTimeTick;

  n.Append('...build');
  TKDT12DI16_Test := TKDT12DI16.Create;

  n.Append('...');
  SetLength(TKDT12DI16_Test.TestBuff, 1000);
  for i := 0 to length(TKDT12DI16_Test.TestBuff) - 1 do
    for j := 0 to KDT12DI16_Axis - 1 do
        TKDT12DI16_Test.TestBuff[i][j] := i * KDT12DI16_Axis + j;

{$IFDEF FPC}
  TKDT12DI16_Test.BuildKDTreeM(length(TKDT12DI16_Test.TestBuff), nil, @TKDT12DI16_Test.Test_BuildM);
{$ELSE FPC}
  TKDT12DI16_Test.BuildKDTreeM(length(TKDT12DI16_Test.TestBuff), nil, TKDT12DI16_Test.Test_BuildM);
{$ENDIF FPC}
  { save/load test }
  n.Append('...save/load');
  m64 := TMemoryStream64.CustomCreate(1024 * 1024);
  TKDT12DI16_Test.SaveToStream(m64);
  m64.Position := 0;
  TKDT12DI16_Test.LoadFromStream(m64);
  for i := 0 to length(TKDT12DI16_Test.TestBuff) - 1 do
    begin
      p := TKDT12DI16_Test.Search(TKDT12DI16_Test.TestBuff[i]);
      if p^.Vec^.Index <> i then
          errored := True;
      if not p^.Vec^.Token.Same(umlIntToStr(i)) then
          errored := True;
      if errored then
          Break;
    end;
  DisposeObject(m64);

  if not errored then
    begin
      { parallel search test }
      n.Append('...parallel');
      SetLength(TestResultBuff, length(TKDT12DI16_Test.TestBuff));
      SetLength(TestResultIndex, length(TKDT12DI16_Test.TestBuff));
      TKDT12DI16_Test.Search(TKDT12DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if Distance(TKDT12DI16_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
            errored := True;
    end;

  if not errored then
    begin
      n.Append('...kMean');
      TKDT12DI16_Test.Clear;
      { kMean test }
      TKDT12DI16_Test.BuildKDTreeWithCluster(TKDT12DI16_Test.TestBuff, 10, 1, KMeanOutIndex);
      { parallel search test }
      TKDT12DI16_Test.Search(TKDT12DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if TestResultIndex[i] <> KMeanOutIndex[i] then
            errored := True;
    end;

  SetLength(TKDT12DI16_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT12DI16_Test.Clear;

  n.Append('...');
  if errored then
      n.Append('error!')
  else
      n.Append('passed ok %dms', [GetTimeTick - t]);
  DisposeObject(TKDT12DI16_Test);
  DoStatus(n);
  n := '';
end;

function TKDT13DI16.InternalBuildKdTree(const KDSourceBufferPtr: PKDT13DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT13DI16_Node;
  function SortCompare(const p1, p2: PKDT13DI16_Source; const axis: NativeInt): ShortInt;
  begin
    if p1^.buff[axis] = p2^.buff[axis] then
      begin
        if p1^.Index = p2^.Index then
            Result := 0
        else if p1^.Index < p2^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.buff[axis] < p2^.buff[axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT13DI16_SourceBuffer; L, R: NativeInt; const axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT13DI16_Source;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer^[(L + R) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, axis) < 0 do
            Inc(i);
        while SortCompare(SortBuffer^[j], p, axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, axis);
      L := i;
    until i >= R;
  end;

var
  M: NativeInt;
  axis: NativeInt;
  kdBuffPtr: PKDT13DI16_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      new(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.Vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);
    end
  else
    begin
      axis := Depth mod KDT13DI16_Axis;
      M := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr^[0], 0, PlanCount - 1, axis);

      new(Result);
      Result^.Parent := nil;
      Result^.Vec := kdBuffPtr^[M];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], M, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[M + 1], PlanCount - (M + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT13DI16.GetData(const Index: NativeInt): PKDT13DI16_Source;
begin
  Result := @KDStoreBuff[Index];
end;

constructor TKDT13DI16.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT13DI16.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT13DI16.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT13DI16_Node(KDNodes[i]));
      Inc(i);
    end;

  for i := 0 to length(KDStoreBuff) - 1 do
      KDStoreBuff[i].Token := '';

  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT13DI16.StoreBuffPtr: PKDT13DI16_DyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT13DI16.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT13DI16_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT13DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT13DI16.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT13DI16_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT13DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT13DI16.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT13DI16_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT13DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{ k-means++ clusterization }
procedure TKDT13DI16.BuildKDTreeWithCluster(const inBuff: TKDT13DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  SetLength(Source, length(inBuff), KDT13DI16_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT13DI16_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT13DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT13DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT13DI16.BuildKDTreeWithCluster(const inBuff: TKDT13DI16_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TKMIntegerArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT13DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT13DI16_BuildCall);
var
  TempStoreBuff: TKDT13DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT13DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT13DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT13DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT13DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT13DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT13DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT13DI16_BuildMethod);
var
  TempStoreBuff: TKDT13DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT13DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT13DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT13DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT13DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT13DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT13DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT13DI16_BuildProc);
var
  TempStoreBuff: TKDT13DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT13DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT13DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT13DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT13DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT13DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

function TKDT13DI16.Search(const buff: TKDT13DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT13DI16_Node;

var
  NearestNeighbour: PKDT13DI16_Node;

  function FindParentNode(const buffPtr: PKDT13DI16_Vec; NodePtr: PKDT13DI16_Node): PKDT13DI16_Node;
  var
    Next: PKDT13DI16_Node;
    Depth, axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        axis := Depth mod KDT13DI16_Axis;
        if buffPtr^[axis] > Next^.Vec^.buff[axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT13DI16_Node; const buffPtr: PKDT13DI16_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    Inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := Distance(buffPtr^, NodePtr^.Vec^.buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.Vec^.Index < NearestNeighbour^.Vec^.Index) then
        NearestNeighbour := NodePtr;

    axis := Depth mod KDT13DI16_Axis;
    Dist := NodePtr^.Vec^.buff[axis] - buffPtr^[axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.Vec^.buff[axis] > buffPtr^[axis] then
            ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const buffPtr: PKDT13DI16_Vec; const p1, p2: PKDT13DI16_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := Distance(buffPtr^, p1^.Vec^.buff);
    d2 := Distance(buffPtr^, p2^.Vec^.buff);
    if d1 = d2 then
      begin
        if p1^.Vec^.Index = p2^.Vec^.Index then
            Result := 0
        else if p1^.Vec^.Index < p2^.Vec^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; L, R: NativeInt; const buffPtr: PKDT13DI16_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT13DI16_Node;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer[(L + R) shr 1];
      repeat
        while SortCompare(buffPtr, SortBuffer[i], p) < 0 do
            Inc(i);
        while SortCompare(buffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, buffPtr);
      L := i;
    until i >= R;
  end;

var
  Parent: PKDT13DI16_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := Distance(buff, Parent^.Vec^.buff);

  ScanSubtree(RootNode, @buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT13DI16_Node(NearestNodes[0]);
    end;
end;

function TKDT13DI16.Search(const buff: TKDT13DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT13DI16_Node;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT13DI16.Search(const buff: TKDT13DI16_Vec; var SearchedDistanceMin: Double): PKDT13DI16_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT13DI16.Search(const buff: TKDT13DI16_Vec): PKDT13DI16_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT13DI16.SearchToken(const buff: TKDT13DI16_Vec): TPascalString;
var
  p: PKDT13DI16_Node;
begin
  p := Search(buff);
  if p <> nil then
      Result := p^.Vec^.Token
  else
      Result := '';
end;

procedure TKDT13DI16.Search(const inBuff: TKDT13DI16_DynamicVecBuffer; var OutBuff: TKDT13DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT13DI16_DynamicVecBuffer;
  outBuffPtr: PKDT13DI16_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT13DI16_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outBuffPtr^[pass] := p^.Vec^.buff;
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT13DI16_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outBuffPtr^[pass] := p^.Vec^.buff;
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT13DI16_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.Vec^.buff;
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT13DI16.Search(const inBuff: TKDT13DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT13DI16_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT13DI16_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT13DI16_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT13DI16_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT13DI16.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  ID := KDT13DI16_Axis;

  stream.write(st, 4);
  stream.write(ID, 4);

  stream.write(cnt, 8);

  i := 0;
  while i < cnt do
    begin
      stream.write(KDStoreBuff[i].buff[0], SizeOf(TKDT13DI16_Vec));
      stream.write(KDStoreBuff[i].Index, 8);
      token_B := KDStoreBuff[i].Token.Bytes;
      token_L := length(token_B);
      stream.write(token_L, 4);
      if token_L > 0 then
        begin
          stream.write(token_B[0], token_L);
          SetLength(token_B, 0);
        end;
      Inc(i);
    end;
end;

procedure TKDT13DI16.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  Clear;

  stream.read(st, 4);
  stream.read(ID, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if ID <> KDT13DI16_Axis then
      RaiseInfo('kdtree axis error!');

  stream.read(cnt, 8);

  SetLength(KDStoreBuff, cnt);

  i := 0;
  try
    while i < cnt do
      begin
        if stream.read(KDStoreBuff[i].buff[0], SizeOf(TKDT13DI16_Vec)) <> SizeOf(TKDT13DI16_Vec) then
          begin
            Clear;
            Exit;
          end;
        if stream.read(KDStoreBuff[i].Index, 8) <> 8 then
          begin
            Clear;
            Exit;
          end;
        if stream.read(token_L, 4) <> 4 then
          begin
            Clear;
            Exit;
          end;
        if token_L > 0 then
          begin
            SetLength(token_B, token_L);
            if stream.read(token_B[0], token_L) <> token_L then
              begin
                Clear;
                Exit;
              end;
            KDStoreBuff[i].Token.Bytes := token_B;
            SetLength(token_B, 0);
          end
        else
            KDStoreBuff[i].Token := '';
        Inc(i);
      end;
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      Inc(i);
    end;

  if cnt > 0 then
      RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT13DI16.SaveToFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(FileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT13DI16.LoadFromFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT13DI16.PrintNodeTree(const NodePtr: PKDT13DI16_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT13DI16_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.Vec^.Index, Vec(p^.Vec^.buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT13DI16.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d - %d : %s ', [i, KDStoreBuff[i].Index, Vec(KDStoreBuff[i].buff)]);
end;

class function TKDT13DI16.Vec(const s: SystemString): TKDT13DI16_Vec;
var
  t: TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j: NativeInt;
begin
  for i := 0 to KDT13DI16_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            Inc(j);
            if j >= KDT13DI16_Axis then
                Break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT13DI16.Vec(const v: TKDT13DI16_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT13DI16_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT13DI16.Distance(const v1, v2: TKDT13DI16_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT13DI16_Axis - 1 do
      Result := Result + (v2[i] - v1[i]) * (v2[i] - v1[i]);
end;

procedure TKDT13DI16.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT13DI16_Source; const Data: Pointer);
begin
  Source.buff := TestBuff[IndexFor];
  Source.Token := umlIntToStr(IndexFor);
end;

class procedure TKDT13DI16.Test;
var
  TKDT13DI16_Test: TKDT13DI16;
  t: TTimeTick;
  i, j: NativeInt;
  TestResultBuff: TKDT13DI16_DynamicVecBuffer;
  TestResultIndex: TKMIntegerArray;
  KMeanOutIndex: TKMIntegerArray;
  errored: Boolean;
  m64: TMemoryStream64;
  p: PKDT13DI16_Node;
  n: TPascalString;
begin
  errored := False;
  n := PFormat('test %s...', [ClassName]);
  t := GetTimeTick;

  n.Append('...build');
  TKDT13DI16_Test := TKDT13DI16.Create;

  n.Append('...');
  SetLength(TKDT13DI16_Test.TestBuff, 1000);
  for i := 0 to length(TKDT13DI16_Test.TestBuff) - 1 do
    for j := 0 to KDT13DI16_Axis - 1 do
        TKDT13DI16_Test.TestBuff[i][j] := i * KDT13DI16_Axis + j;

{$IFDEF FPC}
  TKDT13DI16_Test.BuildKDTreeM(length(TKDT13DI16_Test.TestBuff), nil, @TKDT13DI16_Test.Test_BuildM);
{$ELSE FPC}
  TKDT13DI16_Test.BuildKDTreeM(length(TKDT13DI16_Test.TestBuff), nil, TKDT13DI16_Test.Test_BuildM);
{$ENDIF FPC}
  { save/load test }
  n.Append('...save/load');
  m64 := TMemoryStream64.CustomCreate(1024 * 1024);
  TKDT13DI16_Test.SaveToStream(m64);
  m64.Position := 0;
  TKDT13DI16_Test.LoadFromStream(m64);
  for i := 0 to length(TKDT13DI16_Test.TestBuff) - 1 do
    begin
      p := TKDT13DI16_Test.Search(TKDT13DI16_Test.TestBuff[i]);
      if p^.Vec^.Index <> i then
          errored := True;
      if not p^.Vec^.Token.Same(umlIntToStr(i)) then
          errored := True;
      if errored then
          Break;
    end;
  DisposeObject(m64);

  if not errored then
    begin
      { parallel search test }
      n.Append('...parallel');
      SetLength(TestResultBuff, length(TKDT13DI16_Test.TestBuff));
      SetLength(TestResultIndex, length(TKDT13DI16_Test.TestBuff));
      TKDT13DI16_Test.Search(TKDT13DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if Distance(TKDT13DI16_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
            errored := True;
    end;

  if not errored then
    begin
      n.Append('...kMean');
      TKDT13DI16_Test.Clear;
      { kMean test }
      TKDT13DI16_Test.BuildKDTreeWithCluster(TKDT13DI16_Test.TestBuff, 10, 1, KMeanOutIndex);
      { parallel search test }
      TKDT13DI16_Test.Search(TKDT13DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if TestResultIndex[i] <> KMeanOutIndex[i] then
            errored := True;
    end;

  SetLength(TKDT13DI16_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT13DI16_Test.Clear;

  n.Append('...');
  if errored then
      n.Append('error!')
  else
      n.Append('passed ok %dms', [GetTimeTick - t]);
  DisposeObject(TKDT13DI16_Test);
  DoStatus(n);
  n := '';
end;

function TKDT14DI16.InternalBuildKdTree(const KDSourceBufferPtr: PKDT14DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT14DI16_Node;
  function SortCompare(const p1, p2: PKDT14DI16_Source; const axis: NativeInt): ShortInt;
  begin
    if p1^.buff[axis] = p2^.buff[axis] then
      begin
        if p1^.Index = p2^.Index then
            Result := 0
        else if p1^.Index < p2^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.buff[axis] < p2^.buff[axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT14DI16_SourceBuffer; L, R: NativeInt; const axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT14DI16_Source;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer^[(L + R) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, axis) < 0 do
            Inc(i);
        while SortCompare(SortBuffer^[j], p, axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, axis);
      L := i;
    until i >= R;
  end;

var
  M: NativeInt;
  axis: NativeInt;
  kdBuffPtr: PKDT14DI16_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      new(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.Vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);
    end
  else
    begin
      axis := Depth mod KDT14DI16_Axis;
      M := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr^[0], 0, PlanCount - 1, axis);

      new(Result);
      Result^.Parent := nil;
      Result^.Vec := kdBuffPtr^[M];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], M, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[M + 1], PlanCount - (M + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT14DI16.GetData(const Index: NativeInt): PKDT14DI16_Source;
begin
  Result := @KDStoreBuff[Index];
end;

constructor TKDT14DI16.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT14DI16.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT14DI16.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT14DI16_Node(KDNodes[i]));
      Inc(i);
    end;

  for i := 0 to length(KDStoreBuff) - 1 do
      KDStoreBuff[i].Token := '';

  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT14DI16.StoreBuffPtr: PKDT14DI16_DyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT14DI16.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT14DI16_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT14DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT14DI16.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT14DI16_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT14DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT14DI16.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT14DI16_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT14DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{ k-means++ clusterization }
procedure TKDT14DI16.BuildKDTreeWithCluster(const inBuff: TKDT14DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  SetLength(Source, length(inBuff), KDT14DI16_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT14DI16_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT14DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT14DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT14DI16.BuildKDTreeWithCluster(const inBuff: TKDT14DI16_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TKMIntegerArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT14DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT14DI16_BuildCall);
var
  TempStoreBuff: TKDT14DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT14DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT14DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT14DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT14DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT14DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT14DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT14DI16_BuildMethod);
var
  TempStoreBuff: TKDT14DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT14DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT14DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT14DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT14DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT14DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT14DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT14DI16_BuildProc);
var
  TempStoreBuff: TKDT14DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT14DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT14DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT14DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT14DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT14DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

function TKDT14DI16.Search(const buff: TKDT14DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT14DI16_Node;

var
  NearestNeighbour: PKDT14DI16_Node;

  function FindParentNode(const buffPtr: PKDT14DI16_Vec; NodePtr: PKDT14DI16_Node): PKDT14DI16_Node;
  var
    Next: PKDT14DI16_Node;
    Depth, axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        axis := Depth mod KDT14DI16_Axis;
        if buffPtr^[axis] > Next^.Vec^.buff[axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT14DI16_Node; const buffPtr: PKDT14DI16_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    Inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := Distance(buffPtr^, NodePtr^.Vec^.buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.Vec^.Index < NearestNeighbour^.Vec^.Index) then
        NearestNeighbour := NodePtr;

    axis := Depth mod KDT14DI16_Axis;
    Dist := NodePtr^.Vec^.buff[axis] - buffPtr^[axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.Vec^.buff[axis] > buffPtr^[axis] then
            ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const buffPtr: PKDT14DI16_Vec; const p1, p2: PKDT14DI16_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := Distance(buffPtr^, p1^.Vec^.buff);
    d2 := Distance(buffPtr^, p2^.Vec^.buff);
    if d1 = d2 then
      begin
        if p1^.Vec^.Index = p2^.Vec^.Index then
            Result := 0
        else if p1^.Vec^.Index < p2^.Vec^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; L, R: NativeInt; const buffPtr: PKDT14DI16_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT14DI16_Node;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer[(L + R) shr 1];
      repeat
        while SortCompare(buffPtr, SortBuffer[i], p) < 0 do
            Inc(i);
        while SortCompare(buffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, buffPtr);
      L := i;
    until i >= R;
  end;

var
  Parent: PKDT14DI16_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := Distance(buff, Parent^.Vec^.buff);

  ScanSubtree(RootNode, @buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT14DI16_Node(NearestNodes[0]);
    end;
end;

function TKDT14DI16.Search(const buff: TKDT14DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT14DI16_Node;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT14DI16.Search(const buff: TKDT14DI16_Vec; var SearchedDistanceMin: Double): PKDT14DI16_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT14DI16.Search(const buff: TKDT14DI16_Vec): PKDT14DI16_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT14DI16.SearchToken(const buff: TKDT14DI16_Vec): TPascalString;
var
  p: PKDT14DI16_Node;
begin
  p := Search(buff);
  if p <> nil then
      Result := p^.Vec^.Token
  else
      Result := '';
end;

procedure TKDT14DI16.Search(const inBuff: TKDT14DI16_DynamicVecBuffer; var OutBuff: TKDT14DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT14DI16_DynamicVecBuffer;
  outBuffPtr: PKDT14DI16_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT14DI16_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outBuffPtr^[pass] := p^.Vec^.buff;
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT14DI16_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outBuffPtr^[pass] := p^.Vec^.buff;
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT14DI16_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.Vec^.buff;
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT14DI16.Search(const inBuff: TKDT14DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT14DI16_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT14DI16_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT14DI16_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT14DI16_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT14DI16.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  ID := KDT14DI16_Axis;

  stream.write(st, 4);
  stream.write(ID, 4);

  stream.write(cnt, 8);

  i := 0;
  while i < cnt do
    begin
      stream.write(KDStoreBuff[i].buff[0], SizeOf(TKDT14DI16_Vec));
      stream.write(KDStoreBuff[i].Index, 8);
      token_B := KDStoreBuff[i].Token.Bytes;
      token_L := length(token_B);
      stream.write(token_L, 4);
      if token_L > 0 then
        begin
          stream.write(token_B[0], token_L);
          SetLength(token_B, 0);
        end;
      Inc(i);
    end;
end;

procedure TKDT14DI16.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  Clear;

  stream.read(st, 4);
  stream.read(ID, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if ID <> KDT14DI16_Axis then
      RaiseInfo('kdtree axis error!');

  stream.read(cnt, 8);

  SetLength(KDStoreBuff, cnt);

  i := 0;
  try
    while i < cnt do
      begin
        if stream.read(KDStoreBuff[i].buff[0], SizeOf(TKDT14DI16_Vec)) <> SizeOf(TKDT14DI16_Vec) then
          begin
            Clear;
            Exit;
          end;
        if stream.read(KDStoreBuff[i].Index, 8) <> 8 then
          begin
            Clear;
            Exit;
          end;
        if stream.read(token_L, 4) <> 4 then
          begin
            Clear;
            Exit;
          end;
        if token_L > 0 then
          begin
            SetLength(token_B, token_L);
            if stream.read(token_B[0], token_L) <> token_L then
              begin
                Clear;
                Exit;
              end;
            KDStoreBuff[i].Token.Bytes := token_B;
            SetLength(token_B, 0);
          end
        else
            KDStoreBuff[i].Token := '';
        Inc(i);
      end;
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      Inc(i);
    end;

  if cnt > 0 then
      RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT14DI16.SaveToFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(FileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT14DI16.LoadFromFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT14DI16.PrintNodeTree(const NodePtr: PKDT14DI16_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT14DI16_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.Vec^.Index, Vec(p^.Vec^.buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT14DI16.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d - %d : %s ', [i, KDStoreBuff[i].Index, Vec(KDStoreBuff[i].buff)]);
end;

class function TKDT14DI16.Vec(const s: SystemString): TKDT14DI16_Vec;
var
  t: TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j: NativeInt;
begin
  for i := 0 to KDT14DI16_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            Inc(j);
            if j >= KDT14DI16_Axis then
                Break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT14DI16.Vec(const v: TKDT14DI16_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT14DI16_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT14DI16.Distance(const v1, v2: TKDT14DI16_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT14DI16_Axis - 1 do
      Result := Result + (v2[i] - v1[i]) * (v2[i] - v1[i]);
end;

procedure TKDT14DI16.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT14DI16_Source; const Data: Pointer);
begin
  Source.buff := TestBuff[IndexFor];
  Source.Token := umlIntToStr(IndexFor);
end;

class procedure TKDT14DI16.Test;
var
  TKDT14DI16_Test: TKDT14DI16;
  t: TTimeTick;
  i, j: NativeInt;
  TestResultBuff: TKDT14DI16_DynamicVecBuffer;
  TestResultIndex: TKMIntegerArray;
  KMeanOutIndex: TKMIntegerArray;
  errored: Boolean;
  m64: TMemoryStream64;
  p: PKDT14DI16_Node;
  n: TPascalString;
begin
  errored := False;
  n := PFormat('test %s...', [ClassName]);
  t := GetTimeTick;

  n.Append('...build');
  TKDT14DI16_Test := TKDT14DI16.Create;

  n.Append('...');
  SetLength(TKDT14DI16_Test.TestBuff, 1000);
  for i := 0 to length(TKDT14DI16_Test.TestBuff) - 1 do
    for j := 0 to KDT14DI16_Axis - 1 do
        TKDT14DI16_Test.TestBuff[i][j] := i * KDT14DI16_Axis + j;

{$IFDEF FPC}
  TKDT14DI16_Test.BuildKDTreeM(length(TKDT14DI16_Test.TestBuff), nil, @TKDT14DI16_Test.Test_BuildM);
{$ELSE FPC}
  TKDT14DI16_Test.BuildKDTreeM(length(TKDT14DI16_Test.TestBuff), nil, TKDT14DI16_Test.Test_BuildM);
{$ENDIF FPC}
  { save/load test }
  n.Append('...save/load');
  m64 := TMemoryStream64.CustomCreate(1024 * 1024);
  TKDT14DI16_Test.SaveToStream(m64);
  m64.Position := 0;
  TKDT14DI16_Test.LoadFromStream(m64);
  for i := 0 to length(TKDT14DI16_Test.TestBuff) - 1 do
    begin
      p := TKDT14DI16_Test.Search(TKDT14DI16_Test.TestBuff[i]);
      if p^.Vec^.Index <> i then
          errored := True;
      if not p^.Vec^.Token.Same(umlIntToStr(i)) then
          errored := True;
      if errored then
          Break;
    end;
  DisposeObject(m64);

  if not errored then
    begin
      { parallel search test }
      n.Append('...parallel');
      SetLength(TestResultBuff, length(TKDT14DI16_Test.TestBuff));
      SetLength(TestResultIndex, length(TKDT14DI16_Test.TestBuff));
      TKDT14DI16_Test.Search(TKDT14DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if Distance(TKDT14DI16_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
            errored := True;
    end;

  if not errored then
    begin
      n.Append('...kMean');
      TKDT14DI16_Test.Clear;
      { kMean test }
      TKDT14DI16_Test.BuildKDTreeWithCluster(TKDT14DI16_Test.TestBuff, 10, 1, KMeanOutIndex);
      { parallel search test }
      TKDT14DI16_Test.Search(TKDT14DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if TestResultIndex[i] <> KMeanOutIndex[i] then
            errored := True;
    end;

  SetLength(TKDT14DI16_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT14DI16_Test.Clear;

  n.Append('...');
  if errored then
      n.Append('error!')
  else
      n.Append('passed ok %dms', [GetTimeTick - t]);
  DisposeObject(TKDT14DI16_Test);
  DoStatus(n);
  n := '';
end;

function TKDT15DI16.InternalBuildKdTree(const KDSourceBufferPtr: PKDT15DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT15DI16_Node;
  function SortCompare(const p1, p2: PKDT15DI16_Source; const axis: NativeInt): ShortInt;
  begin
    if p1^.buff[axis] = p2^.buff[axis] then
      begin
        if p1^.Index = p2^.Index then
            Result := 0
        else if p1^.Index < p2^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.buff[axis] < p2^.buff[axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT15DI16_SourceBuffer; L, R: NativeInt; const axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT15DI16_Source;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer^[(L + R) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, axis) < 0 do
            Inc(i);
        while SortCompare(SortBuffer^[j], p, axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, axis);
      L := i;
    until i >= R;
  end;

var
  M: NativeInt;
  axis: NativeInt;
  kdBuffPtr: PKDT15DI16_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      new(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.Vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);
    end
  else
    begin
      axis := Depth mod KDT15DI16_Axis;
      M := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr^[0], 0, PlanCount - 1, axis);

      new(Result);
      Result^.Parent := nil;
      Result^.Vec := kdBuffPtr^[M];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], M, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[M + 1], PlanCount - (M + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT15DI16.GetData(const Index: NativeInt): PKDT15DI16_Source;
begin
  Result := @KDStoreBuff[Index];
end;

constructor TKDT15DI16.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT15DI16.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT15DI16.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT15DI16_Node(KDNodes[i]));
      Inc(i);
    end;

  for i := 0 to length(KDStoreBuff) - 1 do
      KDStoreBuff[i].Token := '';

  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT15DI16.StoreBuffPtr: PKDT15DI16_DyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT15DI16.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT15DI16_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT15DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT15DI16.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT15DI16_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT15DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT15DI16.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT15DI16_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT15DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{ k-means++ clusterization }
procedure TKDT15DI16.BuildKDTreeWithCluster(const inBuff: TKDT15DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  SetLength(Source, length(inBuff), KDT15DI16_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT15DI16_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT15DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT15DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT15DI16.BuildKDTreeWithCluster(const inBuff: TKDT15DI16_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TKMIntegerArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT15DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT15DI16_BuildCall);
var
  TempStoreBuff: TKDT15DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT15DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT15DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT15DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT15DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT15DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT15DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT15DI16_BuildMethod);
var
  TempStoreBuff: TKDT15DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT15DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT15DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT15DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT15DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT15DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT15DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT15DI16_BuildProc);
var
  TempStoreBuff: TKDT15DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT15DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT15DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT15DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT15DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT15DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

function TKDT15DI16.Search(const buff: TKDT15DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT15DI16_Node;

var
  NearestNeighbour: PKDT15DI16_Node;

  function FindParentNode(const buffPtr: PKDT15DI16_Vec; NodePtr: PKDT15DI16_Node): PKDT15DI16_Node;
  var
    Next: PKDT15DI16_Node;
    Depth, axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        axis := Depth mod KDT15DI16_Axis;
        if buffPtr^[axis] > Next^.Vec^.buff[axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT15DI16_Node; const buffPtr: PKDT15DI16_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    Inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := Distance(buffPtr^, NodePtr^.Vec^.buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.Vec^.Index < NearestNeighbour^.Vec^.Index) then
        NearestNeighbour := NodePtr;

    axis := Depth mod KDT15DI16_Axis;
    Dist := NodePtr^.Vec^.buff[axis] - buffPtr^[axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.Vec^.buff[axis] > buffPtr^[axis] then
            ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const buffPtr: PKDT15DI16_Vec; const p1, p2: PKDT15DI16_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := Distance(buffPtr^, p1^.Vec^.buff);
    d2 := Distance(buffPtr^, p2^.Vec^.buff);
    if d1 = d2 then
      begin
        if p1^.Vec^.Index = p2^.Vec^.Index then
            Result := 0
        else if p1^.Vec^.Index < p2^.Vec^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; L, R: NativeInt; const buffPtr: PKDT15DI16_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT15DI16_Node;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer[(L + R) shr 1];
      repeat
        while SortCompare(buffPtr, SortBuffer[i], p) < 0 do
            Inc(i);
        while SortCompare(buffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, buffPtr);
      L := i;
    until i >= R;
  end;

var
  Parent: PKDT15DI16_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := Distance(buff, Parent^.Vec^.buff);

  ScanSubtree(RootNode, @buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT15DI16_Node(NearestNodes[0]);
    end;
end;

function TKDT15DI16.Search(const buff: TKDT15DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT15DI16_Node;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT15DI16.Search(const buff: TKDT15DI16_Vec; var SearchedDistanceMin: Double): PKDT15DI16_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT15DI16.Search(const buff: TKDT15DI16_Vec): PKDT15DI16_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT15DI16.SearchToken(const buff: TKDT15DI16_Vec): TPascalString;
var
  p: PKDT15DI16_Node;
begin
  p := Search(buff);
  if p <> nil then
      Result := p^.Vec^.Token
  else
      Result := '';
end;

procedure TKDT15DI16.Search(const inBuff: TKDT15DI16_DynamicVecBuffer; var OutBuff: TKDT15DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT15DI16_DynamicVecBuffer;
  outBuffPtr: PKDT15DI16_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT15DI16_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outBuffPtr^[pass] := p^.Vec^.buff;
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT15DI16_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outBuffPtr^[pass] := p^.Vec^.buff;
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT15DI16_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.Vec^.buff;
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT15DI16.Search(const inBuff: TKDT15DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT15DI16_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT15DI16_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT15DI16_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT15DI16_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT15DI16.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  ID := KDT15DI16_Axis;

  stream.write(st, 4);
  stream.write(ID, 4);

  stream.write(cnt, 8);

  i := 0;
  while i < cnt do
    begin
      stream.write(KDStoreBuff[i].buff[0], SizeOf(TKDT15DI16_Vec));
      stream.write(KDStoreBuff[i].Index, 8);
      token_B := KDStoreBuff[i].Token.Bytes;
      token_L := length(token_B);
      stream.write(token_L, 4);
      if token_L > 0 then
        begin
          stream.write(token_B[0], token_L);
          SetLength(token_B, 0);
        end;
      Inc(i);
    end;
end;

procedure TKDT15DI16.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  Clear;

  stream.read(st, 4);
  stream.read(ID, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if ID <> KDT15DI16_Axis then
      RaiseInfo('kdtree axis error!');

  stream.read(cnt, 8);

  SetLength(KDStoreBuff, cnt);

  i := 0;
  try
    while i < cnt do
      begin
        if stream.read(KDStoreBuff[i].buff[0], SizeOf(TKDT15DI16_Vec)) <> SizeOf(TKDT15DI16_Vec) then
          begin
            Clear;
            Exit;
          end;
        if stream.read(KDStoreBuff[i].Index, 8) <> 8 then
          begin
            Clear;
            Exit;
          end;
        if stream.read(token_L, 4) <> 4 then
          begin
            Clear;
            Exit;
          end;
        if token_L > 0 then
          begin
            SetLength(token_B, token_L);
            if stream.read(token_B[0], token_L) <> token_L then
              begin
                Clear;
                Exit;
              end;
            KDStoreBuff[i].Token.Bytes := token_B;
            SetLength(token_B, 0);
          end
        else
            KDStoreBuff[i].Token := '';
        Inc(i);
      end;
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      Inc(i);
    end;

  if cnt > 0 then
      RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT15DI16.SaveToFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(FileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT15DI16.LoadFromFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT15DI16.PrintNodeTree(const NodePtr: PKDT15DI16_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT15DI16_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.Vec^.Index, Vec(p^.Vec^.buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT15DI16.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d - %d : %s ', [i, KDStoreBuff[i].Index, Vec(KDStoreBuff[i].buff)]);
end;

class function TKDT15DI16.Vec(const s: SystemString): TKDT15DI16_Vec;
var
  t: TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j: NativeInt;
begin
  for i := 0 to KDT15DI16_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            Inc(j);
            if j >= KDT15DI16_Axis then
                Break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT15DI16.Vec(const v: TKDT15DI16_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT15DI16_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT15DI16.Distance(const v1, v2: TKDT15DI16_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT15DI16_Axis - 1 do
      Result := Result + (v2[i] - v1[i]) * (v2[i] - v1[i]);
end;

procedure TKDT15DI16.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT15DI16_Source; const Data: Pointer);
begin
  Source.buff := TestBuff[IndexFor];
  Source.Token := umlIntToStr(IndexFor);
end;

class procedure TKDT15DI16.Test;
var
  TKDT15DI16_Test: TKDT15DI16;
  t: TTimeTick;
  i, j: NativeInt;
  TestResultBuff: TKDT15DI16_DynamicVecBuffer;
  TestResultIndex: TKMIntegerArray;
  KMeanOutIndex: TKMIntegerArray;
  errored: Boolean;
  m64: TMemoryStream64;
  p: PKDT15DI16_Node;
  n: TPascalString;
begin
  errored := False;
  n := PFormat('test %s...', [ClassName]);
  t := GetTimeTick;

  n.Append('...build');
  TKDT15DI16_Test := TKDT15DI16.Create;

  n.Append('...');
  SetLength(TKDT15DI16_Test.TestBuff, 1000);
  for i := 0 to length(TKDT15DI16_Test.TestBuff) - 1 do
    for j := 0 to KDT15DI16_Axis - 1 do
        TKDT15DI16_Test.TestBuff[i][j] := i * KDT15DI16_Axis + j;

{$IFDEF FPC}
  TKDT15DI16_Test.BuildKDTreeM(length(TKDT15DI16_Test.TestBuff), nil, @TKDT15DI16_Test.Test_BuildM);
{$ELSE FPC}
  TKDT15DI16_Test.BuildKDTreeM(length(TKDT15DI16_Test.TestBuff), nil, TKDT15DI16_Test.Test_BuildM);
{$ENDIF FPC}
  { save/load test }
  n.Append('...save/load');
  m64 := TMemoryStream64.CustomCreate(1024 * 1024);
  TKDT15DI16_Test.SaveToStream(m64);
  m64.Position := 0;
  TKDT15DI16_Test.LoadFromStream(m64);
  for i := 0 to length(TKDT15DI16_Test.TestBuff) - 1 do
    begin
      p := TKDT15DI16_Test.Search(TKDT15DI16_Test.TestBuff[i]);
      if p^.Vec^.Index <> i then
          errored := True;
      if not p^.Vec^.Token.Same(umlIntToStr(i)) then
          errored := True;
      if errored then
          Break;
    end;
  DisposeObject(m64);

  if not errored then
    begin
      { parallel search test }
      n.Append('...parallel');
      SetLength(TestResultBuff, length(TKDT15DI16_Test.TestBuff));
      SetLength(TestResultIndex, length(TKDT15DI16_Test.TestBuff));
      TKDT15DI16_Test.Search(TKDT15DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if Distance(TKDT15DI16_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
            errored := True;
    end;

  if not errored then
    begin
      n.Append('...kMean');
      TKDT15DI16_Test.Clear;
      { kMean test }
      TKDT15DI16_Test.BuildKDTreeWithCluster(TKDT15DI16_Test.TestBuff, 10, 1, KMeanOutIndex);
      { parallel search test }
      TKDT15DI16_Test.Search(TKDT15DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if TestResultIndex[i] <> KMeanOutIndex[i] then
            errored := True;
    end;

  SetLength(TKDT15DI16_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT15DI16_Test.Clear;

  n.Append('...');
  if errored then
      n.Append('error!')
  else
      n.Append('passed ok %dms', [GetTimeTick - t]);
  DisposeObject(TKDT15DI16_Test);
  DoStatus(n);
  n := '';
end;

function TKDT16DI16.InternalBuildKdTree(const KDSourceBufferPtr: PKDT16DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT16DI16_Node;
  function SortCompare(const p1, p2: PKDT16DI16_Source; const axis: NativeInt): ShortInt;
  begin
    if p1^.buff[axis] = p2^.buff[axis] then
      begin
        if p1^.Index = p2^.Index then
            Result := 0
        else if p1^.Index < p2^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.buff[axis] < p2^.buff[axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT16DI16_SourceBuffer; L, R: NativeInt; const axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT16DI16_Source;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer^[(L + R) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, axis) < 0 do
            Inc(i);
        while SortCompare(SortBuffer^[j], p, axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, axis);
      L := i;
    until i >= R;
  end;

var
  M: NativeInt;
  axis: NativeInt;
  kdBuffPtr: PKDT16DI16_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      new(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.Vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);
    end
  else
    begin
      axis := Depth mod KDT16DI16_Axis;
      M := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr^[0], 0, PlanCount - 1, axis);

      new(Result);
      Result^.Parent := nil;
      Result^.Vec := kdBuffPtr^[M];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], M, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[M + 1], PlanCount - (M + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT16DI16.GetData(const Index: NativeInt): PKDT16DI16_Source;
begin
  Result := @KDStoreBuff[Index];
end;

constructor TKDT16DI16.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT16DI16.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT16DI16.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT16DI16_Node(KDNodes[i]));
      Inc(i);
    end;

  for i := 0 to length(KDStoreBuff) - 1 do
      KDStoreBuff[i].Token := '';

  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT16DI16.StoreBuffPtr: PKDT16DI16_DyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT16DI16.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT16DI16_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT16DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT16DI16.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT16DI16_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT16DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT16DI16.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT16DI16_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT16DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{ k-means++ clusterization }
procedure TKDT16DI16.BuildKDTreeWithCluster(const inBuff: TKDT16DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  SetLength(Source, length(inBuff), KDT16DI16_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT16DI16_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT16DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT16DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT16DI16.BuildKDTreeWithCluster(const inBuff: TKDT16DI16_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TKMIntegerArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT16DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT16DI16_BuildCall);
var
  TempStoreBuff: TKDT16DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT16DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT16DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT16DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT16DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT16DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT16DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT16DI16_BuildMethod);
var
  TempStoreBuff: TKDT16DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT16DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT16DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT16DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT16DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT16DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT16DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT16DI16_BuildProc);
var
  TempStoreBuff: TKDT16DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT16DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT16DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT16DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT16DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT16DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

function TKDT16DI16.Search(const buff: TKDT16DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT16DI16_Node;

var
  NearestNeighbour: PKDT16DI16_Node;

  function FindParentNode(const buffPtr: PKDT16DI16_Vec; NodePtr: PKDT16DI16_Node): PKDT16DI16_Node;
  var
    Next: PKDT16DI16_Node;
    Depth, axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        axis := Depth mod KDT16DI16_Axis;
        if buffPtr^[axis] > Next^.Vec^.buff[axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT16DI16_Node; const buffPtr: PKDT16DI16_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    Inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := Distance(buffPtr^, NodePtr^.Vec^.buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.Vec^.Index < NearestNeighbour^.Vec^.Index) then
        NearestNeighbour := NodePtr;

    axis := Depth mod KDT16DI16_Axis;
    Dist := NodePtr^.Vec^.buff[axis] - buffPtr^[axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.Vec^.buff[axis] > buffPtr^[axis] then
            ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const buffPtr: PKDT16DI16_Vec; const p1, p2: PKDT16DI16_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := Distance(buffPtr^, p1^.Vec^.buff);
    d2 := Distance(buffPtr^, p2^.Vec^.buff);
    if d1 = d2 then
      begin
        if p1^.Vec^.Index = p2^.Vec^.Index then
            Result := 0
        else if p1^.Vec^.Index < p2^.Vec^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; L, R: NativeInt; const buffPtr: PKDT16DI16_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT16DI16_Node;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer[(L + R) shr 1];
      repeat
        while SortCompare(buffPtr, SortBuffer[i], p) < 0 do
            Inc(i);
        while SortCompare(buffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, buffPtr);
      L := i;
    until i >= R;
  end;

var
  Parent: PKDT16DI16_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := Distance(buff, Parent^.Vec^.buff);

  ScanSubtree(RootNode, @buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT16DI16_Node(NearestNodes[0]);
    end;
end;

function TKDT16DI16.Search(const buff: TKDT16DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT16DI16_Node;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT16DI16.Search(const buff: TKDT16DI16_Vec; var SearchedDistanceMin: Double): PKDT16DI16_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT16DI16.Search(const buff: TKDT16DI16_Vec): PKDT16DI16_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT16DI16.SearchToken(const buff: TKDT16DI16_Vec): TPascalString;
var
  p: PKDT16DI16_Node;
begin
  p := Search(buff);
  if p <> nil then
      Result := p^.Vec^.Token
  else
      Result := '';
end;

procedure TKDT16DI16.Search(const inBuff: TKDT16DI16_DynamicVecBuffer; var OutBuff: TKDT16DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT16DI16_DynamicVecBuffer;
  outBuffPtr: PKDT16DI16_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT16DI16_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outBuffPtr^[pass] := p^.Vec^.buff;
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT16DI16_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outBuffPtr^[pass] := p^.Vec^.buff;
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT16DI16_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.Vec^.buff;
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT16DI16.Search(const inBuff: TKDT16DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT16DI16_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT16DI16_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT16DI16_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT16DI16_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT16DI16.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  ID := KDT16DI16_Axis;

  stream.write(st, 4);
  stream.write(ID, 4);

  stream.write(cnt, 8);

  i := 0;
  while i < cnt do
    begin
      stream.write(KDStoreBuff[i].buff[0], SizeOf(TKDT16DI16_Vec));
      stream.write(KDStoreBuff[i].Index, 8);
      token_B := KDStoreBuff[i].Token.Bytes;
      token_L := length(token_B);
      stream.write(token_L, 4);
      if token_L > 0 then
        begin
          stream.write(token_B[0], token_L);
          SetLength(token_B, 0);
        end;
      Inc(i);
    end;
end;

procedure TKDT16DI16.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  Clear;

  stream.read(st, 4);
  stream.read(ID, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if ID <> KDT16DI16_Axis then
      RaiseInfo('kdtree axis error!');

  stream.read(cnt, 8);

  SetLength(KDStoreBuff, cnt);

  i := 0;
  try
    while i < cnt do
      begin
        if stream.read(KDStoreBuff[i].buff[0], SizeOf(TKDT16DI16_Vec)) <> SizeOf(TKDT16DI16_Vec) then
          begin
            Clear;
            Exit;
          end;
        if stream.read(KDStoreBuff[i].Index, 8) <> 8 then
          begin
            Clear;
            Exit;
          end;
        if stream.read(token_L, 4) <> 4 then
          begin
            Clear;
            Exit;
          end;
        if token_L > 0 then
          begin
            SetLength(token_B, token_L);
            if stream.read(token_B[0], token_L) <> token_L then
              begin
                Clear;
                Exit;
              end;
            KDStoreBuff[i].Token.Bytes := token_B;
            SetLength(token_B, 0);
          end
        else
            KDStoreBuff[i].Token := '';
        Inc(i);
      end;
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      Inc(i);
    end;

  if cnt > 0 then
      RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT16DI16.SaveToFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(FileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT16DI16.LoadFromFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT16DI16.PrintNodeTree(const NodePtr: PKDT16DI16_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT16DI16_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.Vec^.Index, Vec(p^.Vec^.buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT16DI16.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d - %d : %s ', [i, KDStoreBuff[i].Index, Vec(KDStoreBuff[i].buff)]);
end;

class function TKDT16DI16.Vec(const s: SystemString): TKDT16DI16_Vec;
var
  t: TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j: NativeInt;
begin
  for i := 0 to KDT16DI16_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            Inc(j);
            if j >= KDT16DI16_Axis then
                Break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT16DI16.Vec(const v: TKDT16DI16_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT16DI16_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT16DI16.Distance(const v1, v2: TKDT16DI16_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT16DI16_Axis - 1 do
      Result := Result + (v2[i] - v1[i]) * (v2[i] - v1[i]);
end;

procedure TKDT16DI16.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT16DI16_Source; const Data: Pointer);
begin
  Source.buff := TestBuff[IndexFor];
  Source.Token := umlIntToStr(IndexFor);
end;

class procedure TKDT16DI16.Test;
var
  TKDT16DI16_Test: TKDT16DI16;
  t: TTimeTick;
  i, j: NativeInt;
  TestResultBuff: TKDT16DI16_DynamicVecBuffer;
  TestResultIndex: TKMIntegerArray;
  KMeanOutIndex: TKMIntegerArray;
  errored: Boolean;
  m64: TMemoryStream64;
  p: PKDT16DI16_Node;
  n: TPascalString;
begin
  errored := False;
  n := PFormat('test %s...', [ClassName]);
  t := GetTimeTick;

  n.Append('...build');
  TKDT16DI16_Test := TKDT16DI16.Create;

  n.Append('...');
  SetLength(TKDT16DI16_Test.TestBuff, 1000);
  for i := 0 to length(TKDT16DI16_Test.TestBuff) - 1 do
    for j := 0 to KDT16DI16_Axis - 1 do
        TKDT16DI16_Test.TestBuff[i][j] := i * KDT16DI16_Axis + j;

{$IFDEF FPC}
  TKDT16DI16_Test.BuildKDTreeM(length(TKDT16DI16_Test.TestBuff), nil, @TKDT16DI16_Test.Test_BuildM);
{$ELSE FPC}
  TKDT16DI16_Test.BuildKDTreeM(length(TKDT16DI16_Test.TestBuff), nil, TKDT16DI16_Test.Test_BuildM);
{$ENDIF FPC}
  { save/load test }
  n.Append('...save/load');
  m64 := TMemoryStream64.CustomCreate(1024 * 1024);
  TKDT16DI16_Test.SaveToStream(m64);
  m64.Position := 0;
  TKDT16DI16_Test.LoadFromStream(m64);
  for i := 0 to length(TKDT16DI16_Test.TestBuff) - 1 do
    begin
      p := TKDT16DI16_Test.Search(TKDT16DI16_Test.TestBuff[i]);
      if p^.Vec^.Index <> i then
          errored := True;
      if not p^.Vec^.Token.Same(umlIntToStr(i)) then
          errored := True;
      if errored then
          Break;
    end;
  DisposeObject(m64);

  if not errored then
    begin
      { parallel search test }
      n.Append('...parallel');
      SetLength(TestResultBuff, length(TKDT16DI16_Test.TestBuff));
      SetLength(TestResultIndex, length(TKDT16DI16_Test.TestBuff));
      TKDT16DI16_Test.Search(TKDT16DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if Distance(TKDT16DI16_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
            errored := True;
    end;

  if not errored then
    begin
      n.Append('...kMean');
      TKDT16DI16_Test.Clear;
      { kMean test }
      TKDT16DI16_Test.BuildKDTreeWithCluster(TKDT16DI16_Test.TestBuff, 10, 1, KMeanOutIndex);
      { parallel search test }
      TKDT16DI16_Test.Search(TKDT16DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if TestResultIndex[i] <> KMeanOutIndex[i] then
            errored := True;
    end;

  SetLength(TKDT16DI16_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT16DI16_Test.Clear;

  n.Append('...');
  if errored then
      n.Append('error!')
  else
      n.Append('passed ok %dms', [GetTimeTick - t]);
  DisposeObject(TKDT16DI16_Test);
  DoStatus(n);
  n := '';
end;

function TKDT17DI16.InternalBuildKdTree(const KDSourceBufferPtr: PKDT17DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT17DI16_Node;
  function SortCompare(const p1, p2: PKDT17DI16_Source; const axis: NativeInt): ShortInt;
  begin
    if p1^.buff[axis] = p2^.buff[axis] then
      begin
        if p1^.Index = p2^.Index then
            Result := 0
        else if p1^.Index < p2^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.buff[axis] < p2^.buff[axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT17DI16_SourceBuffer; L, R: NativeInt; const axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT17DI16_Source;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer^[(L + R) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, axis) < 0 do
            Inc(i);
        while SortCompare(SortBuffer^[j], p, axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, axis);
      L := i;
    until i >= R;
  end;

var
  M: NativeInt;
  axis: NativeInt;
  kdBuffPtr: PKDT17DI16_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      new(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.Vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);
    end
  else
    begin
      axis := Depth mod KDT17DI16_Axis;
      M := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr^[0], 0, PlanCount - 1, axis);

      new(Result);
      Result^.Parent := nil;
      Result^.Vec := kdBuffPtr^[M];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], M, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[M + 1], PlanCount - (M + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT17DI16.GetData(const Index: NativeInt): PKDT17DI16_Source;
begin
  Result := @KDStoreBuff[Index];
end;

constructor TKDT17DI16.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT17DI16.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT17DI16.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT17DI16_Node(KDNodes[i]));
      Inc(i);
    end;

  for i := 0 to length(KDStoreBuff) - 1 do
      KDStoreBuff[i].Token := '';

  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT17DI16.StoreBuffPtr: PKDT17DI16_DyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT17DI16.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT17DI16_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT17DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT17DI16.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT17DI16_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT17DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT17DI16.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT17DI16_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT17DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{ k-means++ clusterization }
procedure TKDT17DI16.BuildKDTreeWithCluster(const inBuff: TKDT17DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  SetLength(Source, length(inBuff), KDT17DI16_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT17DI16_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT17DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT17DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT17DI16.BuildKDTreeWithCluster(const inBuff: TKDT17DI16_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TKMIntegerArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT17DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT17DI16_BuildCall);
var
  TempStoreBuff: TKDT17DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT17DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT17DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT17DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT17DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT17DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT17DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT17DI16_BuildMethod);
var
  TempStoreBuff: TKDT17DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT17DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT17DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT17DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT17DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT17DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT17DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT17DI16_BuildProc);
var
  TempStoreBuff: TKDT17DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT17DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT17DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT17DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT17DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT17DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

function TKDT17DI16.Search(const buff: TKDT17DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT17DI16_Node;

var
  NearestNeighbour: PKDT17DI16_Node;

  function FindParentNode(const buffPtr: PKDT17DI16_Vec; NodePtr: PKDT17DI16_Node): PKDT17DI16_Node;
  var
    Next: PKDT17DI16_Node;
    Depth, axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        axis := Depth mod KDT17DI16_Axis;
        if buffPtr^[axis] > Next^.Vec^.buff[axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT17DI16_Node; const buffPtr: PKDT17DI16_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    Inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := Distance(buffPtr^, NodePtr^.Vec^.buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.Vec^.Index < NearestNeighbour^.Vec^.Index) then
        NearestNeighbour := NodePtr;

    axis := Depth mod KDT17DI16_Axis;
    Dist := NodePtr^.Vec^.buff[axis] - buffPtr^[axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.Vec^.buff[axis] > buffPtr^[axis] then
            ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const buffPtr: PKDT17DI16_Vec; const p1, p2: PKDT17DI16_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := Distance(buffPtr^, p1^.Vec^.buff);
    d2 := Distance(buffPtr^, p2^.Vec^.buff);
    if d1 = d2 then
      begin
        if p1^.Vec^.Index = p2^.Vec^.Index then
            Result := 0
        else if p1^.Vec^.Index < p2^.Vec^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; L, R: NativeInt; const buffPtr: PKDT17DI16_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT17DI16_Node;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer[(L + R) shr 1];
      repeat
        while SortCompare(buffPtr, SortBuffer[i], p) < 0 do
            Inc(i);
        while SortCompare(buffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, buffPtr);
      L := i;
    until i >= R;
  end;

var
  Parent: PKDT17DI16_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := Distance(buff, Parent^.Vec^.buff);

  ScanSubtree(RootNode, @buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT17DI16_Node(NearestNodes[0]);
    end;
end;

function TKDT17DI16.Search(const buff: TKDT17DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT17DI16_Node;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT17DI16.Search(const buff: TKDT17DI16_Vec; var SearchedDistanceMin: Double): PKDT17DI16_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT17DI16.Search(const buff: TKDT17DI16_Vec): PKDT17DI16_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT17DI16.SearchToken(const buff: TKDT17DI16_Vec): TPascalString;
var
  p: PKDT17DI16_Node;
begin
  p := Search(buff);
  if p <> nil then
      Result := p^.Vec^.Token
  else
      Result := '';
end;

procedure TKDT17DI16.Search(const inBuff: TKDT17DI16_DynamicVecBuffer; var OutBuff: TKDT17DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT17DI16_DynamicVecBuffer;
  outBuffPtr: PKDT17DI16_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT17DI16_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outBuffPtr^[pass] := p^.Vec^.buff;
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT17DI16_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outBuffPtr^[pass] := p^.Vec^.buff;
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT17DI16_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.Vec^.buff;
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT17DI16.Search(const inBuff: TKDT17DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT17DI16_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT17DI16_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT17DI16_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT17DI16_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT17DI16.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  ID := KDT17DI16_Axis;

  stream.write(st, 4);
  stream.write(ID, 4);

  stream.write(cnt, 8);

  i := 0;
  while i < cnt do
    begin
      stream.write(KDStoreBuff[i].buff[0], SizeOf(TKDT17DI16_Vec));
      stream.write(KDStoreBuff[i].Index, 8);
      token_B := KDStoreBuff[i].Token.Bytes;
      token_L := length(token_B);
      stream.write(token_L, 4);
      if token_L > 0 then
        begin
          stream.write(token_B[0], token_L);
          SetLength(token_B, 0);
        end;
      Inc(i);
    end;
end;

procedure TKDT17DI16.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  Clear;

  stream.read(st, 4);
  stream.read(ID, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if ID <> KDT17DI16_Axis then
      RaiseInfo('kdtree axis error!');

  stream.read(cnt, 8);

  SetLength(KDStoreBuff, cnt);

  i := 0;
  try
    while i < cnt do
      begin
        if stream.read(KDStoreBuff[i].buff[0], SizeOf(TKDT17DI16_Vec)) <> SizeOf(TKDT17DI16_Vec) then
          begin
            Clear;
            Exit;
          end;
        if stream.read(KDStoreBuff[i].Index, 8) <> 8 then
          begin
            Clear;
            Exit;
          end;
        if stream.read(token_L, 4) <> 4 then
          begin
            Clear;
            Exit;
          end;
        if token_L > 0 then
          begin
            SetLength(token_B, token_L);
            if stream.read(token_B[0], token_L) <> token_L then
              begin
                Clear;
                Exit;
              end;
            KDStoreBuff[i].Token.Bytes := token_B;
            SetLength(token_B, 0);
          end
        else
            KDStoreBuff[i].Token := '';
        Inc(i);
      end;
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      Inc(i);
    end;

  if cnt > 0 then
      RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT17DI16.SaveToFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(FileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT17DI16.LoadFromFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT17DI16.PrintNodeTree(const NodePtr: PKDT17DI16_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT17DI16_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.Vec^.Index, Vec(p^.Vec^.buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT17DI16.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d - %d : %s ', [i, KDStoreBuff[i].Index, Vec(KDStoreBuff[i].buff)]);
end;

class function TKDT17DI16.Vec(const s: SystemString): TKDT17DI16_Vec;
var
  t: TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j: NativeInt;
begin
  for i := 0 to KDT17DI16_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            Inc(j);
            if j >= KDT17DI16_Axis then
                Break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT17DI16.Vec(const v: TKDT17DI16_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT17DI16_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT17DI16.Distance(const v1, v2: TKDT17DI16_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT17DI16_Axis - 1 do
      Result := Result + (v2[i] - v1[i]) * (v2[i] - v1[i]);
end;

procedure TKDT17DI16.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT17DI16_Source; const Data: Pointer);
begin
  Source.buff := TestBuff[IndexFor];
  Source.Token := umlIntToStr(IndexFor);
end;

class procedure TKDT17DI16.Test;
var
  TKDT17DI16_Test: TKDT17DI16;
  t: TTimeTick;
  i, j: NativeInt;
  TestResultBuff: TKDT17DI16_DynamicVecBuffer;
  TestResultIndex: TKMIntegerArray;
  KMeanOutIndex: TKMIntegerArray;
  errored: Boolean;
  m64: TMemoryStream64;
  p: PKDT17DI16_Node;
  n: TPascalString;
begin
  errored := False;
  n := PFormat('test %s...', [ClassName]);
  t := GetTimeTick;

  n.Append('...build');
  TKDT17DI16_Test := TKDT17DI16.Create;

  n.Append('...');
  SetLength(TKDT17DI16_Test.TestBuff, 1000);
  for i := 0 to length(TKDT17DI16_Test.TestBuff) - 1 do
    for j := 0 to KDT17DI16_Axis - 1 do
        TKDT17DI16_Test.TestBuff[i][j] := i * KDT17DI16_Axis + j;

{$IFDEF FPC}
  TKDT17DI16_Test.BuildKDTreeM(length(TKDT17DI16_Test.TestBuff), nil, @TKDT17DI16_Test.Test_BuildM);
{$ELSE FPC}
  TKDT17DI16_Test.BuildKDTreeM(length(TKDT17DI16_Test.TestBuff), nil, TKDT17DI16_Test.Test_BuildM);
{$ENDIF FPC}
  { save/load test }
  n.Append('...save/load');
  m64 := TMemoryStream64.CustomCreate(1024 * 1024);
  TKDT17DI16_Test.SaveToStream(m64);
  m64.Position := 0;
  TKDT17DI16_Test.LoadFromStream(m64);
  for i := 0 to length(TKDT17DI16_Test.TestBuff) - 1 do
    begin
      p := TKDT17DI16_Test.Search(TKDT17DI16_Test.TestBuff[i]);
      if p^.Vec^.Index <> i then
          errored := True;
      if not p^.Vec^.Token.Same(umlIntToStr(i)) then
          errored := True;
      if errored then
          Break;
    end;
  DisposeObject(m64);

  if not errored then
    begin
      { parallel search test }
      n.Append('...parallel');
      SetLength(TestResultBuff, length(TKDT17DI16_Test.TestBuff));
      SetLength(TestResultIndex, length(TKDT17DI16_Test.TestBuff));
      TKDT17DI16_Test.Search(TKDT17DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if Distance(TKDT17DI16_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
            errored := True;
    end;

  if not errored then
    begin
      n.Append('...kMean');
      TKDT17DI16_Test.Clear;
      { kMean test }
      TKDT17DI16_Test.BuildKDTreeWithCluster(TKDT17DI16_Test.TestBuff, 10, 1, KMeanOutIndex);
      { parallel search test }
      TKDT17DI16_Test.Search(TKDT17DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if TestResultIndex[i] <> KMeanOutIndex[i] then
            errored := True;
    end;

  SetLength(TKDT17DI16_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT17DI16_Test.Clear;

  n.Append('...');
  if errored then
      n.Append('error!')
  else
      n.Append('passed ok %dms', [GetTimeTick - t]);
  DisposeObject(TKDT17DI16_Test);
  DoStatus(n);
  n := '';
end;

function TKDT18DI16.InternalBuildKdTree(const KDSourceBufferPtr: PKDT18DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT18DI16_Node;
  function SortCompare(const p1, p2: PKDT18DI16_Source; const axis: NativeInt): ShortInt;
  begin
    if p1^.buff[axis] = p2^.buff[axis] then
      begin
        if p1^.Index = p2^.Index then
            Result := 0
        else if p1^.Index < p2^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.buff[axis] < p2^.buff[axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT18DI16_SourceBuffer; L, R: NativeInt; const axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT18DI16_Source;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer^[(L + R) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, axis) < 0 do
            Inc(i);
        while SortCompare(SortBuffer^[j], p, axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, axis);
      L := i;
    until i >= R;
  end;

var
  M: NativeInt;
  axis: NativeInt;
  kdBuffPtr: PKDT18DI16_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      new(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.Vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);
    end
  else
    begin
      axis := Depth mod KDT18DI16_Axis;
      M := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr^[0], 0, PlanCount - 1, axis);

      new(Result);
      Result^.Parent := nil;
      Result^.Vec := kdBuffPtr^[M];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], M, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[M + 1], PlanCount - (M + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT18DI16.GetData(const Index: NativeInt): PKDT18DI16_Source;
begin
  Result := @KDStoreBuff[Index];
end;

constructor TKDT18DI16.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT18DI16.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT18DI16.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT18DI16_Node(KDNodes[i]));
      Inc(i);
    end;

  for i := 0 to length(KDStoreBuff) - 1 do
      KDStoreBuff[i].Token := '';

  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT18DI16.StoreBuffPtr: PKDT18DI16_DyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT18DI16.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT18DI16_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT18DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT18DI16.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT18DI16_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT18DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT18DI16.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT18DI16_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT18DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{ k-means++ clusterization }
procedure TKDT18DI16.BuildKDTreeWithCluster(const inBuff: TKDT18DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  SetLength(Source, length(inBuff), KDT18DI16_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT18DI16_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT18DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT18DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT18DI16.BuildKDTreeWithCluster(const inBuff: TKDT18DI16_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TKMIntegerArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT18DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT18DI16_BuildCall);
var
  TempStoreBuff: TKDT18DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT18DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT18DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT18DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT18DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT18DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT18DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT18DI16_BuildMethod);
var
  TempStoreBuff: TKDT18DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT18DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT18DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT18DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT18DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT18DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT18DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT18DI16_BuildProc);
var
  TempStoreBuff: TKDT18DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT18DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT18DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT18DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT18DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT18DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

function TKDT18DI16.Search(const buff: TKDT18DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT18DI16_Node;

var
  NearestNeighbour: PKDT18DI16_Node;

  function FindParentNode(const buffPtr: PKDT18DI16_Vec; NodePtr: PKDT18DI16_Node): PKDT18DI16_Node;
  var
    Next: PKDT18DI16_Node;
    Depth, axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        axis := Depth mod KDT18DI16_Axis;
        if buffPtr^[axis] > Next^.Vec^.buff[axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT18DI16_Node; const buffPtr: PKDT18DI16_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    Inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := Distance(buffPtr^, NodePtr^.Vec^.buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.Vec^.Index < NearestNeighbour^.Vec^.Index) then
        NearestNeighbour := NodePtr;

    axis := Depth mod KDT18DI16_Axis;
    Dist := NodePtr^.Vec^.buff[axis] - buffPtr^[axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.Vec^.buff[axis] > buffPtr^[axis] then
            ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const buffPtr: PKDT18DI16_Vec; const p1, p2: PKDT18DI16_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := Distance(buffPtr^, p1^.Vec^.buff);
    d2 := Distance(buffPtr^, p2^.Vec^.buff);
    if d1 = d2 then
      begin
        if p1^.Vec^.Index = p2^.Vec^.Index then
            Result := 0
        else if p1^.Vec^.Index < p2^.Vec^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; L, R: NativeInt; const buffPtr: PKDT18DI16_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT18DI16_Node;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer[(L + R) shr 1];
      repeat
        while SortCompare(buffPtr, SortBuffer[i], p) < 0 do
            Inc(i);
        while SortCompare(buffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, buffPtr);
      L := i;
    until i >= R;
  end;

var
  Parent: PKDT18DI16_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := Distance(buff, Parent^.Vec^.buff);

  ScanSubtree(RootNode, @buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT18DI16_Node(NearestNodes[0]);
    end;
end;

function TKDT18DI16.Search(const buff: TKDT18DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT18DI16_Node;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT18DI16.Search(const buff: TKDT18DI16_Vec; var SearchedDistanceMin: Double): PKDT18DI16_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT18DI16.Search(const buff: TKDT18DI16_Vec): PKDT18DI16_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT18DI16.SearchToken(const buff: TKDT18DI16_Vec): TPascalString;
var
  p: PKDT18DI16_Node;
begin
  p := Search(buff);
  if p <> nil then
      Result := p^.Vec^.Token
  else
      Result := '';
end;

procedure TKDT18DI16.Search(const inBuff: TKDT18DI16_DynamicVecBuffer; var OutBuff: TKDT18DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT18DI16_DynamicVecBuffer;
  outBuffPtr: PKDT18DI16_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT18DI16_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outBuffPtr^[pass] := p^.Vec^.buff;
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT18DI16_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outBuffPtr^[pass] := p^.Vec^.buff;
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT18DI16_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.Vec^.buff;
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT18DI16.Search(const inBuff: TKDT18DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT18DI16_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT18DI16_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT18DI16_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT18DI16_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT18DI16.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  ID := KDT18DI16_Axis;

  stream.write(st, 4);
  stream.write(ID, 4);

  stream.write(cnt, 8);

  i := 0;
  while i < cnt do
    begin
      stream.write(KDStoreBuff[i].buff[0], SizeOf(TKDT18DI16_Vec));
      stream.write(KDStoreBuff[i].Index, 8);
      token_B := KDStoreBuff[i].Token.Bytes;
      token_L := length(token_B);
      stream.write(token_L, 4);
      if token_L > 0 then
        begin
          stream.write(token_B[0], token_L);
          SetLength(token_B, 0);
        end;
      Inc(i);
    end;
end;

procedure TKDT18DI16.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  Clear;

  stream.read(st, 4);
  stream.read(ID, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if ID <> KDT18DI16_Axis then
      RaiseInfo('kdtree axis error!');

  stream.read(cnt, 8);

  SetLength(KDStoreBuff, cnt);

  i := 0;
  try
    while i < cnt do
      begin
        if stream.read(KDStoreBuff[i].buff[0], SizeOf(TKDT18DI16_Vec)) <> SizeOf(TKDT18DI16_Vec) then
          begin
            Clear;
            Exit;
          end;
        if stream.read(KDStoreBuff[i].Index, 8) <> 8 then
          begin
            Clear;
            Exit;
          end;
        if stream.read(token_L, 4) <> 4 then
          begin
            Clear;
            Exit;
          end;
        if token_L > 0 then
          begin
            SetLength(token_B, token_L);
            if stream.read(token_B[0], token_L) <> token_L then
              begin
                Clear;
                Exit;
              end;
            KDStoreBuff[i].Token.Bytes := token_B;
            SetLength(token_B, 0);
          end
        else
            KDStoreBuff[i].Token := '';
        Inc(i);
      end;
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      Inc(i);
    end;

  if cnt > 0 then
      RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT18DI16.SaveToFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(FileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT18DI16.LoadFromFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT18DI16.PrintNodeTree(const NodePtr: PKDT18DI16_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT18DI16_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.Vec^.Index, Vec(p^.Vec^.buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT18DI16.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d - %d : %s ', [i, KDStoreBuff[i].Index, Vec(KDStoreBuff[i].buff)]);
end;

class function TKDT18DI16.Vec(const s: SystemString): TKDT18DI16_Vec;
var
  t: TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j: NativeInt;
begin
  for i := 0 to KDT18DI16_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            Inc(j);
            if j >= KDT18DI16_Axis then
                Break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT18DI16.Vec(const v: TKDT18DI16_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT18DI16_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT18DI16.Distance(const v1, v2: TKDT18DI16_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT18DI16_Axis - 1 do
      Result := Result + (v2[i] - v1[i]) * (v2[i] - v1[i]);
end;

procedure TKDT18DI16.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT18DI16_Source; const Data: Pointer);
begin
  Source.buff := TestBuff[IndexFor];
  Source.Token := umlIntToStr(IndexFor);
end;

class procedure TKDT18DI16.Test;
var
  TKDT18DI16_Test: TKDT18DI16;
  t: TTimeTick;
  i, j: NativeInt;
  TestResultBuff: TKDT18DI16_DynamicVecBuffer;
  TestResultIndex: TKMIntegerArray;
  KMeanOutIndex: TKMIntegerArray;
  errored: Boolean;
  m64: TMemoryStream64;
  p: PKDT18DI16_Node;
  n: TPascalString;
begin
  errored := False;
  n := PFormat('test %s...', [ClassName]);
  t := GetTimeTick;

  n.Append('...build');
  TKDT18DI16_Test := TKDT18DI16.Create;

  n.Append('...');
  SetLength(TKDT18DI16_Test.TestBuff, 1000);
  for i := 0 to length(TKDT18DI16_Test.TestBuff) - 1 do
    for j := 0 to KDT18DI16_Axis - 1 do
        TKDT18DI16_Test.TestBuff[i][j] := i * KDT18DI16_Axis + j;

{$IFDEF FPC}
  TKDT18DI16_Test.BuildKDTreeM(length(TKDT18DI16_Test.TestBuff), nil, @TKDT18DI16_Test.Test_BuildM);
{$ELSE FPC}
  TKDT18DI16_Test.BuildKDTreeM(length(TKDT18DI16_Test.TestBuff), nil, TKDT18DI16_Test.Test_BuildM);
{$ENDIF FPC}
  { save/load test }
  n.Append('...save/load');
  m64 := TMemoryStream64.CustomCreate(1024 * 1024);
  TKDT18DI16_Test.SaveToStream(m64);
  m64.Position := 0;
  TKDT18DI16_Test.LoadFromStream(m64);
  for i := 0 to length(TKDT18DI16_Test.TestBuff) - 1 do
    begin
      p := TKDT18DI16_Test.Search(TKDT18DI16_Test.TestBuff[i]);
      if p^.Vec^.Index <> i then
          errored := True;
      if not p^.Vec^.Token.Same(umlIntToStr(i)) then
          errored := True;
      if errored then
          Break;
    end;
  DisposeObject(m64);

  if not errored then
    begin
      { parallel search test }
      n.Append('...parallel');
      SetLength(TestResultBuff, length(TKDT18DI16_Test.TestBuff));
      SetLength(TestResultIndex, length(TKDT18DI16_Test.TestBuff));
      TKDT18DI16_Test.Search(TKDT18DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if Distance(TKDT18DI16_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
            errored := True;
    end;

  if not errored then
    begin
      n.Append('...kMean');
      TKDT18DI16_Test.Clear;
      { kMean test }
      TKDT18DI16_Test.BuildKDTreeWithCluster(TKDT18DI16_Test.TestBuff, 10, 1, KMeanOutIndex);
      { parallel search test }
      TKDT18DI16_Test.Search(TKDT18DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if TestResultIndex[i] <> KMeanOutIndex[i] then
            errored := True;
    end;

  SetLength(TKDT18DI16_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT18DI16_Test.Clear;

  n.Append('...');
  if errored then
      n.Append('error!')
  else
      n.Append('passed ok %dms', [GetTimeTick - t]);
  DisposeObject(TKDT18DI16_Test);
  DoStatus(n);
  n := '';
end;

function TKDT19DI16.InternalBuildKdTree(const KDSourceBufferPtr: PKDT19DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT19DI16_Node;
  function SortCompare(const p1, p2: PKDT19DI16_Source; const axis: NativeInt): ShortInt;
  begin
    if p1^.buff[axis] = p2^.buff[axis] then
      begin
        if p1^.Index = p2^.Index then
            Result := 0
        else if p1^.Index < p2^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.buff[axis] < p2^.buff[axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT19DI16_SourceBuffer; L, R: NativeInt; const axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT19DI16_Source;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer^[(L + R) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, axis) < 0 do
            Inc(i);
        while SortCompare(SortBuffer^[j], p, axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, axis);
      L := i;
    until i >= R;
  end;

var
  M: NativeInt;
  axis: NativeInt;
  kdBuffPtr: PKDT19DI16_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      new(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.Vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);
    end
  else
    begin
      axis := Depth mod KDT19DI16_Axis;
      M := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr^[0], 0, PlanCount - 1, axis);

      new(Result);
      Result^.Parent := nil;
      Result^.Vec := kdBuffPtr^[M];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], M, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[M + 1], PlanCount - (M + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT19DI16.GetData(const Index: NativeInt): PKDT19DI16_Source;
begin
  Result := @KDStoreBuff[Index];
end;

constructor TKDT19DI16.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT19DI16.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT19DI16.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT19DI16_Node(KDNodes[i]));
      Inc(i);
    end;

  for i := 0 to length(KDStoreBuff) - 1 do
      KDStoreBuff[i].Token := '';

  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT19DI16.StoreBuffPtr: PKDT19DI16_DyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT19DI16.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT19DI16_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT19DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT19DI16.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT19DI16_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT19DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT19DI16.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT19DI16_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT19DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{ k-means++ clusterization }
procedure TKDT19DI16.BuildKDTreeWithCluster(const inBuff: TKDT19DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  SetLength(Source, length(inBuff), KDT19DI16_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT19DI16_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT19DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT19DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT19DI16.BuildKDTreeWithCluster(const inBuff: TKDT19DI16_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TKMIntegerArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT19DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT19DI16_BuildCall);
var
  TempStoreBuff: TKDT19DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT19DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT19DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT19DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT19DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT19DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT19DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT19DI16_BuildMethod);
var
  TempStoreBuff: TKDT19DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT19DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT19DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT19DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT19DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT19DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT19DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT19DI16_BuildProc);
var
  TempStoreBuff: TKDT19DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT19DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT19DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT19DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT19DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT19DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

function TKDT19DI16.Search(const buff: TKDT19DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT19DI16_Node;

var
  NearestNeighbour: PKDT19DI16_Node;

  function FindParentNode(const buffPtr: PKDT19DI16_Vec; NodePtr: PKDT19DI16_Node): PKDT19DI16_Node;
  var
    Next: PKDT19DI16_Node;
    Depth, axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        axis := Depth mod KDT19DI16_Axis;
        if buffPtr^[axis] > Next^.Vec^.buff[axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT19DI16_Node; const buffPtr: PKDT19DI16_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    Inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := Distance(buffPtr^, NodePtr^.Vec^.buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.Vec^.Index < NearestNeighbour^.Vec^.Index) then
        NearestNeighbour := NodePtr;

    axis := Depth mod KDT19DI16_Axis;
    Dist := NodePtr^.Vec^.buff[axis] - buffPtr^[axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.Vec^.buff[axis] > buffPtr^[axis] then
            ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const buffPtr: PKDT19DI16_Vec; const p1, p2: PKDT19DI16_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := Distance(buffPtr^, p1^.Vec^.buff);
    d2 := Distance(buffPtr^, p2^.Vec^.buff);
    if d1 = d2 then
      begin
        if p1^.Vec^.Index = p2^.Vec^.Index then
            Result := 0
        else if p1^.Vec^.Index < p2^.Vec^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; L, R: NativeInt; const buffPtr: PKDT19DI16_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT19DI16_Node;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer[(L + R) shr 1];
      repeat
        while SortCompare(buffPtr, SortBuffer[i], p) < 0 do
            Inc(i);
        while SortCompare(buffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, buffPtr);
      L := i;
    until i >= R;
  end;

var
  Parent: PKDT19DI16_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := Distance(buff, Parent^.Vec^.buff);

  ScanSubtree(RootNode, @buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT19DI16_Node(NearestNodes[0]);
    end;
end;

function TKDT19DI16.Search(const buff: TKDT19DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT19DI16_Node;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT19DI16.Search(const buff: TKDT19DI16_Vec; var SearchedDistanceMin: Double): PKDT19DI16_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT19DI16.Search(const buff: TKDT19DI16_Vec): PKDT19DI16_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT19DI16.SearchToken(const buff: TKDT19DI16_Vec): TPascalString;
var
  p: PKDT19DI16_Node;
begin
  p := Search(buff);
  if p <> nil then
      Result := p^.Vec^.Token
  else
      Result := '';
end;

procedure TKDT19DI16.Search(const inBuff: TKDT19DI16_DynamicVecBuffer; var OutBuff: TKDT19DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT19DI16_DynamicVecBuffer;
  outBuffPtr: PKDT19DI16_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT19DI16_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outBuffPtr^[pass] := p^.Vec^.buff;
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT19DI16_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outBuffPtr^[pass] := p^.Vec^.buff;
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT19DI16_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.Vec^.buff;
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT19DI16.Search(const inBuff: TKDT19DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT19DI16_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT19DI16_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT19DI16_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT19DI16_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT19DI16.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  ID := KDT19DI16_Axis;

  stream.write(st, 4);
  stream.write(ID, 4);

  stream.write(cnt, 8);

  i := 0;
  while i < cnt do
    begin
      stream.write(KDStoreBuff[i].buff[0], SizeOf(TKDT19DI16_Vec));
      stream.write(KDStoreBuff[i].Index, 8);
      token_B := KDStoreBuff[i].Token.Bytes;
      token_L := length(token_B);
      stream.write(token_L, 4);
      if token_L > 0 then
        begin
          stream.write(token_B[0], token_L);
          SetLength(token_B, 0);
        end;
      Inc(i);
    end;
end;

procedure TKDT19DI16.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  Clear;

  stream.read(st, 4);
  stream.read(ID, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if ID <> KDT19DI16_Axis then
      RaiseInfo('kdtree axis error!');

  stream.read(cnt, 8);

  SetLength(KDStoreBuff, cnt);

  i := 0;
  try
    while i < cnt do
      begin
        if stream.read(KDStoreBuff[i].buff[0], SizeOf(TKDT19DI16_Vec)) <> SizeOf(TKDT19DI16_Vec) then
          begin
            Clear;
            Exit;
          end;
        if stream.read(KDStoreBuff[i].Index, 8) <> 8 then
          begin
            Clear;
            Exit;
          end;
        if stream.read(token_L, 4) <> 4 then
          begin
            Clear;
            Exit;
          end;
        if token_L > 0 then
          begin
            SetLength(token_B, token_L);
            if stream.read(token_B[0], token_L) <> token_L then
              begin
                Clear;
                Exit;
              end;
            KDStoreBuff[i].Token.Bytes := token_B;
            SetLength(token_B, 0);
          end
        else
            KDStoreBuff[i].Token := '';
        Inc(i);
      end;
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      Inc(i);
    end;

  if cnt > 0 then
      RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT19DI16.SaveToFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(FileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT19DI16.LoadFromFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT19DI16.PrintNodeTree(const NodePtr: PKDT19DI16_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT19DI16_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.Vec^.Index, Vec(p^.Vec^.buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT19DI16.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d - %d : %s ', [i, KDStoreBuff[i].Index, Vec(KDStoreBuff[i].buff)]);
end;

class function TKDT19DI16.Vec(const s: SystemString): TKDT19DI16_Vec;
var
  t: TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j: NativeInt;
begin
  for i := 0 to KDT19DI16_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            Inc(j);
            if j >= KDT19DI16_Axis then
                Break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT19DI16.Vec(const v: TKDT19DI16_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT19DI16_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT19DI16.Distance(const v1, v2: TKDT19DI16_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT19DI16_Axis - 1 do
      Result := Result + (v2[i] - v1[i]) * (v2[i] - v1[i]);
end;

procedure TKDT19DI16.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT19DI16_Source; const Data: Pointer);
begin
  Source.buff := TestBuff[IndexFor];
  Source.Token := umlIntToStr(IndexFor);
end;

class procedure TKDT19DI16.Test;
var
  TKDT19DI16_Test: TKDT19DI16;
  t: TTimeTick;
  i, j: NativeInt;
  TestResultBuff: TKDT19DI16_DynamicVecBuffer;
  TestResultIndex: TKMIntegerArray;
  KMeanOutIndex: TKMIntegerArray;
  errored: Boolean;
  m64: TMemoryStream64;
  p: PKDT19DI16_Node;
  n: TPascalString;
begin
  errored := False;
  n := PFormat('test %s...', [ClassName]);
  t := GetTimeTick;

  n.Append('...build');
  TKDT19DI16_Test := TKDT19DI16.Create;

  n.Append('...');
  SetLength(TKDT19DI16_Test.TestBuff, 1000);
  for i := 0 to length(TKDT19DI16_Test.TestBuff) - 1 do
    for j := 0 to KDT19DI16_Axis - 1 do
        TKDT19DI16_Test.TestBuff[i][j] := i * KDT19DI16_Axis + j;

{$IFDEF FPC}
  TKDT19DI16_Test.BuildKDTreeM(length(TKDT19DI16_Test.TestBuff), nil, @TKDT19DI16_Test.Test_BuildM);
{$ELSE FPC}
  TKDT19DI16_Test.BuildKDTreeM(length(TKDT19DI16_Test.TestBuff), nil, TKDT19DI16_Test.Test_BuildM);
{$ENDIF FPC}
  { save/load test }
  n.Append('...save/load');
  m64 := TMemoryStream64.CustomCreate(1024 * 1024);
  TKDT19DI16_Test.SaveToStream(m64);
  m64.Position := 0;
  TKDT19DI16_Test.LoadFromStream(m64);
  for i := 0 to length(TKDT19DI16_Test.TestBuff) - 1 do
    begin
      p := TKDT19DI16_Test.Search(TKDT19DI16_Test.TestBuff[i]);
      if p^.Vec^.Index <> i then
          errored := True;
      if not p^.Vec^.Token.Same(umlIntToStr(i)) then
          errored := True;
      if errored then
          Break;
    end;
  DisposeObject(m64);

  if not errored then
    begin
      { parallel search test }
      n.Append('...parallel');
      SetLength(TestResultBuff, length(TKDT19DI16_Test.TestBuff));
      SetLength(TestResultIndex, length(TKDT19DI16_Test.TestBuff));
      TKDT19DI16_Test.Search(TKDT19DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if Distance(TKDT19DI16_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
            errored := True;
    end;

  if not errored then
    begin
      n.Append('...kMean');
      TKDT19DI16_Test.Clear;
      { kMean test }
      TKDT19DI16_Test.BuildKDTreeWithCluster(TKDT19DI16_Test.TestBuff, 10, 1, KMeanOutIndex);
      { parallel search test }
      TKDT19DI16_Test.Search(TKDT19DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if TestResultIndex[i] <> KMeanOutIndex[i] then
            errored := True;
    end;

  SetLength(TKDT19DI16_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT19DI16_Test.Clear;

  n.Append('...');
  if errored then
      n.Append('error!')
  else
      n.Append('passed ok %dms', [GetTimeTick - t]);
  DisposeObject(TKDT19DI16_Test);
  DoStatus(n);
  n := '';
end;

function TKDT20DI16.InternalBuildKdTree(const KDSourceBufferPtr: PKDT20DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT20DI16_Node;
  function SortCompare(const p1, p2: PKDT20DI16_Source; const axis: NativeInt): ShortInt;
  begin
    if p1^.buff[axis] = p2^.buff[axis] then
      begin
        if p1^.Index = p2^.Index then
            Result := 0
        else if p1^.Index < p2^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.buff[axis] < p2^.buff[axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT20DI16_SourceBuffer; L, R: NativeInt; const axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT20DI16_Source;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer^[(L + R) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, axis) < 0 do
            Inc(i);
        while SortCompare(SortBuffer^[j], p, axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, axis);
      L := i;
    until i >= R;
  end;

var
  M: NativeInt;
  axis: NativeInt;
  kdBuffPtr: PKDT20DI16_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      new(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.Vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);
    end
  else
    begin
      axis := Depth mod KDT20DI16_Axis;
      M := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr^[0], 0, PlanCount - 1, axis);

      new(Result);
      Result^.Parent := nil;
      Result^.Vec := kdBuffPtr^[M];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], M, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[M + 1], PlanCount - (M + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT20DI16.GetData(const Index: NativeInt): PKDT20DI16_Source;
begin
  Result := @KDStoreBuff[Index];
end;

constructor TKDT20DI16.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT20DI16.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT20DI16.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT20DI16_Node(KDNodes[i]));
      Inc(i);
    end;

  for i := 0 to length(KDStoreBuff) - 1 do
      KDStoreBuff[i].Token := '';

  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT20DI16.StoreBuffPtr: PKDT20DI16_DyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT20DI16.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT20DI16_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT20DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT20DI16.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT20DI16_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT20DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT20DI16.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT20DI16_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT20DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{ k-means++ clusterization }
procedure TKDT20DI16.BuildKDTreeWithCluster(const inBuff: TKDT20DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  SetLength(Source, length(inBuff), KDT20DI16_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT20DI16_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT20DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT20DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT20DI16.BuildKDTreeWithCluster(const inBuff: TKDT20DI16_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TKMIntegerArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT20DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT20DI16_BuildCall);
var
  TempStoreBuff: TKDT20DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT20DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT20DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT20DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT20DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT20DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT20DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT20DI16_BuildMethod);
var
  TempStoreBuff: TKDT20DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT20DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT20DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT20DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT20DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT20DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT20DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT20DI16_BuildProc);
var
  TempStoreBuff: TKDT20DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT20DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT20DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT20DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT20DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT20DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

function TKDT20DI16.Search(const buff: TKDT20DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT20DI16_Node;

var
  NearestNeighbour: PKDT20DI16_Node;

  function FindParentNode(const buffPtr: PKDT20DI16_Vec; NodePtr: PKDT20DI16_Node): PKDT20DI16_Node;
  var
    Next: PKDT20DI16_Node;
    Depth, axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        axis := Depth mod KDT20DI16_Axis;
        if buffPtr^[axis] > Next^.Vec^.buff[axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT20DI16_Node; const buffPtr: PKDT20DI16_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    Inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := Distance(buffPtr^, NodePtr^.Vec^.buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.Vec^.Index < NearestNeighbour^.Vec^.Index) then
        NearestNeighbour := NodePtr;

    axis := Depth mod KDT20DI16_Axis;
    Dist := NodePtr^.Vec^.buff[axis] - buffPtr^[axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.Vec^.buff[axis] > buffPtr^[axis] then
            ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const buffPtr: PKDT20DI16_Vec; const p1, p2: PKDT20DI16_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := Distance(buffPtr^, p1^.Vec^.buff);
    d2 := Distance(buffPtr^, p2^.Vec^.buff);
    if d1 = d2 then
      begin
        if p1^.Vec^.Index = p2^.Vec^.Index then
            Result := 0
        else if p1^.Vec^.Index < p2^.Vec^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; L, R: NativeInt; const buffPtr: PKDT20DI16_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT20DI16_Node;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer[(L + R) shr 1];
      repeat
        while SortCompare(buffPtr, SortBuffer[i], p) < 0 do
            Inc(i);
        while SortCompare(buffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, buffPtr);
      L := i;
    until i >= R;
  end;

var
  Parent: PKDT20DI16_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := Distance(buff, Parent^.Vec^.buff);

  ScanSubtree(RootNode, @buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT20DI16_Node(NearestNodes[0]);
    end;
end;

function TKDT20DI16.Search(const buff: TKDT20DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT20DI16_Node;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT20DI16.Search(const buff: TKDT20DI16_Vec; var SearchedDistanceMin: Double): PKDT20DI16_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT20DI16.Search(const buff: TKDT20DI16_Vec): PKDT20DI16_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT20DI16.SearchToken(const buff: TKDT20DI16_Vec): TPascalString;
var
  p: PKDT20DI16_Node;
begin
  p := Search(buff);
  if p <> nil then
      Result := p^.Vec^.Token
  else
      Result := '';
end;

procedure TKDT20DI16.Search(const inBuff: TKDT20DI16_DynamicVecBuffer; var OutBuff: TKDT20DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT20DI16_DynamicVecBuffer;
  outBuffPtr: PKDT20DI16_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT20DI16_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outBuffPtr^[pass] := p^.Vec^.buff;
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT20DI16_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outBuffPtr^[pass] := p^.Vec^.buff;
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT20DI16_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.Vec^.buff;
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT20DI16.Search(const inBuff: TKDT20DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT20DI16_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT20DI16_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT20DI16_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT20DI16_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT20DI16.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  ID := KDT20DI16_Axis;

  stream.write(st, 4);
  stream.write(ID, 4);

  stream.write(cnt, 8);

  i := 0;
  while i < cnt do
    begin
      stream.write(KDStoreBuff[i].buff[0], SizeOf(TKDT20DI16_Vec));
      stream.write(KDStoreBuff[i].Index, 8);
      token_B := KDStoreBuff[i].Token.Bytes;
      token_L := length(token_B);
      stream.write(token_L, 4);
      if token_L > 0 then
        begin
          stream.write(token_B[0], token_L);
          SetLength(token_B, 0);
        end;
      Inc(i);
    end;
end;

procedure TKDT20DI16.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  Clear;

  stream.read(st, 4);
  stream.read(ID, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if ID <> KDT20DI16_Axis then
      RaiseInfo('kdtree axis error!');

  stream.read(cnt, 8);

  SetLength(KDStoreBuff, cnt);

  i := 0;
  try
    while i < cnt do
      begin
        if stream.read(KDStoreBuff[i].buff[0], SizeOf(TKDT20DI16_Vec)) <> SizeOf(TKDT20DI16_Vec) then
          begin
            Clear;
            Exit;
          end;
        if stream.read(KDStoreBuff[i].Index, 8) <> 8 then
          begin
            Clear;
            Exit;
          end;
        if stream.read(token_L, 4) <> 4 then
          begin
            Clear;
            Exit;
          end;
        if token_L > 0 then
          begin
            SetLength(token_B, token_L);
            if stream.read(token_B[0], token_L) <> token_L then
              begin
                Clear;
                Exit;
              end;
            KDStoreBuff[i].Token.Bytes := token_B;
            SetLength(token_B, 0);
          end
        else
            KDStoreBuff[i].Token := '';
        Inc(i);
      end;
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      Inc(i);
    end;

  if cnt > 0 then
      RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT20DI16.SaveToFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(FileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT20DI16.LoadFromFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT20DI16.PrintNodeTree(const NodePtr: PKDT20DI16_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT20DI16_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.Vec^.Index, Vec(p^.Vec^.buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT20DI16.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d - %d : %s ', [i, KDStoreBuff[i].Index, Vec(KDStoreBuff[i].buff)]);
end;

class function TKDT20DI16.Vec(const s: SystemString): TKDT20DI16_Vec;
var
  t: TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j: NativeInt;
begin
  for i := 0 to KDT20DI16_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            Inc(j);
            if j >= KDT20DI16_Axis then
                Break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT20DI16.Vec(const v: TKDT20DI16_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT20DI16_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT20DI16.Distance(const v1, v2: TKDT20DI16_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT20DI16_Axis - 1 do
      Result := Result + (v2[i] - v1[i]) * (v2[i] - v1[i]);
end;

procedure TKDT20DI16.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT20DI16_Source; const Data: Pointer);
begin
  Source.buff := TestBuff[IndexFor];
  Source.Token := umlIntToStr(IndexFor);
end;

class procedure TKDT20DI16.Test;
var
  TKDT20DI16_Test: TKDT20DI16;
  t: TTimeTick;
  i, j: NativeInt;
  TestResultBuff: TKDT20DI16_DynamicVecBuffer;
  TestResultIndex: TKMIntegerArray;
  KMeanOutIndex: TKMIntegerArray;
  errored: Boolean;
  m64: TMemoryStream64;
  p: PKDT20DI16_Node;
  n: TPascalString;
begin
  errored := False;
  n := PFormat('test %s...', [ClassName]);
  t := GetTimeTick;

  n.Append('...build');
  TKDT20DI16_Test := TKDT20DI16.Create;

  n.Append('...');
  SetLength(TKDT20DI16_Test.TestBuff, 1000);
  for i := 0 to length(TKDT20DI16_Test.TestBuff) - 1 do
    for j := 0 to KDT20DI16_Axis - 1 do
        TKDT20DI16_Test.TestBuff[i][j] := i * KDT20DI16_Axis + j;

{$IFDEF FPC}
  TKDT20DI16_Test.BuildKDTreeM(length(TKDT20DI16_Test.TestBuff), nil, @TKDT20DI16_Test.Test_BuildM);
{$ELSE FPC}
  TKDT20DI16_Test.BuildKDTreeM(length(TKDT20DI16_Test.TestBuff), nil, TKDT20DI16_Test.Test_BuildM);
{$ENDIF FPC}
  { save/load test }
  n.Append('...save/load');
  m64 := TMemoryStream64.CustomCreate(1024 * 1024);
  TKDT20DI16_Test.SaveToStream(m64);
  m64.Position := 0;
  TKDT20DI16_Test.LoadFromStream(m64);
  for i := 0 to length(TKDT20DI16_Test.TestBuff) - 1 do
    begin
      p := TKDT20DI16_Test.Search(TKDT20DI16_Test.TestBuff[i]);
      if p^.Vec^.Index <> i then
          errored := True;
      if not p^.Vec^.Token.Same(umlIntToStr(i)) then
          errored := True;
      if errored then
          Break;
    end;
  DisposeObject(m64);

  if not errored then
    begin
      { parallel search test }
      n.Append('...parallel');
      SetLength(TestResultBuff, length(TKDT20DI16_Test.TestBuff));
      SetLength(TestResultIndex, length(TKDT20DI16_Test.TestBuff));
      TKDT20DI16_Test.Search(TKDT20DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if Distance(TKDT20DI16_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
            errored := True;
    end;

  if not errored then
    begin
      n.Append('...kMean');
      TKDT20DI16_Test.Clear;
      { kMean test }
      TKDT20DI16_Test.BuildKDTreeWithCluster(TKDT20DI16_Test.TestBuff, 10, 1, KMeanOutIndex);
      { parallel search test }
      TKDT20DI16_Test.Search(TKDT20DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if TestResultIndex[i] <> KMeanOutIndex[i] then
            errored := True;
    end;

  SetLength(TKDT20DI16_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT20DI16_Test.Clear;

  n.Append('...');
  if errored then
      n.Append('error!')
  else
      n.Append('passed ok %dms', [GetTimeTick - t]);
  DisposeObject(TKDT20DI16_Test);
  DoStatus(n);
  n := '';
end;

function TKDT21DI16.InternalBuildKdTree(const KDSourceBufferPtr: PKDT21DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT21DI16_Node;
  function SortCompare(const p1, p2: PKDT21DI16_Source; const axis: NativeInt): ShortInt;
  begin
    if p1^.buff[axis] = p2^.buff[axis] then
      begin
        if p1^.Index = p2^.Index then
            Result := 0
        else if p1^.Index < p2^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.buff[axis] < p2^.buff[axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT21DI16_SourceBuffer; L, R: NativeInt; const axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT21DI16_Source;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer^[(L + R) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, axis) < 0 do
            Inc(i);
        while SortCompare(SortBuffer^[j], p, axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, axis);
      L := i;
    until i >= R;
  end;

var
  M: NativeInt;
  axis: NativeInt;
  kdBuffPtr: PKDT21DI16_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      new(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.Vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);
    end
  else
    begin
      axis := Depth mod KDT21DI16_Axis;
      M := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr^[0], 0, PlanCount - 1, axis);

      new(Result);
      Result^.Parent := nil;
      Result^.Vec := kdBuffPtr^[M];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], M, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[M + 1], PlanCount - (M + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT21DI16.GetData(const Index: NativeInt): PKDT21DI16_Source;
begin
  Result := @KDStoreBuff[Index];
end;

constructor TKDT21DI16.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT21DI16.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT21DI16.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT21DI16_Node(KDNodes[i]));
      Inc(i);
    end;

  for i := 0 to length(KDStoreBuff) - 1 do
      KDStoreBuff[i].Token := '';

  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT21DI16.StoreBuffPtr: PKDT21DI16_DyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT21DI16.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT21DI16_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT21DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT21DI16.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT21DI16_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT21DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT21DI16.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT21DI16_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT21DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{ k-means++ clusterization }
procedure TKDT21DI16.BuildKDTreeWithCluster(const inBuff: TKDT21DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  SetLength(Source, length(inBuff), KDT21DI16_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT21DI16_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT21DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT21DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT21DI16.BuildKDTreeWithCluster(const inBuff: TKDT21DI16_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TKMIntegerArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT21DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT21DI16_BuildCall);
var
  TempStoreBuff: TKDT21DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT21DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT21DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT21DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT21DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT21DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT21DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT21DI16_BuildMethod);
var
  TempStoreBuff: TKDT21DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT21DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT21DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT21DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT21DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT21DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT21DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT21DI16_BuildProc);
var
  TempStoreBuff: TKDT21DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT21DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT21DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT21DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT21DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT21DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

function TKDT21DI16.Search(const buff: TKDT21DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT21DI16_Node;

var
  NearestNeighbour: PKDT21DI16_Node;

  function FindParentNode(const buffPtr: PKDT21DI16_Vec; NodePtr: PKDT21DI16_Node): PKDT21DI16_Node;
  var
    Next: PKDT21DI16_Node;
    Depth, axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        axis := Depth mod KDT21DI16_Axis;
        if buffPtr^[axis] > Next^.Vec^.buff[axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT21DI16_Node; const buffPtr: PKDT21DI16_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    Inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := Distance(buffPtr^, NodePtr^.Vec^.buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.Vec^.Index < NearestNeighbour^.Vec^.Index) then
        NearestNeighbour := NodePtr;

    axis := Depth mod KDT21DI16_Axis;
    Dist := NodePtr^.Vec^.buff[axis] - buffPtr^[axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.Vec^.buff[axis] > buffPtr^[axis] then
            ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const buffPtr: PKDT21DI16_Vec; const p1, p2: PKDT21DI16_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := Distance(buffPtr^, p1^.Vec^.buff);
    d2 := Distance(buffPtr^, p2^.Vec^.buff);
    if d1 = d2 then
      begin
        if p1^.Vec^.Index = p2^.Vec^.Index then
            Result := 0
        else if p1^.Vec^.Index < p2^.Vec^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; L, R: NativeInt; const buffPtr: PKDT21DI16_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT21DI16_Node;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer[(L + R) shr 1];
      repeat
        while SortCompare(buffPtr, SortBuffer[i], p) < 0 do
            Inc(i);
        while SortCompare(buffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, buffPtr);
      L := i;
    until i >= R;
  end;

var
  Parent: PKDT21DI16_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := Distance(buff, Parent^.Vec^.buff);

  ScanSubtree(RootNode, @buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT21DI16_Node(NearestNodes[0]);
    end;
end;

function TKDT21DI16.Search(const buff: TKDT21DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT21DI16_Node;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT21DI16.Search(const buff: TKDT21DI16_Vec; var SearchedDistanceMin: Double): PKDT21DI16_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT21DI16.Search(const buff: TKDT21DI16_Vec): PKDT21DI16_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT21DI16.SearchToken(const buff: TKDT21DI16_Vec): TPascalString;
var
  p: PKDT21DI16_Node;
begin
  p := Search(buff);
  if p <> nil then
      Result := p^.Vec^.Token
  else
      Result := '';
end;

procedure TKDT21DI16.Search(const inBuff: TKDT21DI16_DynamicVecBuffer; var OutBuff: TKDT21DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT21DI16_DynamicVecBuffer;
  outBuffPtr: PKDT21DI16_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT21DI16_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outBuffPtr^[pass] := p^.Vec^.buff;
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT21DI16_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outBuffPtr^[pass] := p^.Vec^.buff;
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT21DI16_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.Vec^.buff;
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT21DI16.Search(const inBuff: TKDT21DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT21DI16_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT21DI16_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT21DI16_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT21DI16_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT21DI16.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  ID := KDT21DI16_Axis;

  stream.write(st, 4);
  stream.write(ID, 4);

  stream.write(cnt, 8);

  i := 0;
  while i < cnt do
    begin
      stream.write(KDStoreBuff[i].buff[0], SizeOf(TKDT21DI16_Vec));
      stream.write(KDStoreBuff[i].Index, 8);
      token_B := KDStoreBuff[i].Token.Bytes;
      token_L := length(token_B);
      stream.write(token_L, 4);
      if token_L > 0 then
        begin
          stream.write(token_B[0], token_L);
          SetLength(token_B, 0);
        end;
      Inc(i);
    end;
end;

procedure TKDT21DI16.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  Clear;

  stream.read(st, 4);
  stream.read(ID, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if ID <> KDT21DI16_Axis then
      RaiseInfo('kdtree axis error!');

  stream.read(cnt, 8);

  SetLength(KDStoreBuff, cnt);

  i := 0;
  try
    while i < cnt do
      begin
        if stream.read(KDStoreBuff[i].buff[0], SizeOf(TKDT21DI16_Vec)) <> SizeOf(TKDT21DI16_Vec) then
          begin
            Clear;
            Exit;
          end;
        if stream.read(KDStoreBuff[i].Index, 8) <> 8 then
          begin
            Clear;
            Exit;
          end;
        if stream.read(token_L, 4) <> 4 then
          begin
            Clear;
            Exit;
          end;
        if token_L > 0 then
          begin
            SetLength(token_B, token_L);
            if stream.read(token_B[0], token_L) <> token_L then
              begin
                Clear;
                Exit;
              end;
            KDStoreBuff[i].Token.Bytes := token_B;
            SetLength(token_B, 0);
          end
        else
            KDStoreBuff[i].Token := '';
        Inc(i);
      end;
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      Inc(i);
    end;

  if cnt > 0 then
      RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT21DI16.SaveToFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(FileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT21DI16.LoadFromFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT21DI16.PrintNodeTree(const NodePtr: PKDT21DI16_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT21DI16_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.Vec^.Index, Vec(p^.Vec^.buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT21DI16.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d - %d : %s ', [i, KDStoreBuff[i].Index, Vec(KDStoreBuff[i].buff)]);
end;

class function TKDT21DI16.Vec(const s: SystemString): TKDT21DI16_Vec;
var
  t: TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j: NativeInt;
begin
  for i := 0 to KDT21DI16_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            Inc(j);
            if j >= KDT21DI16_Axis then
                Break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT21DI16.Vec(const v: TKDT21DI16_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT21DI16_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT21DI16.Distance(const v1, v2: TKDT21DI16_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT21DI16_Axis - 1 do
      Result := Result + (v2[i] - v1[i]) * (v2[i] - v1[i]);
end;

procedure TKDT21DI16.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT21DI16_Source; const Data: Pointer);
begin
  Source.buff := TestBuff[IndexFor];
  Source.Token := umlIntToStr(IndexFor);
end;

class procedure TKDT21DI16.Test;
var
  TKDT21DI16_Test: TKDT21DI16;
  t: TTimeTick;
  i, j: NativeInt;
  TestResultBuff: TKDT21DI16_DynamicVecBuffer;
  TestResultIndex: TKMIntegerArray;
  KMeanOutIndex: TKMIntegerArray;
  errored: Boolean;
  m64: TMemoryStream64;
  p: PKDT21DI16_Node;
  n: TPascalString;
begin
  errored := False;
  n := PFormat('test %s...', [ClassName]);
  t := GetTimeTick;

  n.Append('...build');
  TKDT21DI16_Test := TKDT21DI16.Create;

  n.Append('...');
  SetLength(TKDT21DI16_Test.TestBuff, 1000);
  for i := 0 to length(TKDT21DI16_Test.TestBuff) - 1 do
    for j := 0 to KDT21DI16_Axis - 1 do
        TKDT21DI16_Test.TestBuff[i][j] := i * KDT21DI16_Axis + j;

{$IFDEF FPC}
  TKDT21DI16_Test.BuildKDTreeM(length(TKDT21DI16_Test.TestBuff), nil, @TKDT21DI16_Test.Test_BuildM);
{$ELSE FPC}
  TKDT21DI16_Test.BuildKDTreeM(length(TKDT21DI16_Test.TestBuff), nil, TKDT21DI16_Test.Test_BuildM);
{$ENDIF FPC}
  { save/load test }
  n.Append('...save/load');
  m64 := TMemoryStream64.CustomCreate(1024 * 1024);
  TKDT21DI16_Test.SaveToStream(m64);
  m64.Position := 0;
  TKDT21DI16_Test.LoadFromStream(m64);
  for i := 0 to length(TKDT21DI16_Test.TestBuff) - 1 do
    begin
      p := TKDT21DI16_Test.Search(TKDT21DI16_Test.TestBuff[i]);
      if p^.Vec^.Index <> i then
          errored := True;
      if not p^.Vec^.Token.Same(umlIntToStr(i)) then
          errored := True;
      if errored then
          Break;
    end;
  DisposeObject(m64);

  if not errored then
    begin
      { parallel search test }
      n.Append('...parallel');
      SetLength(TestResultBuff, length(TKDT21DI16_Test.TestBuff));
      SetLength(TestResultIndex, length(TKDT21DI16_Test.TestBuff));
      TKDT21DI16_Test.Search(TKDT21DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if Distance(TKDT21DI16_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
            errored := True;
    end;

  if not errored then
    begin
      n.Append('...kMean');
      TKDT21DI16_Test.Clear;
      { kMean test }
      TKDT21DI16_Test.BuildKDTreeWithCluster(TKDT21DI16_Test.TestBuff, 10, 1, KMeanOutIndex);
      { parallel search test }
      TKDT21DI16_Test.Search(TKDT21DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if TestResultIndex[i] <> KMeanOutIndex[i] then
            errored := True;
    end;

  SetLength(TKDT21DI16_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT21DI16_Test.Clear;

  n.Append('...');
  if errored then
      n.Append('error!')
  else
      n.Append('passed ok %dms', [GetTimeTick - t]);
  DisposeObject(TKDT21DI16_Test);
  DoStatus(n);
  n := '';
end;

function TKDT22DI16.InternalBuildKdTree(const KDSourceBufferPtr: PKDT22DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT22DI16_Node;
  function SortCompare(const p1, p2: PKDT22DI16_Source; const axis: NativeInt): ShortInt;
  begin
    if p1^.buff[axis] = p2^.buff[axis] then
      begin
        if p1^.Index = p2^.Index then
            Result := 0
        else if p1^.Index < p2^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.buff[axis] < p2^.buff[axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT22DI16_SourceBuffer; L, R: NativeInt; const axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT22DI16_Source;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer^[(L + R) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, axis) < 0 do
            Inc(i);
        while SortCompare(SortBuffer^[j], p, axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, axis);
      L := i;
    until i >= R;
  end;

var
  M: NativeInt;
  axis: NativeInt;
  kdBuffPtr: PKDT22DI16_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      new(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.Vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);
    end
  else
    begin
      axis := Depth mod KDT22DI16_Axis;
      M := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr^[0], 0, PlanCount - 1, axis);

      new(Result);
      Result^.Parent := nil;
      Result^.Vec := kdBuffPtr^[M];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], M, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[M + 1], PlanCount - (M + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT22DI16.GetData(const Index: NativeInt): PKDT22DI16_Source;
begin
  Result := @KDStoreBuff[Index];
end;

constructor TKDT22DI16.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT22DI16.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT22DI16.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT22DI16_Node(KDNodes[i]));
      Inc(i);
    end;

  for i := 0 to length(KDStoreBuff) - 1 do
      KDStoreBuff[i].Token := '';

  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT22DI16.StoreBuffPtr: PKDT22DI16_DyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT22DI16.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT22DI16_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT22DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT22DI16.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT22DI16_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT22DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT22DI16.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT22DI16_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT22DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{ k-means++ clusterization }
procedure TKDT22DI16.BuildKDTreeWithCluster(const inBuff: TKDT22DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  SetLength(Source, length(inBuff), KDT22DI16_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT22DI16_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT22DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT22DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT22DI16.BuildKDTreeWithCluster(const inBuff: TKDT22DI16_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TKMIntegerArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT22DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT22DI16_BuildCall);
var
  TempStoreBuff: TKDT22DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT22DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT22DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT22DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT22DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT22DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT22DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT22DI16_BuildMethod);
var
  TempStoreBuff: TKDT22DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT22DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT22DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT22DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT22DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT22DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT22DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT22DI16_BuildProc);
var
  TempStoreBuff: TKDT22DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT22DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT22DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT22DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT22DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT22DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

function TKDT22DI16.Search(const buff: TKDT22DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT22DI16_Node;

var
  NearestNeighbour: PKDT22DI16_Node;

  function FindParentNode(const buffPtr: PKDT22DI16_Vec; NodePtr: PKDT22DI16_Node): PKDT22DI16_Node;
  var
    Next: PKDT22DI16_Node;
    Depth, axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        axis := Depth mod KDT22DI16_Axis;
        if buffPtr^[axis] > Next^.Vec^.buff[axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT22DI16_Node; const buffPtr: PKDT22DI16_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    Inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := Distance(buffPtr^, NodePtr^.Vec^.buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.Vec^.Index < NearestNeighbour^.Vec^.Index) then
        NearestNeighbour := NodePtr;

    axis := Depth mod KDT22DI16_Axis;
    Dist := NodePtr^.Vec^.buff[axis] - buffPtr^[axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.Vec^.buff[axis] > buffPtr^[axis] then
            ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const buffPtr: PKDT22DI16_Vec; const p1, p2: PKDT22DI16_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := Distance(buffPtr^, p1^.Vec^.buff);
    d2 := Distance(buffPtr^, p2^.Vec^.buff);
    if d1 = d2 then
      begin
        if p1^.Vec^.Index = p2^.Vec^.Index then
            Result := 0
        else if p1^.Vec^.Index < p2^.Vec^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; L, R: NativeInt; const buffPtr: PKDT22DI16_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT22DI16_Node;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer[(L + R) shr 1];
      repeat
        while SortCompare(buffPtr, SortBuffer[i], p) < 0 do
            Inc(i);
        while SortCompare(buffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, buffPtr);
      L := i;
    until i >= R;
  end;

var
  Parent: PKDT22DI16_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := Distance(buff, Parent^.Vec^.buff);

  ScanSubtree(RootNode, @buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT22DI16_Node(NearestNodes[0]);
    end;
end;

function TKDT22DI16.Search(const buff: TKDT22DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT22DI16_Node;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT22DI16.Search(const buff: TKDT22DI16_Vec; var SearchedDistanceMin: Double): PKDT22DI16_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT22DI16.Search(const buff: TKDT22DI16_Vec): PKDT22DI16_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT22DI16.SearchToken(const buff: TKDT22DI16_Vec): TPascalString;
var
  p: PKDT22DI16_Node;
begin
  p := Search(buff);
  if p <> nil then
      Result := p^.Vec^.Token
  else
      Result := '';
end;

procedure TKDT22DI16.Search(const inBuff: TKDT22DI16_DynamicVecBuffer; var OutBuff: TKDT22DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT22DI16_DynamicVecBuffer;
  outBuffPtr: PKDT22DI16_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT22DI16_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outBuffPtr^[pass] := p^.Vec^.buff;
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT22DI16_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outBuffPtr^[pass] := p^.Vec^.buff;
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT22DI16_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.Vec^.buff;
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT22DI16.Search(const inBuff: TKDT22DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT22DI16_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT22DI16_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT22DI16_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT22DI16_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT22DI16.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  ID := KDT22DI16_Axis;

  stream.write(st, 4);
  stream.write(ID, 4);

  stream.write(cnt, 8);

  i := 0;
  while i < cnt do
    begin
      stream.write(KDStoreBuff[i].buff[0], SizeOf(TKDT22DI16_Vec));
      stream.write(KDStoreBuff[i].Index, 8);
      token_B := KDStoreBuff[i].Token.Bytes;
      token_L := length(token_B);
      stream.write(token_L, 4);
      if token_L > 0 then
        begin
          stream.write(token_B[0], token_L);
          SetLength(token_B, 0);
        end;
      Inc(i);
    end;
end;

procedure TKDT22DI16.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  Clear;

  stream.read(st, 4);
  stream.read(ID, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if ID <> KDT22DI16_Axis then
      RaiseInfo('kdtree axis error!');

  stream.read(cnt, 8);

  SetLength(KDStoreBuff, cnt);

  i := 0;
  try
    while i < cnt do
      begin
        if stream.read(KDStoreBuff[i].buff[0], SizeOf(TKDT22DI16_Vec)) <> SizeOf(TKDT22DI16_Vec) then
          begin
            Clear;
            Exit;
          end;
        if stream.read(KDStoreBuff[i].Index, 8) <> 8 then
          begin
            Clear;
            Exit;
          end;
        if stream.read(token_L, 4) <> 4 then
          begin
            Clear;
            Exit;
          end;
        if token_L > 0 then
          begin
            SetLength(token_B, token_L);
            if stream.read(token_B[0], token_L) <> token_L then
              begin
                Clear;
                Exit;
              end;
            KDStoreBuff[i].Token.Bytes := token_B;
            SetLength(token_B, 0);
          end
        else
            KDStoreBuff[i].Token := '';
        Inc(i);
      end;
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      Inc(i);
    end;

  if cnt > 0 then
      RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT22DI16.SaveToFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(FileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT22DI16.LoadFromFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT22DI16.PrintNodeTree(const NodePtr: PKDT22DI16_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT22DI16_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.Vec^.Index, Vec(p^.Vec^.buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT22DI16.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d - %d : %s ', [i, KDStoreBuff[i].Index, Vec(KDStoreBuff[i].buff)]);
end;

class function TKDT22DI16.Vec(const s: SystemString): TKDT22DI16_Vec;
var
  t: TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j: NativeInt;
begin
  for i := 0 to KDT22DI16_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            Inc(j);
            if j >= KDT22DI16_Axis then
                Break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT22DI16.Vec(const v: TKDT22DI16_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT22DI16_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT22DI16.Distance(const v1, v2: TKDT22DI16_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT22DI16_Axis - 1 do
      Result := Result + (v2[i] - v1[i]) * (v2[i] - v1[i]);
end;

procedure TKDT22DI16.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT22DI16_Source; const Data: Pointer);
begin
  Source.buff := TestBuff[IndexFor];
  Source.Token := umlIntToStr(IndexFor);
end;

class procedure TKDT22DI16.Test;
var
  TKDT22DI16_Test: TKDT22DI16;
  t: TTimeTick;
  i, j: NativeInt;
  TestResultBuff: TKDT22DI16_DynamicVecBuffer;
  TestResultIndex: TKMIntegerArray;
  KMeanOutIndex: TKMIntegerArray;
  errored: Boolean;
  m64: TMemoryStream64;
  p: PKDT22DI16_Node;
  n: TPascalString;
begin
  errored := False;
  n := PFormat('test %s...', [ClassName]);
  t := GetTimeTick;

  n.Append('...build');
  TKDT22DI16_Test := TKDT22DI16.Create;

  n.Append('...');
  SetLength(TKDT22DI16_Test.TestBuff, 1000);
  for i := 0 to length(TKDT22DI16_Test.TestBuff) - 1 do
    for j := 0 to KDT22DI16_Axis - 1 do
        TKDT22DI16_Test.TestBuff[i][j] := i * KDT22DI16_Axis + j;

{$IFDEF FPC}
  TKDT22DI16_Test.BuildKDTreeM(length(TKDT22DI16_Test.TestBuff), nil, @TKDT22DI16_Test.Test_BuildM);
{$ELSE FPC}
  TKDT22DI16_Test.BuildKDTreeM(length(TKDT22DI16_Test.TestBuff), nil, TKDT22DI16_Test.Test_BuildM);
{$ENDIF FPC}
  { save/load test }
  n.Append('...save/load');
  m64 := TMemoryStream64.CustomCreate(1024 * 1024);
  TKDT22DI16_Test.SaveToStream(m64);
  m64.Position := 0;
  TKDT22DI16_Test.LoadFromStream(m64);
  for i := 0 to length(TKDT22DI16_Test.TestBuff) - 1 do
    begin
      p := TKDT22DI16_Test.Search(TKDT22DI16_Test.TestBuff[i]);
      if p^.Vec^.Index <> i then
          errored := True;
      if not p^.Vec^.Token.Same(umlIntToStr(i)) then
          errored := True;
      if errored then
          Break;
    end;
  DisposeObject(m64);

  if not errored then
    begin
      { parallel search test }
      n.Append('...parallel');
      SetLength(TestResultBuff, length(TKDT22DI16_Test.TestBuff));
      SetLength(TestResultIndex, length(TKDT22DI16_Test.TestBuff));
      TKDT22DI16_Test.Search(TKDT22DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if Distance(TKDT22DI16_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
            errored := True;
    end;

  if not errored then
    begin
      n.Append('...kMean');
      TKDT22DI16_Test.Clear;
      { kMean test }
      TKDT22DI16_Test.BuildKDTreeWithCluster(TKDT22DI16_Test.TestBuff, 10, 1, KMeanOutIndex);
      { parallel search test }
      TKDT22DI16_Test.Search(TKDT22DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if TestResultIndex[i] <> KMeanOutIndex[i] then
            errored := True;
    end;

  SetLength(TKDT22DI16_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT22DI16_Test.Clear;

  n.Append('...');
  if errored then
      n.Append('error!')
  else
      n.Append('passed ok %dms', [GetTimeTick - t]);
  DisposeObject(TKDT22DI16_Test);
  DoStatus(n);
  n := '';
end;

function TKDT23DI16.InternalBuildKdTree(const KDSourceBufferPtr: PKDT23DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT23DI16_Node;
  function SortCompare(const p1, p2: PKDT23DI16_Source; const axis: NativeInt): ShortInt;
  begin
    if p1^.buff[axis] = p2^.buff[axis] then
      begin
        if p1^.Index = p2^.Index then
            Result := 0
        else if p1^.Index < p2^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.buff[axis] < p2^.buff[axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT23DI16_SourceBuffer; L, R: NativeInt; const axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT23DI16_Source;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer^[(L + R) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, axis) < 0 do
            Inc(i);
        while SortCompare(SortBuffer^[j], p, axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, axis);
      L := i;
    until i >= R;
  end;

var
  M: NativeInt;
  axis: NativeInt;
  kdBuffPtr: PKDT23DI16_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      new(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.Vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);
    end
  else
    begin
      axis := Depth mod KDT23DI16_Axis;
      M := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr^[0], 0, PlanCount - 1, axis);

      new(Result);
      Result^.Parent := nil;
      Result^.Vec := kdBuffPtr^[M];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], M, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[M + 1], PlanCount - (M + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT23DI16.GetData(const Index: NativeInt): PKDT23DI16_Source;
begin
  Result := @KDStoreBuff[Index];
end;

constructor TKDT23DI16.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT23DI16.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT23DI16.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT23DI16_Node(KDNodes[i]));
      Inc(i);
    end;

  for i := 0 to length(KDStoreBuff) - 1 do
      KDStoreBuff[i].Token := '';

  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT23DI16.StoreBuffPtr: PKDT23DI16_DyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT23DI16.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT23DI16_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT23DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT23DI16.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT23DI16_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT23DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT23DI16.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT23DI16_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT23DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{ k-means++ clusterization }
procedure TKDT23DI16.BuildKDTreeWithCluster(const inBuff: TKDT23DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  SetLength(Source, length(inBuff), KDT23DI16_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT23DI16_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT23DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT23DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT23DI16.BuildKDTreeWithCluster(const inBuff: TKDT23DI16_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TKMIntegerArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT23DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT23DI16_BuildCall);
var
  TempStoreBuff: TKDT23DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT23DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT23DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT23DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT23DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT23DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT23DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT23DI16_BuildMethod);
var
  TempStoreBuff: TKDT23DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT23DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT23DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT23DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT23DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT23DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT23DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT23DI16_BuildProc);
var
  TempStoreBuff: TKDT23DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT23DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT23DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT23DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT23DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT23DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

function TKDT23DI16.Search(const buff: TKDT23DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT23DI16_Node;

var
  NearestNeighbour: PKDT23DI16_Node;

  function FindParentNode(const buffPtr: PKDT23DI16_Vec; NodePtr: PKDT23DI16_Node): PKDT23DI16_Node;
  var
    Next: PKDT23DI16_Node;
    Depth, axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        axis := Depth mod KDT23DI16_Axis;
        if buffPtr^[axis] > Next^.Vec^.buff[axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT23DI16_Node; const buffPtr: PKDT23DI16_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    Inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := Distance(buffPtr^, NodePtr^.Vec^.buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.Vec^.Index < NearestNeighbour^.Vec^.Index) then
        NearestNeighbour := NodePtr;

    axis := Depth mod KDT23DI16_Axis;
    Dist := NodePtr^.Vec^.buff[axis] - buffPtr^[axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.Vec^.buff[axis] > buffPtr^[axis] then
            ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const buffPtr: PKDT23DI16_Vec; const p1, p2: PKDT23DI16_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := Distance(buffPtr^, p1^.Vec^.buff);
    d2 := Distance(buffPtr^, p2^.Vec^.buff);
    if d1 = d2 then
      begin
        if p1^.Vec^.Index = p2^.Vec^.Index then
            Result := 0
        else if p1^.Vec^.Index < p2^.Vec^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; L, R: NativeInt; const buffPtr: PKDT23DI16_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT23DI16_Node;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer[(L + R) shr 1];
      repeat
        while SortCompare(buffPtr, SortBuffer[i], p) < 0 do
            Inc(i);
        while SortCompare(buffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, buffPtr);
      L := i;
    until i >= R;
  end;

var
  Parent: PKDT23DI16_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := Distance(buff, Parent^.Vec^.buff);

  ScanSubtree(RootNode, @buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT23DI16_Node(NearestNodes[0]);
    end;
end;

function TKDT23DI16.Search(const buff: TKDT23DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT23DI16_Node;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT23DI16.Search(const buff: TKDT23DI16_Vec; var SearchedDistanceMin: Double): PKDT23DI16_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT23DI16.Search(const buff: TKDT23DI16_Vec): PKDT23DI16_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT23DI16.SearchToken(const buff: TKDT23DI16_Vec): TPascalString;
var
  p: PKDT23DI16_Node;
begin
  p := Search(buff);
  if p <> nil then
      Result := p^.Vec^.Token
  else
      Result := '';
end;

procedure TKDT23DI16.Search(const inBuff: TKDT23DI16_DynamicVecBuffer; var OutBuff: TKDT23DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT23DI16_DynamicVecBuffer;
  outBuffPtr: PKDT23DI16_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT23DI16_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outBuffPtr^[pass] := p^.Vec^.buff;
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT23DI16_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outBuffPtr^[pass] := p^.Vec^.buff;
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT23DI16_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.Vec^.buff;
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT23DI16.Search(const inBuff: TKDT23DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT23DI16_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT23DI16_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT23DI16_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT23DI16_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT23DI16.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  ID := KDT23DI16_Axis;

  stream.write(st, 4);
  stream.write(ID, 4);

  stream.write(cnt, 8);

  i := 0;
  while i < cnt do
    begin
      stream.write(KDStoreBuff[i].buff[0], SizeOf(TKDT23DI16_Vec));
      stream.write(KDStoreBuff[i].Index, 8);
      token_B := KDStoreBuff[i].Token.Bytes;
      token_L := length(token_B);
      stream.write(token_L, 4);
      if token_L > 0 then
        begin
          stream.write(token_B[0], token_L);
          SetLength(token_B, 0);
        end;
      Inc(i);
    end;
end;

procedure TKDT23DI16.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  Clear;

  stream.read(st, 4);
  stream.read(ID, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if ID <> KDT23DI16_Axis then
      RaiseInfo('kdtree axis error!');

  stream.read(cnt, 8);

  SetLength(KDStoreBuff, cnt);

  i := 0;
  try
    while i < cnt do
      begin
        if stream.read(KDStoreBuff[i].buff[0], SizeOf(TKDT23DI16_Vec)) <> SizeOf(TKDT23DI16_Vec) then
          begin
            Clear;
            Exit;
          end;
        if stream.read(KDStoreBuff[i].Index, 8) <> 8 then
          begin
            Clear;
            Exit;
          end;
        if stream.read(token_L, 4) <> 4 then
          begin
            Clear;
            Exit;
          end;
        if token_L > 0 then
          begin
            SetLength(token_B, token_L);
            if stream.read(token_B[0], token_L) <> token_L then
              begin
                Clear;
                Exit;
              end;
            KDStoreBuff[i].Token.Bytes := token_B;
            SetLength(token_B, 0);
          end
        else
            KDStoreBuff[i].Token := '';
        Inc(i);
      end;
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      Inc(i);
    end;

  if cnt > 0 then
      RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT23DI16.SaveToFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(FileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT23DI16.LoadFromFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT23DI16.PrintNodeTree(const NodePtr: PKDT23DI16_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT23DI16_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.Vec^.Index, Vec(p^.Vec^.buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT23DI16.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d - %d : %s ', [i, KDStoreBuff[i].Index, Vec(KDStoreBuff[i].buff)]);
end;

class function TKDT23DI16.Vec(const s: SystemString): TKDT23DI16_Vec;
var
  t: TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j: NativeInt;
begin
  for i := 0 to KDT23DI16_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            Inc(j);
            if j >= KDT23DI16_Axis then
                Break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT23DI16.Vec(const v: TKDT23DI16_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT23DI16_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT23DI16.Distance(const v1, v2: TKDT23DI16_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT23DI16_Axis - 1 do
      Result := Result + (v2[i] - v1[i]) * (v2[i] - v1[i]);
end;

procedure TKDT23DI16.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT23DI16_Source; const Data: Pointer);
begin
  Source.buff := TestBuff[IndexFor];
  Source.Token := umlIntToStr(IndexFor);
end;

class procedure TKDT23DI16.Test;
var
  TKDT23DI16_Test: TKDT23DI16;
  t: TTimeTick;
  i, j: NativeInt;
  TestResultBuff: TKDT23DI16_DynamicVecBuffer;
  TestResultIndex: TKMIntegerArray;
  KMeanOutIndex: TKMIntegerArray;
  errored: Boolean;
  m64: TMemoryStream64;
  p: PKDT23DI16_Node;
  n: TPascalString;
begin
  errored := False;
  n := PFormat('test %s...', [ClassName]);
  t := GetTimeTick;

  n.Append('...build');
  TKDT23DI16_Test := TKDT23DI16.Create;

  n.Append('...');
  SetLength(TKDT23DI16_Test.TestBuff, 1000);
  for i := 0 to length(TKDT23DI16_Test.TestBuff) - 1 do
    for j := 0 to KDT23DI16_Axis - 1 do
        TKDT23DI16_Test.TestBuff[i][j] := i * KDT23DI16_Axis + j;

{$IFDEF FPC}
  TKDT23DI16_Test.BuildKDTreeM(length(TKDT23DI16_Test.TestBuff), nil, @TKDT23DI16_Test.Test_BuildM);
{$ELSE FPC}
  TKDT23DI16_Test.BuildKDTreeM(length(TKDT23DI16_Test.TestBuff), nil, TKDT23DI16_Test.Test_BuildM);
{$ENDIF FPC}
  { save/load test }
  n.Append('...save/load');
  m64 := TMemoryStream64.CustomCreate(1024 * 1024);
  TKDT23DI16_Test.SaveToStream(m64);
  m64.Position := 0;
  TKDT23DI16_Test.LoadFromStream(m64);
  for i := 0 to length(TKDT23DI16_Test.TestBuff) - 1 do
    begin
      p := TKDT23DI16_Test.Search(TKDT23DI16_Test.TestBuff[i]);
      if p^.Vec^.Index <> i then
          errored := True;
      if not p^.Vec^.Token.Same(umlIntToStr(i)) then
          errored := True;
      if errored then
          Break;
    end;
  DisposeObject(m64);

  if not errored then
    begin
      { parallel search test }
      n.Append('...parallel');
      SetLength(TestResultBuff, length(TKDT23DI16_Test.TestBuff));
      SetLength(TestResultIndex, length(TKDT23DI16_Test.TestBuff));
      TKDT23DI16_Test.Search(TKDT23DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if Distance(TKDT23DI16_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
            errored := True;
    end;

  if not errored then
    begin
      n.Append('...kMean');
      TKDT23DI16_Test.Clear;
      { kMean test }
      TKDT23DI16_Test.BuildKDTreeWithCluster(TKDT23DI16_Test.TestBuff, 10, 1, KMeanOutIndex);
      { parallel search test }
      TKDT23DI16_Test.Search(TKDT23DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if TestResultIndex[i] <> KMeanOutIndex[i] then
            errored := True;
    end;

  SetLength(TKDT23DI16_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT23DI16_Test.Clear;

  n.Append('...');
  if errored then
      n.Append('error!')
  else
      n.Append('passed ok %dms', [GetTimeTick - t]);
  DisposeObject(TKDT23DI16_Test);
  DoStatus(n);
  n := '';
end;

function TKDT24DI16.InternalBuildKdTree(const KDSourceBufferPtr: PKDT24DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT24DI16_Node;
  function SortCompare(const p1, p2: PKDT24DI16_Source; const axis: NativeInt): ShortInt;
  begin
    if p1^.buff[axis] = p2^.buff[axis] then
      begin
        if p1^.Index = p2^.Index then
            Result := 0
        else if p1^.Index < p2^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.buff[axis] < p2^.buff[axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT24DI16_SourceBuffer; L, R: NativeInt; const axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT24DI16_Source;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer^[(L + R) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, axis) < 0 do
            Inc(i);
        while SortCompare(SortBuffer^[j], p, axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, axis);
      L := i;
    until i >= R;
  end;

var
  M: NativeInt;
  axis: NativeInt;
  kdBuffPtr: PKDT24DI16_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      new(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.Vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);
    end
  else
    begin
      axis := Depth mod KDT24DI16_Axis;
      M := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr^[0], 0, PlanCount - 1, axis);

      new(Result);
      Result^.Parent := nil;
      Result^.Vec := kdBuffPtr^[M];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], M, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[M + 1], PlanCount - (M + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT24DI16.GetData(const Index: NativeInt): PKDT24DI16_Source;
begin
  Result := @KDStoreBuff[Index];
end;

constructor TKDT24DI16.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT24DI16.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT24DI16.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT24DI16_Node(KDNodes[i]));
      Inc(i);
    end;

  for i := 0 to length(KDStoreBuff) - 1 do
      KDStoreBuff[i].Token := '';

  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT24DI16.StoreBuffPtr: PKDT24DI16_DyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT24DI16.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT24DI16_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT24DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT24DI16.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT24DI16_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT24DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT24DI16.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT24DI16_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT24DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{ k-means++ clusterization }
procedure TKDT24DI16.BuildKDTreeWithCluster(const inBuff: TKDT24DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  SetLength(Source, length(inBuff), KDT24DI16_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT24DI16_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT24DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT24DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT24DI16.BuildKDTreeWithCluster(const inBuff: TKDT24DI16_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TKMIntegerArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT24DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT24DI16_BuildCall);
var
  TempStoreBuff: TKDT24DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT24DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT24DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT24DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT24DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT24DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT24DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT24DI16_BuildMethod);
var
  TempStoreBuff: TKDT24DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT24DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT24DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT24DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT24DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT24DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT24DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT24DI16_BuildProc);
var
  TempStoreBuff: TKDT24DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT24DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT24DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT24DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT24DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT24DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

function TKDT24DI16.Search(const buff: TKDT24DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT24DI16_Node;

var
  NearestNeighbour: PKDT24DI16_Node;

  function FindParentNode(const buffPtr: PKDT24DI16_Vec; NodePtr: PKDT24DI16_Node): PKDT24DI16_Node;
  var
    Next: PKDT24DI16_Node;
    Depth, axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        axis := Depth mod KDT24DI16_Axis;
        if buffPtr^[axis] > Next^.Vec^.buff[axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT24DI16_Node; const buffPtr: PKDT24DI16_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    Inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := Distance(buffPtr^, NodePtr^.Vec^.buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.Vec^.Index < NearestNeighbour^.Vec^.Index) then
        NearestNeighbour := NodePtr;

    axis := Depth mod KDT24DI16_Axis;
    Dist := NodePtr^.Vec^.buff[axis] - buffPtr^[axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.Vec^.buff[axis] > buffPtr^[axis] then
            ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const buffPtr: PKDT24DI16_Vec; const p1, p2: PKDT24DI16_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := Distance(buffPtr^, p1^.Vec^.buff);
    d2 := Distance(buffPtr^, p2^.Vec^.buff);
    if d1 = d2 then
      begin
        if p1^.Vec^.Index = p2^.Vec^.Index then
            Result := 0
        else if p1^.Vec^.Index < p2^.Vec^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; L, R: NativeInt; const buffPtr: PKDT24DI16_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT24DI16_Node;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer[(L + R) shr 1];
      repeat
        while SortCompare(buffPtr, SortBuffer[i], p) < 0 do
            Inc(i);
        while SortCompare(buffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, buffPtr);
      L := i;
    until i >= R;
  end;

var
  Parent: PKDT24DI16_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := Distance(buff, Parent^.Vec^.buff);

  ScanSubtree(RootNode, @buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT24DI16_Node(NearestNodes[0]);
    end;
end;

function TKDT24DI16.Search(const buff: TKDT24DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT24DI16_Node;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT24DI16.Search(const buff: TKDT24DI16_Vec; var SearchedDistanceMin: Double): PKDT24DI16_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT24DI16.Search(const buff: TKDT24DI16_Vec): PKDT24DI16_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT24DI16.SearchToken(const buff: TKDT24DI16_Vec): TPascalString;
var
  p: PKDT24DI16_Node;
begin
  p := Search(buff);
  if p <> nil then
      Result := p^.Vec^.Token
  else
      Result := '';
end;

procedure TKDT24DI16.Search(const inBuff: TKDT24DI16_DynamicVecBuffer; var OutBuff: TKDT24DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT24DI16_DynamicVecBuffer;
  outBuffPtr: PKDT24DI16_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT24DI16_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outBuffPtr^[pass] := p^.Vec^.buff;
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT24DI16_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outBuffPtr^[pass] := p^.Vec^.buff;
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT24DI16_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.Vec^.buff;
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT24DI16.Search(const inBuff: TKDT24DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT24DI16_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT24DI16_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT24DI16_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT24DI16_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT24DI16.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  ID := KDT24DI16_Axis;

  stream.write(st, 4);
  stream.write(ID, 4);

  stream.write(cnt, 8);

  i := 0;
  while i < cnt do
    begin
      stream.write(KDStoreBuff[i].buff[0], SizeOf(TKDT24DI16_Vec));
      stream.write(KDStoreBuff[i].Index, 8);
      token_B := KDStoreBuff[i].Token.Bytes;
      token_L := length(token_B);
      stream.write(token_L, 4);
      if token_L > 0 then
        begin
          stream.write(token_B[0], token_L);
          SetLength(token_B, 0);
        end;
      Inc(i);
    end;
end;

procedure TKDT24DI16.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  Clear;

  stream.read(st, 4);
  stream.read(ID, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if ID <> KDT24DI16_Axis then
      RaiseInfo('kdtree axis error!');

  stream.read(cnt, 8);

  SetLength(KDStoreBuff, cnt);

  i := 0;
  try
    while i < cnt do
      begin
        if stream.read(KDStoreBuff[i].buff[0], SizeOf(TKDT24DI16_Vec)) <> SizeOf(TKDT24DI16_Vec) then
          begin
            Clear;
            Exit;
          end;
        if stream.read(KDStoreBuff[i].Index, 8) <> 8 then
          begin
            Clear;
            Exit;
          end;
        if stream.read(token_L, 4) <> 4 then
          begin
            Clear;
            Exit;
          end;
        if token_L > 0 then
          begin
            SetLength(token_B, token_L);
            if stream.read(token_B[0], token_L) <> token_L then
              begin
                Clear;
                Exit;
              end;
            KDStoreBuff[i].Token.Bytes := token_B;
            SetLength(token_B, 0);
          end
        else
            KDStoreBuff[i].Token := '';
        Inc(i);
      end;
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      Inc(i);
    end;

  if cnt > 0 then
      RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT24DI16.SaveToFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(FileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT24DI16.LoadFromFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT24DI16.PrintNodeTree(const NodePtr: PKDT24DI16_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT24DI16_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.Vec^.Index, Vec(p^.Vec^.buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT24DI16.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d - %d : %s ', [i, KDStoreBuff[i].Index, Vec(KDStoreBuff[i].buff)]);
end;

class function TKDT24DI16.Vec(const s: SystemString): TKDT24DI16_Vec;
var
  t: TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j: NativeInt;
begin
  for i := 0 to KDT24DI16_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            Inc(j);
            if j >= KDT24DI16_Axis then
                Break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT24DI16.Vec(const v: TKDT24DI16_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT24DI16_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT24DI16.Distance(const v1, v2: TKDT24DI16_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT24DI16_Axis - 1 do
      Result := Result + (v2[i] - v1[i]) * (v2[i] - v1[i]);
end;

procedure TKDT24DI16.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT24DI16_Source; const Data: Pointer);
begin
  Source.buff := TestBuff[IndexFor];
  Source.Token := umlIntToStr(IndexFor);
end;

class procedure TKDT24DI16.Test;
var
  TKDT24DI16_Test: TKDT24DI16;
  t: TTimeTick;
  i, j: NativeInt;
  TestResultBuff: TKDT24DI16_DynamicVecBuffer;
  TestResultIndex: TKMIntegerArray;
  KMeanOutIndex: TKMIntegerArray;
  errored: Boolean;
  m64: TMemoryStream64;
  p: PKDT24DI16_Node;
  n: TPascalString;
begin
  errored := False;
  n := PFormat('test %s...', [ClassName]);
  t := GetTimeTick;

  n.Append('...build');
  TKDT24DI16_Test := TKDT24DI16.Create;

  n.Append('...');
  SetLength(TKDT24DI16_Test.TestBuff, 1000);
  for i := 0 to length(TKDT24DI16_Test.TestBuff) - 1 do
    for j := 0 to KDT24DI16_Axis - 1 do
        TKDT24DI16_Test.TestBuff[i][j] := i * KDT24DI16_Axis + j;

{$IFDEF FPC}
  TKDT24DI16_Test.BuildKDTreeM(length(TKDT24DI16_Test.TestBuff), nil, @TKDT24DI16_Test.Test_BuildM);
{$ELSE FPC}
  TKDT24DI16_Test.BuildKDTreeM(length(TKDT24DI16_Test.TestBuff), nil, TKDT24DI16_Test.Test_BuildM);
{$ENDIF FPC}
  { save/load test }
  n.Append('...save/load');
  m64 := TMemoryStream64.CustomCreate(1024 * 1024);
  TKDT24DI16_Test.SaveToStream(m64);
  m64.Position := 0;
  TKDT24DI16_Test.LoadFromStream(m64);
  for i := 0 to length(TKDT24DI16_Test.TestBuff) - 1 do
    begin
      p := TKDT24DI16_Test.Search(TKDT24DI16_Test.TestBuff[i]);
      if p^.Vec^.Index <> i then
          errored := True;
      if not p^.Vec^.Token.Same(umlIntToStr(i)) then
          errored := True;
      if errored then
          Break;
    end;
  DisposeObject(m64);

  if not errored then
    begin
      { parallel search test }
      n.Append('...parallel');
      SetLength(TestResultBuff, length(TKDT24DI16_Test.TestBuff));
      SetLength(TestResultIndex, length(TKDT24DI16_Test.TestBuff));
      TKDT24DI16_Test.Search(TKDT24DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if Distance(TKDT24DI16_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
            errored := True;
    end;

  if not errored then
    begin
      n.Append('...kMean');
      TKDT24DI16_Test.Clear;
      { kMean test }
      TKDT24DI16_Test.BuildKDTreeWithCluster(TKDT24DI16_Test.TestBuff, 10, 1, KMeanOutIndex);
      { parallel search test }
      TKDT24DI16_Test.Search(TKDT24DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if TestResultIndex[i] <> KMeanOutIndex[i] then
            errored := True;
    end;

  SetLength(TKDT24DI16_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT24DI16_Test.Clear;

  n.Append('...');
  if errored then
      n.Append('error!')
  else
      n.Append('passed ok %dms', [GetTimeTick - t]);
  DisposeObject(TKDT24DI16_Test);
  DoStatus(n);
  n := '';
end;

function TKDT48DI16.InternalBuildKdTree(const KDSourceBufferPtr: PKDT48DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT48DI16_Node;
  function SortCompare(const p1, p2: PKDT48DI16_Source; const axis: NativeInt): ShortInt;
  begin
    if p1^.buff[axis] = p2^.buff[axis] then
      begin
        if p1^.Index = p2^.Index then
            Result := 0
        else if p1^.Index < p2^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.buff[axis] < p2^.buff[axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT48DI16_SourceBuffer; L, R: NativeInt; const axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT48DI16_Source;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer^[(L + R) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, axis) < 0 do
            Inc(i);
        while SortCompare(SortBuffer^[j], p, axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, axis);
      L := i;
    until i >= R;
  end;

var
  M: NativeInt;
  axis: NativeInt;
  kdBuffPtr: PKDT48DI16_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      new(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.Vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);
    end
  else
    begin
      axis := Depth mod KDT48DI16_Axis;
      M := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr^[0], 0, PlanCount - 1, axis);

      new(Result);
      Result^.Parent := nil;
      Result^.Vec := kdBuffPtr^[M];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], M, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[M + 1], PlanCount - (M + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT48DI16.GetData(const Index: NativeInt): PKDT48DI16_Source;
begin
  Result := @KDStoreBuff[Index];
end;

constructor TKDT48DI16.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT48DI16.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT48DI16.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT48DI16_Node(KDNodes[i]));
      Inc(i);
    end;

  for i := 0 to length(KDStoreBuff) - 1 do
      KDStoreBuff[i].Token := '';

  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT48DI16.StoreBuffPtr: PKDT48DI16_DyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT48DI16.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT48DI16_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT48DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT48DI16.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT48DI16_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT48DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT48DI16.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT48DI16_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT48DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{ k-means++ clusterization }
procedure TKDT48DI16.BuildKDTreeWithCluster(const inBuff: TKDT48DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  SetLength(Source, length(inBuff), KDT48DI16_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT48DI16_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT48DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT48DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT48DI16.BuildKDTreeWithCluster(const inBuff: TKDT48DI16_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TKMIntegerArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT48DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT48DI16_BuildCall);
var
  TempStoreBuff: TKDT48DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT48DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT48DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT48DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT48DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT48DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT48DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT48DI16_BuildMethod);
var
  TempStoreBuff: TKDT48DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT48DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT48DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT48DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT48DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT48DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT48DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT48DI16_BuildProc);
var
  TempStoreBuff: TKDT48DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT48DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT48DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT48DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT48DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT48DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

function TKDT48DI16.Search(const buff: TKDT48DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT48DI16_Node;

var
  NearestNeighbour: PKDT48DI16_Node;

  function FindParentNode(const buffPtr: PKDT48DI16_Vec; NodePtr: PKDT48DI16_Node): PKDT48DI16_Node;
  var
    Next: PKDT48DI16_Node;
    Depth, axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        axis := Depth mod KDT48DI16_Axis;
        if buffPtr^[axis] > Next^.Vec^.buff[axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT48DI16_Node; const buffPtr: PKDT48DI16_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    Inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := Distance(buffPtr^, NodePtr^.Vec^.buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.Vec^.Index < NearestNeighbour^.Vec^.Index) then
        NearestNeighbour := NodePtr;

    axis := Depth mod KDT48DI16_Axis;
    Dist := NodePtr^.Vec^.buff[axis] - buffPtr^[axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.Vec^.buff[axis] > buffPtr^[axis] then
            ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const buffPtr: PKDT48DI16_Vec; const p1, p2: PKDT48DI16_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := Distance(buffPtr^, p1^.Vec^.buff);
    d2 := Distance(buffPtr^, p2^.Vec^.buff);
    if d1 = d2 then
      begin
        if p1^.Vec^.Index = p2^.Vec^.Index then
            Result := 0
        else if p1^.Vec^.Index < p2^.Vec^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; L, R: NativeInt; const buffPtr: PKDT48DI16_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT48DI16_Node;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer[(L + R) shr 1];
      repeat
        while SortCompare(buffPtr, SortBuffer[i], p) < 0 do
            Inc(i);
        while SortCompare(buffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, buffPtr);
      L := i;
    until i >= R;
  end;

var
  Parent: PKDT48DI16_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := Distance(buff, Parent^.Vec^.buff);

  ScanSubtree(RootNode, @buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT48DI16_Node(NearestNodes[0]);
    end;
end;

function TKDT48DI16.Search(const buff: TKDT48DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT48DI16_Node;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT48DI16.Search(const buff: TKDT48DI16_Vec; var SearchedDistanceMin: Double): PKDT48DI16_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT48DI16.Search(const buff: TKDT48DI16_Vec): PKDT48DI16_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT48DI16.SearchToken(const buff: TKDT48DI16_Vec): TPascalString;
var
  p: PKDT48DI16_Node;
begin
  p := Search(buff);
  if p <> nil then
      Result := p^.Vec^.Token
  else
      Result := '';
end;

procedure TKDT48DI16.Search(const inBuff: TKDT48DI16_DynamicVecBuffer; var OutBuff: TKDT48DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT48DI16_DynamicVecBuffer;
  outBuffPtr: PKDT48DI16_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT48DI16_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outBuffPtr^[pass] := p^.Vec^.buff;
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT48DI16_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outBuffPtr^[pass] := p^.Vec^.buff;
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT48DI16_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.Vec^.buff;
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT48DI16.Search(const inBuff: TKDT48DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT48DI16_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT48DI16_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT48DI16_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT48DI16_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT48DI16.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  ID := KDT48DI16_Axis;

  stream.write(st, 4);
  stream.write(ID, 4);

  stream.write(cnt, 8);

  i := 0;
  while i < cnt do
    begin
      stream.write(KDStoreBuff[i].buff[0], SizeOf(TKDT48DI16_Vec));
      stream.write(KDStoreBuff[i].Index, 8);
      token_B := KDStoreBuff[i].Token.Bytes;
      token_L := length(token_B);
      stream.write(token_L, 4);
      if token_L > 0 then
        begin
          stream.write(token_B[0], token_L);
          SetLength(token_B, 0);
        end;
      Inc(i);
    end;
end;

procedure TKDT48DI16.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  Clear;

  stream.read(st, 4);
  stream.read(ID, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if ID <> KDT48DI16_Axis then
      RaiseInfo('kdtree axis error!');

  stream.read(cnt, 8);

  SetLength(KDStoreBuff, cnt);

  i := 0;
  try
    while i < cnt do
      begin
        if stream.read(KDStoreBuff[i].buff[0], SizeOf(TKDT48DI16_Vec)) <> SizeOf(TKDT48DI16_Vec) then
          begin
            Clear;
            Exit;
          end;
        if stream.read(KDStoreBuff[i].Index, 8) <> 8 then
          begin
            Clear;
            Exit;
          end;
        if stream.read(token_L, 4) <> 4 then
          begin
            Clear;
            Exit;
          end;
        if token_L > 0 then
          begin
            SetLength(token_B, token_L);
            if stream.read(token_B[0], token_L) <> token_L then
              begin
                Clear;
                Exit;
              end;
            KDStoreBuff[i].Token.Bytes := token_B;
            SetLength(token_B, 0);
          end
        else
            KDStoreBuff[i].Token := '';
        Inc(i);
      end;
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      Inc(i);
    end;

  if cnt > 0 then
      RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT48DI16.SaveToFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(FileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT48DI16.LoadFromFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT48DI16.PrintNodeTree(const NodePtr: PKDT48DI16_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT48DI16_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.Vec^.Index, Vec(p^.Vec^.buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT48DI16.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d - %d : %s ', [i, KDStoreBuff[i].Index, Vec(KDStoreBuff[i].buff)]);
end;

class function TKDT48DI16.Vec(const s: SystemString): TKDT48DI16_Vec;
var
  t: TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j: NativeInt;
begin
  for i := 0 to KDT48DI16_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            Inc(j);
            if j >= KDT48DI16_Axis then
                Break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT48DI16.Vec(const v: TKDT48DI16_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT48DI16_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT48DI16.Distance(const v1, v2: TKDT48DI16_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT48DI16_Axis - 1 do
      Result := Result + (v2[i] - v1[i]) * (v2[i] - v1[i]);
end;

procedure TKDT48DI16.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT48DI16_Source; const Data: Pointer);
begin
  Source.buff := TestBuff[IndexFor];
  Source.Token := umlIntToStr(IndexFor);
end;

class procedure TKDT48DI16.Test;
var
  TKDT48DI16_Test: TKDT48DI16;
  t: TTimeTick;
  i, j: NativeInt;
  TestResultBuff: TKDT48DI16_DynamicVecBuffer;
  TestResultIndex: TKMIntegerArray;
  KMeanOutIndex: TKMIntegerArray;
  errored: Boolean;
  m64: TMemoryStream64;
  p: PKDT48DI16_Node;
  n: TPascalString;
begin
  errored := False;
  n := PFormat('test %s...', [ClassName]);
  t := GetTimeTick;

  n.Append('...build');
  TKDT48DI16_Test := TKDT48DI16.Create;

  n.Append('...');
  SetLength(TKDT48DI16_Test.TestBuff, 1000);
  for i := 0 to length(TKDT48DI16_Test.TestBuff) - 1 do
    for j := 0 to KDT48DI16_Axis - 1 do
        TKDT48DI16_Test.TestBuff[i][j] := i * KDT48DI16_Axis + j;

{$IFDEF FPC}
  TKDT48DI16_Test.BuildKDTreeM(length(TKDT48DI16_Test.TestBuff), nil, @TKDT48DI16_Test.Test_BuildM);
{$ELSE FPC}
  TKDT48DI16_Test.BuildKDTreeM(length(TKDT48DI16_Test.TestBuff), nil, TKDT48DI16_Test.Test_BuildM);
{$ENDIF FPC}
  { save/load test }
  n.Append('...save/load');
  m64 := TMemoryStream64.CustomCreate(1024 * 1024);
  TKDT48DI16_Test.SaveToStream(m64);
  m64.Position := 0;
  TKDT48DI16_Test.LoadFromStream(m64);
  for i := 0 to length(TKDT48DI16_Test.TestBuff) - 1 do
    begin
      p := TKDT48DI16_Test.Search(TKDT48DI16_Test.TestBuff[i]);
      if p^.Vec^.Index <> i then
          errored := True;
      if not p^.Vec^.Token.Same(umlIntToStr(i)) then
          errored := True;
      if errored then
          Break;
    end;
  DisposeObject(m64);

  if not errored then
    begin
      { parallel search test }
      n.Append('...parallel');
      SetLength(TestResultBuff, length(TKDT48DI16_Test.TestBuff));
      SetLength(TestResultIndex, length(TKDT48DI16_Test.TestBuff));
      TKDT48DI16_Test.Search(TKDT48DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if Distance(TKDT48DI16_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
            errored := True;
    end;

  if not errored then
    begin
      n.Append('...kMean');
      TKDT48DI16_Test.Clear;
      { kMean test }
      TKDT48DI16_Test.BuildKDTreeWithCluster(TKDT48DI16_Test.TestBuff, 10, 1, KMeanOutIndex);
      { parallel search test }
      TKDT48DI16_Test.Search(TKDT48DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if TestResultIndex[i] <> KMeanOutIndex[i] then
            errored := True;
    end;

  SetLength(TKDT48DI16_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT48DI16_Test.Clear;

  n.Append('...');
  if errored then
      n.Append('error!')
  else
      n.Append('passed ok %dms', [GetTimeTick - t]);
  DisposeObject(TKDT48DI16_Test);
  DoStatus(n);
  n := '';
end;

function TKDT52DI16.InternalBuildKdTree(const KDSourceBufferPtr: PKDT52DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT52DI16_Node;
  function SortCompare(const p1, p2: PKDT52DI16_Source; const axis: NativeInt): ShortInt;
  begin
    if p1^.buff[axis] = p2^.buff[axis] then
      begin
        if p1^.Index = p2^.Index then
            Result := 0
        else if p1^.Index < p2^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.buff[axis] < p2^.buff[axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT52DI16_SourceBuffer; L, R: NativeInt; const axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT52DI16_Source;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer^[(L + R) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, axis) < 0 do
            Inc(i);
        while SortCompare(SortBuffer^[j], p, axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, axis);
      L := i;
    until i >= R;
  end;

var
  M: NativeInt;
  axis: NativeInt;
  kdBuffPtr: PKDT52DI16_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      new(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.Vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);
    end
  else
    begin
      axis := Depth mod KDT52DI16_Axis;
      M := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr^[0], 0, PlanCount - 1, axis);

      new(Result);
      Result^.Parent := nil;
      Result^.Vec := kdBuffPtr^[M];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], M, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[M + 1], PlanCount - (M + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT52DI16.GetData(const Index: NativeInt): PKDT52DI16_Source;
begin
  Result := @KDStoreBuff[Index];
end;

constructor TKDT52DI16.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT52DI16.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT52DI16.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT52DI16_Node(KDNodes[i]));
      Inc(i);
    end;

  for i := 0 to length(KDStoreBuff) - 1 do
      KDStoreBuff[i].Token := '';

  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT52DI16.StoreBuffPtr: PKDT52DI16_DyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT52DI16.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT52DI16_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT52DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT52DI16.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT52DI16_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT52DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT52DI16.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT52DI16_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT52DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{ k-means++ clusterization }
procedure TKDT52DI16.BuildKDTreeWithCluster(const inBuff: TKDT52DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  SetLength(Source, length(inBuff), KDT52DI16_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT52DI16_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT52DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT52DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT52DI16.BuildKDTreeWithCluster(const inBuff: TKDT52DI16_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TKMIntegerArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT52DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT52DI16_BuildCall);
var
  TempStoreBuff: TKDT52DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT52DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT52DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT52DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT52DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT52DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT52DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT52DI16_BuildMethod);
var
  TempStoreBuff: TKDT52DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT52DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT52DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT52DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT52DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT52DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT52DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT52DI16_BuildProc);
var
  TempStoreBuff: TKDT52DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT52DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT52DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT52DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT52DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT52DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

function TKDT52DI16.Search(const buff: TKDT52DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT52DI16_Node;

var
  NearestNeighbour: PKDT52DI16_Node;

  function FindParentNode(const buffPtr: PKDT52DI16_Vec; NodePtr: PKDT52DI16_Node): PKDT52DI16_Node;
  var
    Next: PKDT52DI16_Node;
    Depth, axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        axis := Depth mod KDT52DI16_Axis;
        if buffPtr^[axis] > Next^.Vec^.buff[axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT52DI16_Node; const buffPtr: PKDT52DI16_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    Inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := Distance(buffPtr^, NodePtr^.Vec^.buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.Vec^.Index < NearestNeighbour^.Vec^.Index) then
        NearestNeighbour := NodePtr;

    axis := Depth mod KDT52DI16_Axis;
    Dist := NodePtr^.Vec^.buff[axis] - buffPtr^[axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.Vec^.buff[axis] > buffPtr^[axis] then
            ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const buffPtr: PKDT52DI16_Vec; const p1, p2: PKDT52DI16_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := Distance(buffPtr^, p1^.Vec^.buff);
    d2 := Distance(buffPtr^, p2^.Vec^.buff);
    if d1 = d2 then
      begin
        if p1^.Vec^.Index = p2^.Vec^.Index then
            Result := 0
        else if p1^.Vec^.Index < p2^.Vec^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; L, R: NativeInt; const buffPtr: PKDT52DI16_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT52DI16_Node;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer[(L + R) shr 1];
      repeat
        while SortCompare(buffPtr, SortBuffer[i], p) < 0 do
            Inc(i);
        while SortCompare(buffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, buffPtr);
      L := i;
    until i >= R;
  end;

var
  Parent: PKDT52DI16_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := Distance(buff, Parent^.Vec^.buff);

  ScanSubtree(RootNode, @buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT52DI16_Node(NearestNodes[0]);
    end;
end;

function TKDT52DI16.Search(const buff: TKDT52DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT52DI16_Node;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT52DI16.Search(const buff: TKDT52DI16_Vec; var SearchedDistanceMin: Double): PKDT52DI16_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT52DI16.Search(const buff: TKDT52DI16_Vec): PKDT52DI16_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT52DI16.SearchToken(const buff: TKDT52DI16_Vec): TPascalString;
var
  p: PKDT52DI16_Node;
begin
  p := Search(buff);
  if p <> nil then
      Result := p^.Vec^.Token
  else
      Result := '';
end;

procedure TKDT52DI16.Search(const inBuff: TKDT52DI16_DynamicVecBuffer; var OutBuff: TKDT52DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT52DI16_DynamicVecBuffer;
  outBuffPtr: PKDT52DI16_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT52DI16_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outBuffPtr^[pass] := p^.Vec^.buff;
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT52DI16_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outBuffPtr^[pass] := p^.Vec^.buff;
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT52DI16_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.Vec^.buff;
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT52DI16.Search(const inBuff: TKDT52DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT52DI16_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT52DI16_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT52DI16_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT52DI16_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT52DI16.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  ID := KDT52DI16_Axis;

  stream.write(st, 4);
  stream.write(ID, 4);

  stream.write(cnt, 8);

  i := 0;
  while i < cnt do
    begin
      stream.write(KDStoreBuff[i].buff[0], SizeOf(TKDT52DI16_Vec));
      stream.write(KDStoreBuff[i].Index, 8);
      token_B := KDStoreBuff[i].Token.Bytes;
      token_L := length(token_B);
      stream.write(token_L, 4);
      if token_L > 0 then
        begin
          stream.write(token_B[0], token_L);
          SetLength(token_B, 0);
        end;
      Inc(i);
    end;
end;

procedure TKDT52DI16.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  Clear;

  stream.read(st, 4);
  stream.read(ID, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if ID <> KDT52DI16_Axis then
      RaiseInfo('kdtree axis error!');

  stream.read(cnt, 8);

  SetLength(KDStoreBuff, cnt);

  i := 0;
  try
    while i < cnt do
      begin
        if stream.read(KDStoreBuff[i].buff[0], SizeOf(TKDT52DI16_Vec)) <> SizeOf(TKDT52DI16_Vec) then
          begin
            Clear;
            Exit;
          end;
        if stream.read(KDStoreBuff[i].Index, 8) <> 8 then
          begin
            Clear;
            Exit;
          end;
        if stream.read(token_L, 4) <> 4 then
          begin
            Clear;
            Exit;
          end;
        if token_L > 0 then
          begin
            SetLength(token_B, token_L);
            if stream.read(token_B[0], token_L) <> token_L then
              begin
                Clear;
                Exit;
              end;
            KDStoreBuff[i].Token.Bytes := token_B;
            SetLength(token_B, 0);
          end
        else
            KDStoreBuff[i].Token := '';
        Inc(i);
      end;
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      Inc(i);
    end;

  if cnt > 0 then
      RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT52DI16.SaveToFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(FileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT52DI16.LoadFromFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT52DI16.PrintNodeTree(const NodePtr: PKDT52DI16_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT52DI16_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.Vec^.Index, Vec(p^.Vec^.buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT52DI16.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d - %d : %s ', [i, KDStoreBuff[i].Index, Vec(KDStoreBuff[i].buff)]);
end;

class function TKDT52DI16.Vec(const s: SystemString): TKDT52DI16_Vec;
var
  t: TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j: NativeInt;
begin
  for i := 0 to KDT52DI16_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            Inc(j);
            if j >= KDT52DI16_Axis then
                Break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT52DI16.Vec(const v: TKDT52DI16_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT52DI16_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT52DI16.Distance(const v1, v2: TKDT52DI16_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT52DI16_Axis - 1 do
      Result := Result + (v2[i] - v1[i]) * (v2[i] - v1[i]);
end;

procedure TKDT52DI16.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT52DI16_Source; const Data: Pointer);
begin
  Source.buff := TestBuff[IndexFor];
  Source.Token := umlIntToStr(IndexFor);
end;

class procedure TKDT52DI16.Test;
var
  TKDT52DI16_Test: TKDT52DI16;
  t: TTimeTick;
  i, j: NativeInt;
  TestResultBuff: TKDT52DI16_DynamicVecBuffer;
  TestResultIndex: TKMIntegerArray;
  KMeanOutIndex: TKMIntegerArray;
  errored: Boolean;
  m64: TMemoryStream64;
  p: PKDT52DI16_Node;
  n: TPascalString;
begin
  errored := False;
  n := PFormat('test %s...', [ClassName]);
  t := GetTimeTick;

  n.Append('...build');
  TKDT52DI16_Test := TKDT52DI16.Create;

  n.Append('...');
  SetLength(TKDT52DI16_Test.TestBuff, 1000);
  for i := 0 to length(TKDT52DI16_Test.TestBuff) - 1 do
    for j := 0 to KDT52DI16_Axis - 1 do
        TKDT52DI16_Test.TestBuff[i][j] := i * KDT52DI16_Axis + j;

{$IFDEF FPC}
  TKDT52DI16_Test.BuildKDTreeM(length(TKDT52DI16_Test.TestBuff), nil, @TKDT52DI16_Test.Test_BuildM);
{$ELSE FPC}
  TKDT52DI16_Test.BuildKDTreeM(length(TKDT52DI16_Test.TestBuff), nil, TKDT52DI16_Test.Test_BuildM);
{$ENDIF FPC}
  { save/load test }
  n.Append('...save/load');
  m64 := TMemoryStream64.CustomCreate(1024 * 1024);
  TKDT52DI16_Test.SaveToStream(m64);
  m64.Position := 0;
  TKDT52DI16_Test.LoadFromStream(m64);
  for i := 0 to length(TKDT52DI16_Test.TestBuff) - 1 do
    begin
      p := TKDT52DI16_Test.Search(TKDT52DI16_Test.TestBuff[i]);
      if p^.Vec^.Index <> i then
          errored := True;
      if not p^.Vec^.Token.Same(umlIntToStr(i)) then
          errored := True;
      if errored then
          Break;
    end;
  DisposeObject(m64);

  if not errored then
    begin
      { parallel search test }
      n.Append('...parallel');
      SetLength(TestResultBuff, length(TKDT52DI16_Test.TestBuff));
      SetLength(TestResultIndex, length(TKDT52DI16_Test.TestBuff));
      TKDT52DI16_Test.Search(TKDT52DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if Distance(TKDT52DI16_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
            errored := True;
    end;

  if not errored then
    begin
      n.Append('...kMean');
      TKDT52DI16_Test.Clear;
      { kMean test }
      TKDT52DI16_Test.BuildKDTreeWithCluster(TKDT52DI16_Test.TestBuff, 10, 1, KMeanOutIndex);
      { parallel search test }
      TKDT52DI16_Test.Search(TKDT52DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if TestResultIndex[i] <> KMeanOutIndex[i] then
            errored := True;
    end;

  SetLength(TKDT52DI16_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT52DI16_Test.Clear;

  n.Append('...');
  if errored then
      n.Append('error!')
  else
      n.Append('passed ok %dms', [GetTimeTick - t]);
  DisposeObject(TKDT52DI16_Test);
  DoStatus(n);
  n := '';
end;

function TKDT64DI16.InternalBuildKdTree(const KDSourceBufferPtr: PKDT64DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT64DI16_Node;
  function SortCompare(const p1, p2: PKDT64DI16_Source; const axis: NativeInt): ShortInt;
  begin
    if p1^.buff[axis] = p2^.buff[axis] then
      begin
        if p1^.Index = p2^.Index then
            Result := 0
        else if p1^.Index < p2^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.buff[axis] < p2^.buff[axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT64DI16_SourceBuffer; L, R: NativeInt; const axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT64DI16_Source;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer^[(L + R) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, axis) < 0 do
            Inc(i);
        while SortCompare(SortBuffer^[j], p, axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, axis);
      L := i;
    until i >= R;
  end;

var
  M: NativeInt;
  axis: NativeInt;
  kdBuffPtr: PKDT64DI16_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      new(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.Vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);
    end
  else
    begin
      axis := Depth mod KDT64DI16_Axis;
      M := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr^[0], 0, PlanCount - 1, axis);

      new(Result);
      Result^.Parent := nil;
      Result^.Vec := kdBuffPtr^[M];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], M, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[M + 1], PlanCount - (M + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT64DI16.GetData(const Index: NativeInt): PKDT64DI16_Source;
begin
  Result := @KDStoreBuff[Index];
end;

constructor TKDT64DI16.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT64DI16.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT64DI16.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT64DI16_Node(KDNodes[i]));
      Inc(i);
    end;

  for i := 0 to length(KDStoreBuff) - 1 do
      KDStoreBuff[i].Token := '';

  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT64DI16.StoreBuffPtr: PKDT64DI16_DyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT64DI16.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT64DI16_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT64DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT64DI16.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT64DI16_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT64DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT64DI16.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT64DI16_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT64DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{ k-means++ clusterization }
procedure TKDT64DI16.BuildKDTreeWithCluster(const inBuff: TKDT64DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  SetLength(Source, length(inBuff), KDT64DI16_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT64DI16_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT64DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT64DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT64DI16.BuildKDTreeWithCluster(const inBuff: TKDT64DI16_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TKMIntegerArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT64DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT64DI16_BuildCall);
var
  TempStoreBuff: TKDT64DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT64DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT64DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT64DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT64DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT64DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT64DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT64DI16_BuildMethod);
var
  TempStoreBuff: TKDT64DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT64DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT64DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT64DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT64DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT64DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT64DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT64DI16_BuildProc);
var
  TempStoreBuff: TKDT64DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT64DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT64DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT64DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT64DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT64DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

function TKDT64DI16.Search(const buff: TKDT64DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT64DI16_Node;

var
  NearestNeighbour: PKDT64DI16_Node;

  function FindParentNode(const buffPtr: PKDT64DI16_Vec; NodePtr: PKDT64DI16_Node): PKDT64DI16_Node;
  var
    Next: PKDT64DI16_Node;
    Depth, axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        axis := Depth mod KDT64DI16_Axis;
        if buffPtr^[axis] > Next^.Vec^.buff[axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT64DI16_Node; const buffPtr: PKDT64DI16_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    Inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := Distance(buffPtr^, NodePtr^.Vec^.buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.Vec^.Index < NearestNeighbour^.Vec^.Index) then
        NearestNeighbour := NodePtr;

    axis := Depth mod KDT64DI16_Axis;
    Dist := NodePtr^.Vec^.buff[axis] - buffPtr^[axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.Vec^.buff[axis] > buffPtr^[axis] then
            ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const buffPtr: PKDT64DI16_Vec; const p1, p2: PKDT64DI16_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := Distance(buffPtr^, p1^.Vec^.buff);
    d2 := Distance(buffPtr^, p2^.Vec^.buff);
    if d1 = d2 then
      begin
        if p1^.Vec^.Index = p2^.Vec^.Index then
            Result := 0
        else if p1^.Vec^.Index < p2^.Vec^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; L, R: NativeInt; const buffPtr: PKDT64DI16_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT64DI16_Node;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer[(L + R) shr 1];
      repeat
        while SortCompare(buffPtr, SortBuffer[i], p) < 0 do
            Inc(i);
        while SortCompare(buffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, buffPtr);
      L := i;
    until i >= R;
  end;

var
  Parent: PKDT64DI16_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := Distance(buff, Parent^.Vec^.buff);

  ScanSubtree(RootNode, @buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT64DI16_Node(NearestNodes[0]);
    end;
end;

function TKDT64DI16.Search(const buff: TKDT64DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT64DI16_Node;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT64DI16.Search(const buff: TKDT64DI16_Vec; var SearchedDistanceMin: Double): PKDT64DI16_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT64DI16.Search(const buff: TKDT64DI16_Vec): PKDT64DI16_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT64DI16.SearchToken(const buff: TKDT64DI16_Vec): TPascalString;
var
  p: PKDT64DI16_Node;
begin
  p := Search(buff);
  if p <> nil then
      Result := p^.Vec^.Token
  else
      Result := '';
end;

procedure TKDT64DI16.Search(const inBuff: TKDT64DI16_DynamicVecBuffer; var OutBuff: TKDT64DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT64DI16_DynamicVecBuffer;
  outBuffPtr: PKDT64DI16_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT64DI16_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outBuffPtr^[pass] := p^.Vec^.buff;
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT64DI16_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outBuffPtr^[pass] := p^.Vec^.buff;
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT64DI16_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.Vec^.buff;
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT64DI16.Search(const inBuff: TKDT64DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT64DI16_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT64DI16_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT64DI16_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT64DI16_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT64DI16.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  ID := KDT64DI16_Axis;

  stream.write(st, 4);
  stream.write(ID, 4);

  stream.write(cnt, 8);

  i := 0;
  while i < cnt do
    begin
      stream.write(KDStoreBuff[i].buff[0], SizeOf(TKDT64DI16_Vec));
      stream.write(KDStoreBuff[i].Index, 8);
      token_B := KDStoreBuff[i].Token.Bytes;
      token_L := length(token_B);
      stream.write(token_L, 4);
      if token_L > 0 then
        begin
          stream.write(token_B[0], token_L);
          SetLength(token_B, 0);
        end;
      Inc(i);
    end;
end;

procedure TKDT64DI16.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  Clear;

  stream.read(st, 4);
  stream.read(ID, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if ID <> KDT64DI16_Axis then
      RaiseInfo('kdtree axis error!');

  stream.read(cnt, 8);

  SetLength(KDStoreBuff, cnt);

  i := 0;
  try
    while i < cnt do
      begin
        if stream.read(KDStoreBuff[i].buff[0], SizeOf(TKDT64DI16_Vec)) <> SizeOf(TKDT64DI16_Vec) then
          begin
            Clear;
            Exit;
          end;
        if stream.read(KDStoreBuff[i].Index, 8) <> 8 then
          begin
            Clear;
            Exit;
          end;
        if stream.read(token_L, 4) <> 4 then
          begin
            Clear;
            Exit;
          end;
        if token_L > 0 then
          begin
            SetLength(token_B, token_L);
            if stream.read(token_B[0], token_L) <> token_L then
              begin
                Clear;
                Exit;
              end;
            KDStoreBuff[i].Token.Bytes := token_B;
            SetLength(token_B, 0);
          end
        else
            KDStoreBuff[i].Token := '';
        Inc(i);
      end;
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      Inc(i);
    end;

  if cnt > 0 then
      RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT64DI16.SaveToFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(FileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT64DI16.LoadFromFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT64DI16.PrintNodeTree(const NodePtr: PKDT64DI16_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT64DI16_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.Vec^.Index, Vec(p^.Vec^.buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT64DI16.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d - %d : %s ', [i, KDStoreBuff[i].Index, Vec(KDStoreBuff[i].buff)]);
end;

class function TKDT64DI16.Vec(const s: SystemString): TKDT64DI16_Vec;
var
  t: TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j: NativeInt;
begin
  for i := 0 to KDT64DI16_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            Inc(j);
            if j >= KDT64DI16_Axis then
                Break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT64DI16.Vec(const v: TKDT64DI16_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT64DI16_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT64DI16.Distance(const v1, v2: TKDT64DI16_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT64DI16_Axis - 1 do
      Result := Result + (v2[i] - v1[i]) * (v2[i] - v1[i]);
end;

procedure TKDT64DI16.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT64DI16_Source; const Data: Pointer);
begin
  Source.buff := TestBuff[IndexFor];
  Source.Token := umlIntToStr(IndexFor);
end;

class procedure TKDT64DI16.Test;
var
  TKDT64DI16_Test: TKDT64DI16;
  t: TTimeTick;
  i, j: NativeInt;
  TestResultBuff: TKDT64DI16_DynamicVecBuffer;
  TestResultIndex: TKMIntegerArray;
  KMeanOutIndex: TKMIntegerArray;
  errored: Boolean;
  m64: TMemoryStream64;
  p: PKDT64DI16_Node;
  n: TPascalString;
begin
  errored := False;
  n := PFormat('test %s...', [ClassName]);
  t := GetTimeTick;

  n.Append('...build');
  TKDT64DI16_Test := TKDT64DI16.Create;

  n.Append('...');
  SetLength(TKDT64DI16_Test.TestBuff, 1000);
  for i := 0 to length(TKDT64DI16_Test.TestBuff) - 1 do
    for j := 0 to KDT64DI16_Axis - 1 do
        TKDT64DI16_Test.TestBuff[i][j] := i * KDT64DI16_Axis + j;

{$IFDEF FPC}
  TKDT64DI16_Test.BuildKDTreeM(length(TKDT64DI16_Test.TestBuff), nil, @TKDT64DI16_Test.Test_BuildM);
{$ELSE FPC}
  TKDT64DI16_Test.BuildKDTreeM(length(TKDT64DI16_Test.TestBuff), nil, TKDT64DI16_Test.Test_BuildM);
{$ENDIF FPC}
  { save/load test }
  n.Append('...save/load');
  m64 := TMemoryStream64.CustomCreate(1024 * 1024);
  TKDT64DI16_Test.SaveToStream(m64);
  m64.Position := 0;
  TKDT64DI16_Test.LoadFromStream(m64);
  for i := 0 to length(TKDT64DI16_Test.TestBuff) - 1 do
    begin
      p := TKDT64DI16_Test.Search(TKDT64DI16_Test.TestBuff[i]);
      if p^.Vec^.Index <> i then
          errored := True;
      if not p^.Vec^.Token.Same(umlIntToStr(i)) then
          errored := True;
      if errored then
          Break;
    end;
  DisposeObject(m64);

  if not errored then
    begin
      { parallel search test }
      n.Append('...parallel');
      SetLength(TestResultBuff, length(TKDT64DI16_Test.TestBuff));
      SetLength(TestResultIndex, length(TKDT64DI16_Test.TestBuff));
      TKDT64DI16_Test.Search(TKDT64DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if Distance(TKDT64DI16_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
            errored := True;
    end;

  if not errored then
    begin
      n.Append('...kMean');
      TKDT64DI16_Test.Clear;
      { kMean test }
      TKDT64DI16_Test.BuildKDTreeWithCluster(TKDT64DI16_Test.TestBuff, 10, 1, KMeanOutIndex);
      { parallel search test }
      TKDT64DI16_Test.Search(TKDT64DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if TestResultIndex[i] <> KMeanOutIndex[i] then
            errored := True;
    end;

  SetLength(TKDT64DI16_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT64DI16_Test.Clear;

  n.Append('...');
  if errored then
      n.Append('error!')
  else
      n.Append('passed ok %dms', [GetTimeTick - t]);
  DisposeObject(TKDT64DI16_Test);
  DoStatus(n);
  n := '';
end;

function TKDT96DI16.InternalBuildKdTree(const KDSourceBufferPtr: PKDT96DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT96DI16_Node;
  function SortCompare(const p1, p2: PKDT96DI16_Source; const axis: NativeInt): ShortInt;
  begin
    if p1^.buff[axis] = p2^.buff[axis] then
      begin
        if p1^.Index = p2^.Index then
            Result := 0
        else if p1^.Index < p2^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.buff[axis] < p2^.buff[axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT96DI16_SourceBuffer; L, R: NativeInt; const axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT96DI16_Source;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer^[(L + R) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, axis) < 0 do
            Inc(i);
        while SortCompare(SortBuffer^[j], p, axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, axis);
      L := i;
    until i >= R;
  end;

var
  M: NativeInt;
  axis: NativeInt;
  kdBuffPtr: PKDT96DI16_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      new(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.Vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);
    end
  else
    begin
      axis := Depth mod KDT96DI16_Axis;
      M := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr^[0], 0, PlanCount - 1, axis);

      new(Result);
      Result^.Parent := nil;
      Result^.Vec := kdBuffPtr^[M];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], M, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[M + 1], PlanCount - (M + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT96DI16.GetData(const Index: NativeInt): PKDT96DI16_Source;
begin
  Result := @KDStoreBuff[Index];
end;

constructor TKDT96DI16.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT96DI16.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT96DI16.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT96DI16_Node(KDNodes[i]));
      Inc(i);
    end;

  for i := 0 to length(KDStoreBuff) - 1 do
      KDStoreBuff[i].Token := '';

  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT96DI16.StoreBuffPtr: PKDT96DI16_DyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT96DI16.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT96DI16_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT96DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT96DI16.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT96DI16_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT96DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT96DI16.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT96DI16_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT96DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{ k-means++ clusterization }
procedure TKDT96DI16.BuildKDTreeWithCluster(const inBuff: TKDT96DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  SetLength(Source, length(inBuff), KDT96DI16_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT96DI16_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT96DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT96DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT96DI16.BuildKDTreeWithCluster(const inBuff: TKDT96DI16_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TKMIntegerArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT96DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT96DI16_BuildCall);
var
  TempStoreBuff: TKDT96DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT96DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT96DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT96DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT96DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT96DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT96DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT96DI16_BuildMethod);
var
  TempStoreBuff: TKDT96DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT96DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT96DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT96DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT96DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT96DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT96DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT96DI16_BuildProc);
var
  TempStoreBuff: TKDT96DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT96DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT96DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT96DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT96DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT96DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

function TKDT96DI16.Search(const buff: TKDT96DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT96DI16_Node;

var
  NearestNeighbour: PKDT96DI16_Node;

  function FindParentNode(const buffPtr: PKDT96DI16_Vec; NodePtr: PKDT96DI16_Node): PKDT96DI16_Node;
  var
    Next: PKDT96DI16_Node;
    Depth, axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        axis := Depth mod KDT96DI16_Axis;
        if buffPtr^[axis] > Next^.Vec^.buff[axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT96DI16_Node; const buffPtr: PKDT96DI16_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    Inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := Distance(buffPtr^, NodePtr^.Vec^.buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.Vec^.Index < NearestNeighbour^.Vec^.Index) then
        NearestNeighbour := NodePtr;

    axis := Depth mod KDT96DI16_Axis;
    Dist := NodePtr^.Vec^.buff[axis] - buffPtr^[axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.Vec^.buff[axis] > buffPtr^[axis] then
            ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const buffPtr: PKDT96DI16_Vec; const p1, p2: PKDT96DI16_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := Distance(buffPtr^, p1^.Vec^.buff);
    d2 := Distance(buffPtr^, p2^.Vec^.buff);
    if d1 = d2 then
      begin
        if p1^.Vec^.Index = p2^.Vec^.Index then
            Result := 0
        else if p1^.Vec^.Index < p2^.Vec^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; L, R: NativeInt; const buffPtr: PKDT96DI16_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT96DI16_Node;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer[(L + R) shr 1];
      repeat
        while SortCompare(buffPtr, SortBuffer[i], p) < 0 do
            Inc(i);
        while SortCompare(buffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, buffPtr);
      L := i;
    until i >= R;
  end;

var
  Parent: PKDT96DI16_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := Distance(buff, Parent^.Vec^.buff);

  ScanSubtree(RootNode, @buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT96DI16_Node(NearestNodes[0]);
    end;
end;

function TKDT96DI16.Search(const buff: TKDT96DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT96DI16_Node;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT96DI16.Search(const buff: TKDT96DI16_Vec; var SearchedDistanceMin: Double): PKDT96DI16_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT96DI16.Search(const buff: TKDT96DI16_Vec): PKDT96DI16_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT96DI16.SearchToken(const buff: TKDT96DI16_Vec): TPascalString;
var
  p: PKDT96DI16_Node;
begin
  p := Search(buff);
  if p <> nil then
      Result := p^.Vec^.Token
  else
      Result := '';
end;

procedure TKDT96DI16.Search(const inBuff: TKDT96DI16_DynamicVecBuffer; var OutBuff: TKDT96DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT96DI16_DynamicVecBuffer;
  outBuffPtr: PKDT96DI16_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT96DI16_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outBuffPtr^[pass] := p^.Vec^.buff;
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT96DI16_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outBuffPtr^[pass] := p^.Vec^.buff;
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT96DI16_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.Vec^.buff;
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT96DI16.Search(const inBuff: TKDT96DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT96DI16_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT96DI16_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT96DI16_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT96DI16_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT96DI16.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  ID := KDT96DI16_Axis;

  stream.write(st, 4);
  stream.write(ID, 4);

  stream.write(cnt, 8);

  i := 0;
  while i < cnt do
    begin
      stream.write(KDStoreBuff[i].buff[0], SizeOf(TKDT96DI16_Vec));
      stream.write(KDStoreBuff[i].Index, 8);
      token_B := KDStoreBuff[i].Token.Bytes;
      token_L := length(token_B);
      stream.write(token_L, 4);
      if token_L > 0 then
        begin
          stream.write(token_B[0], token_L);
          SetLength(token_B, 0);
        end;
      Inc(i);
    end;
end;

procedure TKDT96DI16.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  Clear;

  stream.read(st, 4);
  stream.read(ID, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if ID <> KDT96DI16_Axis then
      RaiseInfo('kdtree axis error!');

  stream.read(cnt, 8);

  SetLength(KDStoreBuff, cnt);

  i := 0;
  try
    while i < cnt do
      begin
        if stream.read(KDStoreBuff[i].buff[0], SizeOf(TKDT96DI16_Vec)) <> SizeOf(TKDT96DI16_Vec) then
          begin
            Clear;
            Exit;
          end;
        if stream.read(KDStoreBuff[i].Index, 8) <> 8 then
          begin
            Clear;
            Exit;
          end;
        if stream.read(token_L, 4) <> 4 then
          begin
            Clear;
            Exit;
          end;
        if token_L > 0 then
          begin
            SetLength(token_B, token_L);
            if stream.read(token_B[0], token_L) <> token_L then
              begin
                Clear;
                Exit;
              end;
            KDStoreBuff[i].Token.Bytes := token_B;
            SetLength(token_B, 0);
          end
        else
            KDStoreBuff[i].Token := '';
        Inc(i);
      end;
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      Inc(i);
    end;

  if cnt > 0 then
      RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT96DI16.SaveToFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(FileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT96DI16.LoadFromFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT96DI16.PrintNodeTree(const NodePtr: PKDT96DI16_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT96DI16_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.Vec^.Index, Vec(p^.Vec^.buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT96DI16.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d - %d : %s ', [i, KDStoreBuff[i].Index, Vec(KDStoreBuff[i].buff)]);
end;

class function TKDT96DI16.Vec(const s: SystemString): TKDT96DI16_Vec;
var
  t: TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j: NativeInt;
begin
  for i := 0 to KDT96DI16_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            Inc(j);
            if j >= KDT96DI16_Axis then
                Break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT96DI16.Vec(const v: TKDT96DI16_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT96DI16_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT96DI16.Distance(const v1, v2: TKDT96DI16_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT96DI16_Axis - 1 do
      Result := Result + (v2[i] - v1[i]) * (v2[i] - v1[i]);
end;

procedure TKDT96DI16.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT96DI16_Source; const Data: Pointer);
begin
  Source.buff := TestBuff[IndexFor];
  Source.Token := umlIntToStr(IndexFor);
end;

class procedure TKDT96DI16.Test;
var
  TKDT96DI16_Test: TKDT96DI16;
  t: TTimeTick;
  i, j: NativeInt;
  TestResultBuff: TKDT96DI16_DynamicVecBuffer;
  TestResultIndex: TKMIntegerArray;
  KMeanOutIndex: TKMIntegerArray;
  errored: Boolean;
  m64: TMemoryStream64;
  p: PKDT96DI16_Node;
  n: TPascalString;
begin
  errored := False;
  n := PFormat('test %s...', [ClassName]);
  t := GetTimeTick;

  n.Append('...build');
  TKDT96DI16_Test := TKDT96DI16.Create;

  n.Append('...');
  SetLength(TKDT96DI16_Test.TestBuff, 1000);
  for i := 0 to length(TKDT96DI16_Test.TestBuff) - 1 do
    for j := 0 to KDT96DI16_Axis - 1 do
        TKDT96DI16_Test.TestBuff[i][j] := i * KDT96DI16_Axis + j;

{$IFDEF FPC}
  TKDT96DI16_Test.BuildKDTreeM(length(TKDT96DI16_Test.TestBuff), nil, @TKDT96DI16_Test.Test_BuildM);
{$ELSE FPC}
  TKDT96DI16_Test.BuildKDTreeM(length(TKDT96DI16_Test.TestBuff), nil, TKDT96DI16_Test.Test_BuildM);
{$ENDIF FPC}
  { save/load test }
  n.Append('...save/load');
  m64 := TMemoryStream64.CustomCreate(1024 * 1024);
  TKDT96DI16_Test.SaveToStream(m64);
  m64.Position := 0;
  TKDT96DI16_Test.LoadFromStream(m64);
  for i := 0 to length(TKDT96DI16_Test.TestBuff) - 1 do
    begin
      p := TKDT96DI16_Test.Search(TKDT96DI16_Test.TestBuff[i]);
      if p^.Vec^.Index <> i then
          errored := True;
      if not p^.Vec^.Token.Same(umlIntToStr(i)) then
          errored := True;
      if errored then
          Break;
    end;
  DisposeObject(m64);

  if not errored then
    begin
      { parallel search test }
      n.Append('...parallel');
      SetLength(TestResultBuff, length(TKDT96DI16_Test.TestBuff));
      SetLength(TestResultIndex, length(TKDT96DI16_Test.TestBuff));
      TKDT96DI16_Test.Search(TKDT96DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if Distance(TKDT96DI16_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
            errored := True;
    end;

  if not errored then
    begin
      n.Append('...kMean');
      TKDT96DI16_Test.Clear;
      { kMean test }
      TKDT96DI16_Test.BuildKDTreeWithCluster(TKDT96DI16_Test.TestBuff, 10, 1, KMeanOutIndex);
      { parallel search test }
      TKDT96DI16_Test.Search(TKDT96DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if TestResultIndex[i] <> KMeanOutIndex[i] then
            errored := True;
    end;

  SetLength(TKDT96DI16_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT96DI16_Test.Clear;

  n.Append('...');
  if errored then
      n.Append('error!')
  else
      n.Append('passed ok %dms', [GetTimeTick - t]);
  DisposeObject(TKDT96DI16_Test);
  DoStatus(n);
  n := '';
end;

function TKDT128DI16.InternalBuildKdTree(const KDSourceBufferPtr: PKDT128DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT128DI16_Node;
  function SortCompare(const p1, p2: PKDT128DI16_Source; const axis: NativeInt): ShortInt;
  begin
    if p1^.buff[axis] = p2^.buff[axis] then
      begin
        if p1^.Index = p2^.Index then
            Result := 0
        else if p1^.Index < p2^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.buff[axis] < p2^.buff[axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT128DI16_SourceBuffer; L, R: NativeInt; const axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT128DI16_Source;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer^[(L + R) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, axis) < 0 do
            Inc(i);
        while SortCompare(SortBuffer^[j], p, axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, axis);
      L := i;
    until i >= R;
  end;

var
  M: NativeInt;
  axis: NativeInt;
  kdBuffPtr: PKDT128DI16_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      new(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.Vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);
    end
  else
    begin
      axis := Depth mod KDT128DI16_Axis;
      M := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr^[0], 0, PlanCount - 1, axis);

      new(Result);
      Result^.Parent := nil;
      Result^.Vec := kdBuffPtr^[M];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], M, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[M + 1], PlanCount - (M + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT128DI16.GetData(const Index: NativeInt): PKDT128DI16_Source;
begin
  Result := @KDStoreBuff[Index];
end;

constructor TKDT128DI16.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT128DI16.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT128DI16.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT128DI16_Node(KDNodes[i]));
      Inc(i);
    end;

  for i := 0 to length(KDStoreBuff) - 1 do
      KDStoreBuff[i].Token := '';

  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT128DI16.StoreBuffPtr: PKDT128DI16_DyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT128DI16.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT128DI16_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT128DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT128DI16.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT128DI16_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT128DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT128DI16.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT128DI16_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT128DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{ k-means++ clusterization }
procedure TKDT128DI16.BuildKDTreeWithCluster(const inBuff: TKDT128DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  SetLength(Source, length(inBuff), KDT128DI16_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT128DI16_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT128DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT128DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT128DI16.BuildKDTreeWithCluster(const inBuff: TKDT128DI16_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TKMIntegerArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT128DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT128DI16_BuildCall);
var
  TempStoreBuff: TKDT128DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT128DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT128DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT128DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT128DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT128DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT128DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT128DI16_BuildMethod);
var
  TempStoreBuff: TKDT128DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT128DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT128DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT128DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT128DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT128DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT128DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT128DI16_BuildProc);
var
  TempStoreBuff: TKDT128DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT128DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT128DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT128DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT128DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT128DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

function TKDT128DI16.Search(const buff: TKDT128DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT128DI16_Node;

var
  NearestNeighbour: PKDT128DI16_Node;

  function FindParentNode(const buffPtr: PKDT128DI16_Vec; NodePtr: PKDT128DI16_Node): PKDT128DI16_Node;
  var
    Next: PKDT128DI16_Node;
    Depth, axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        axis := Depth mod KDT128DI16_Axis;
        if buffPtr^[axis] > Next^.Vec^.buff[axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT128DI16_Node; const buffPtr: PKDT128DI16_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    Inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := Distance(buffPtr^, NodePtr^.Vec^.buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.Vec^.Index < NearestNeighbour^.Vec^.Index) then
        NearestNeighbour := NodePtr;

    axis := Depth mod KDT128DI16_Axis;
    Dist := NodePtr^.Vec^.buff[axis] - buffPtr^[axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.Vec^.buff[axis] > buffPtr^[axis] then
            ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const buffPtr: PKDT128DI16_Vec; const p1, p2: PKDT128DI16_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := Distance(buffPtr^, p1^.Vec^.buff);
    d2 := Distance(buffPtr^, p2^.Vec^.buff);
    if d1 = d2 then
      begin
        if p1^.Vec^.Index = p2^.Vec^.Index then
            Result := 0
        else if p1^.Vec^.Index < p2^.Vec^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; L, R: NativeInt; const buffPtr: PKDT128DI16_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT128DI16_Node;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer[(L + R) shr 1];
      repeat
        while SortCompare(buffPtr, SortBuffer[i], p) < 0 do
            Inc(i);
        while SortCompare(buffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, buffPtr);
      L := i;
    until i >= R;
  end;

var
  Parent: PKDT128DI16_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := Distance(buff, Parent^.Vec^.buff);

  ScanSubtree(RootNode, @buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT128DI16_Node(NearestNodes[0]);
    end;
end;

function TKDT128DI16.Search(const buff: TKDT128DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT128DI16_Node;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT128DI16.Search(const buff: TKDT128DI16_Vec; var SearchedDistanceMin: Double): PKDT128DI16_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT128DI16.Search(const buff: TKDT128DI16_Vec): PKDT128DI16_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT128DI16.SearchToken(const buff: TKDT128DI16_Vec): TPascalString;
var
  p: PKDT128DI16_Node;
begin
  p := Search(buff);
  if p <> nil then
      Result := p^.Vec^.Token
  else
      Result := '';
end;

procedure TKDT128DI16.Search(const inBuff: TKDT128DI16_DynamicVecBuffer; var OutBuff: TKDT128DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT128DI16_DynamicVecBuffer;
  outBuffPtr: PKDT128DI16_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT128DI16_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outBuffPtr^[pass] := p^.Vec^.buff;
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT128DI16_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outBuffPtr^[pass] := p^.Vec^.buff;
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT128DI16_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.Vec^.buff;
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT128DI16.Search(const inBuff: TKDT128DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT128DI16_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT128DI16_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT128DI16_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT128DI16_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT128DI16.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  ID := KDT128DI16_Axis;

  stream.write(st, 4);
  stream.write(ID, 4);

  stream.write(cnt, 8);

  i := 0;
  while i < cnt do
    begin
      stream.write(KDStoreBuff[i].buff[0], SizeOf(TKDT128DI16_Vec));
      stream.write(KDStoreBuff[i].Index, 8);
      token_B := KDStoreBuff[i].Token.Bytes;
      token_L := length(token_B);
      stream.write(token_L, 4);
      if token_L > 0 then
        begin
          stream.write(token_B[0], token_L);
          SetLength(token_B, 0);
        end;
      Inc(i);
    end;
end;

procedure TKDT128DI16.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  Clear;

  stream.read(st, 4);
  stream.read(ID, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if ID <> KDT128DI16_Axis then
      RaiseInfo('kdtree axis error!');

  stream.read(cnt, 8);

  SetLength(KDStoreBuff, cnt);

  i := 0;
  try
    while i < cnt do
      begin
        if stream.read(KDStoreBuff[i].buff[0], SizeOf(TKDT128DI16_Vec)) <> SizeOf(TKDT128DI16_Vec) then
          begin
            Clear;
            Exit;
          end;
        if stream.read(KDStoreBuff[i].Index, 8) <> 8 then
          begin
            Clear;
            Exit;
          end;
        if stream.read(token_L, 4) <> 4 then
          begin
            Clear;
            Exit;
          end;
        if token_L > 0 then
          begin
            SetLength(token_B, token_L);
            if stream.read(token_B[0], token_L) <> token_L then
              begin
                Clear;
                Exit;
              end;
            KDStoreBuff[i].Token.Bytes := token_B;
            SetLength(token_B, 0);
          end
        else
            KDStoreBuff[i].Token := '';
        Inc(i);
      end;
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      Inc(i);
    end;

  if cnt > 0 then
      RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT128DI16.SaveToFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(FileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT128DI16.LoadFromFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT128DI16.PrintNodeTree(const NodePtr: PKDT128DI16_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT128DI16_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.Vec^.Index, Vec(p^.Vec^.buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT128DI16.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d - %d : %s ', [i, KDStoreBuff[i].Index, Vec(KDStoreBuff[i].buff)]);
end;

class function TKDT128DI16.Vec(const s: SystemString): TKDT128DI16_Vec;
var
  t: TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j: NativeInt;
begin
  for i := 0 to KDT128DI16_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            Inc(j);
            if j >= KDT128DI16_Axis then
                Break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT128DI16.Vec(const v: TKDT128DI16_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT128DI16_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT128DI16.Distance(const v1, v2: TKDT128DI16_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT128DI16_Axis - 1 do
      Result := Result + (v2[i] - v1[i]) * (v2[i] - v1[i]);
end;

procedure TKDT128DI16.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT128DI16_Source; const Data: Pointer);
begin
  Source.buff := TestBuff[IndexFor];
  Source.Token := umlIntToStr(IndexFor);
end;

class procedure TKDT128DI16.Test;
var
  TKDT128DI16_Test: TKDT128DI16;
  t: TTimeTick;
  i, j: NativeInt;
  TestResultBuff: TKDT128DI16_DynamicVecBuffer;
  TestResultIndex: TKMIntegerArray;
  KMeanOutIndex: TKMIntegerArray;
  errored: Boolean;
  m64: TMemoryStream64;
  p: PKDT128DI16_Node;
  n: TPascalString;
begin
  errored := False;
  n := PFormat('test %s...', [ClassName]);
  t := GetTimeTick;

  n.Append('...build');
  TKDT128DI16_Test := TKDT128DI16.Create;

  n.Append('...');
  SetLength(TKDT128DI16_Test.TestBuff, 1000);
  for i := 0 to length(TKDT128DI16_Test.TestBuff) - 1 do
    for j := 0 to KDT128DI16_Axis - 1 do
        TKDT128DI16_Test.TestBuff[i][j] := i * KDT128DI16_Axis + j;

{$IFDEF FPC}
  TKDT128DI16_Test.BuildKDTreeM(length(TKDT128DI16_Test.TestBuff), nil, @TKDT128DI16_Test.Test_BuildM);
{$ELSE FPC}
  TKDT128DI16_Test.BuildKDTreeM(length(TKDT128DI16_Test.TestBuff), nil, TKDT128DI16_Test.Test_BuildM);
{$ENDIF FPC}
  { save/load test }
  n.Append('...save/load');
  m64 := TMemoryStream64.CustomCreate(1024 * 1024);
  TKDT128DI16_Test.SaveToStream(m64);
  m64.Position := 0;
  TKDT128DI16_Test.LoadFromStream(m64);
  for i := 0 to length(TKDT128DI16_Test.TestBuff) - 1 do
    begin
      p := TKDT128DI16_Test.Search(TKDT128DI16_Test.TestBuff[i]);
      if p^.Vec^.Index <> i then
          errored := True;
      if not p^.Vec^.Token.Same(umlIntToStr(i)) then
          errored := True;
      if errored then
          Break;
    end;
  DisposeObject(m64);

  if not errored then
    begin
      { parallel search test }
      n.Append('...parallel');
      SetLength(TestResultBuff, length(TKDT128DI16_Test.TestBuff));
      SetLength(TestResultIndex, length(TKDT128DI16_Test.TestBuff));
      TKDT128DI16_Test.Search(TKDT128DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if Distance(TKDT128DI16_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
            errored := True;
    end;

  if not errored then
    begin
      n.Append('...kMean');
      TKDT128DI16_Test.Clear;
      { kMean test }
      TKDT128DI16_Test.BuildKDTreeWithCluster(TKDT128DI16_Test.TestBuff, 10, 1, KMeanOutIndex);
      { parallel search test }
      TKDT128DI16_Test.Search(TKDT128DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if TestResultIndex[i] <> KMeanOutIndex[i] then
            errored := True;
    end;

  SetLength(TKDT128DI16_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT128DI16_Test.Clear;

  n.Append('...');
  if errored then
      n.Append('error!')
  else
      n.Append('passed ok %dms', [GetTimeTick - t]);
  DisposeObject(TKDT128DI16_Test);
  DoStatus(n);
  n := '';
end;

function TKDT156DI16.InternalBuildKdTree(const KDSourceBufferPtr: PKDT156DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT156DI16_Node;
  function SortCompare(const p1, p2: PKDT156DI16_Source; const axis: NativeInt): ShortInt;
  begin
    if p1^.buff[axis] = p2^.buff[axis] then
      begin
        if p1^.Index = p2^.Index then
            Result := 0
        else if p1^.Index < p2^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.buff[axis] < p2^.buff[axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT156DI16_SourceBuffer; L, R: NativeInt; const axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT156DI16_Source;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer^[(L + R) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, axis) < 0 do
            Inc(i);
        while SortCompare(SortBuffer^[j], p, axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, axis);
      L := i;
    until i >= R;
  end;

var
  M: NativeInt;
  axis: NativeInt;
  kdBuffPtr: PKDT156DI16_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      new(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.Vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);
    end
  else
    begin
      axis := Depth mod KDT156DI16_Axis;
      M := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr^[0], 0, PlanCount - 1, axis);

      new(Result);
      Result^.Parent := nil;
      Result^.Vec := kdBuffPtr^[M];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], M, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[M + 1], PlanCount - (M + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT156DI16.GetData(const Index: NativeInt): PKDT156DI16_Source;
begin
  Result := @KDStoreBuff[Index];
end;

constructor TKDT156DI16.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT156DI16.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT156DI16.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT156DI16_Node(KDNodes[i]));
      Inc(i);
    end;

  for i := 0 to length(KDStoreBuff) - 1 do
      KDStoreBuff[i].Token := '';

  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT156DI16.StoreBuffPtr: PKDT156DI16_DyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT156DI16.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT156DI16_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT156DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT156DI16.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT156DI16_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT156DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT156DI16.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT156DI16_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT156DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{ k-means++ clusterization }
procedure TKDT156DI16.BuildKDTreeWithCluster(const inBuff: TKDT156DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  SetLength(Source, length(inBuff), KDT156DI16_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT156DI16_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT156DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT156DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT156DI16.BuildKDTreeWithCluster(const inBuff: TKDT156DI16_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TKMIntegerArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT156DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT156DI16_BuildCall);
var
  TempStoreBuff: TKDT156DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT156DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT156DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT156DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT156DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT156DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT156DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT156DI16_BuildMethod);
var
  TempStoreBuff: TKDT156DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT156DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT156DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT156DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT156DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT156DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT156DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT156DI16_BuildProc);
var
  TempStoreBuff: TKDT156DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT156DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT156DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT156DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT156DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT156DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

function TKDT156DI16.Search(const buff: TKDT156DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT156DI16_Node;

var
  NearestNeighbour: PKDT156DI16_Node;

  function FindParentNode(const buffPtr: PKDT156DI16_Vec; NodePtr: PKDT156DI16_Node): PKDT156DI16_Node;
  var
    Next: PKDT156DI16_Node;
    Depth, axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        axis := Depth mod KDT156DI16_Axis;
        if buffPtr^[axis] > Next^.Vec^.buff[axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT156DI16_Node; const buffPtr: PKDT156DI16_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    Inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := Distance(buffPtr^, NodePtr^.Vec^.buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.Vec^.Index < NearestNeighbour^.Vec^.Index) then
        NearestNeighbour := NodePtr;

    axis := Depth mod KDT156DI16_Axis;
    Dist := NodePtr^.Vec^.buff[axis] - buffPtr^[axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.Vec^.buff[axis] > buffPtr^[axis] then
            ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const buffPtr: PKDT156DI16_Vec; const p1, p2: PKDT156DI16_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := Distance(buffPtr^, p1^.Vec^.buff);
    d2 := Distance(buffPtr^, p2^.Vec^.buff);
    if d1 = d2 then
      begin
        if p1^.Vec^.Index = p2^.Vec^.Index then
            Result := 0
        else if p1^.Vec^.Index < p2^.Vec^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; L, R: NativeInt; const buffPtr: PKDT156DI16_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT156DI16_Node;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer[(L + R) shr 1];
      repeat
        while SortCompare(buffPtr, SortBuffer[i], p) < 0 do
            Inc(i);
        while SortCompare(buffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, buffPtr);
      L := i;
    until i >= R;
  end;

var
  Parent: PKDT156DI16_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := Distance(buff, Parent^.Vec^.buff);

  ScanSubtree(RootNode, @buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT156DI16_Node(NearestNodes[0]);
    end;
end;

function TKDT156DI16.Search(const buff: TKDT156DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT156DI16_Node;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT156DI16.Search(const buff: TKDT156DI16_Vec; var SearchedDistanceMin: Double): PKDT156DI16_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT156DI16.Search(const buff: TKDT156DI16_Vec): PKDT156DI16_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT156DI16.SearchToken(const buff: TKDT156DI16_Vec): TPascalString;
var
  p: PKDT156DI16_Node;
begin
  p := Search(buff);
  if p <> nil then
      Result := p^.Vec^.Token
  else
      Result := '';
end;

procedure TKDT156DI16.Search(const inBuff: TKDT156DI16_DynamicVecBuffer; var OutBuff: TKDT156DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT156DI16_DynamicVecBuffer;
  outBuffPtr: PKDT156DI16_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT156DI16_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outBuffPtr^[pass] := p^.Vec^.buff;
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT156DI16_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outBuffPtr^[pass] := p^.Vec^.buff;
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT156DI16_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.Vec^.buff;
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT156DI16.Search(const inBuff: TKDT156DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT156DI16_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT156DI16_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT156DI16_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT156DI16_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT156DI16.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  ID := KDT156DI16_Axis;

  stream.write(st, 4);
  stream.write(ID, 4);

  stream.write(cnt, 8);

  i := 0;
  while i < cnt do
    begin
      stream.write(KDStoreBuff[i].buff[0], SizeOf(TKDT156DI16_Vec));
      stream.write(KDStoreBuff[i].Index, 8);
      token_B := KDStoreBuff[i].Token.Bytes;
      token_L := length(token_B);
      stream.write(token_L, 4);
      if token_L > 0 then
        begin
          stream.write(token_B[0], token_L);
          SetLength(token_B, 0);
        end;
      Inc(i);
    end;
end;

procedure TKDT156DI16.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  Clear;

  stream.read(st, 4);
  stream.read(ID, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if ID <> KDT156DI16_Axis then
      RaiseInfo('kdtree axis error!');

  stream.read(cnt, 8);

  SetLength(KDStoreBuff, cnt);

  i := 0;
  try
    while i < cnt do
      begin
        if stream.read(KDStoreBuff[i].buff[0], SizeOf(TKDT156DI16_Vec)) <> SizeOf(TKDT156DI16_Vec) then
          begin
            Clear;
            Exit;
          end;
        if stream.read(KDStoreBuff[i].Index, 8) <> 8 then
          begin
            Clear;
            Exit;
          end;
        if stream.read(token_L, 4) <> 4 then
          begin
            Clear;
            Exit;
          end;
        if token_L > 0 then
          begin
            SetLength(token_B, token_L);
            if stream.read(token_B[0], token_L) <> token_L then
              begin
                Clear;
                Exit;
              end;
            KDStoreBuff[i].Token.Bytes := token_B;
            SetLength(token_B, 0);
          end
        else
            KDStoreBuff[i].Token := '';
        Inc(i);
      end;
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      Inc(i);
    end;

  if cnt > 0 then
      RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT156DI16.SaveToFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(FileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT156DI16.LoadFromFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT156DI16.PrintNodeTree(const NodePtr: PKDT156DI16_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT156DI16_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.Vec^.Index, Vec(p^.Vec^.buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT156DI16.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d - %d : %s ', [i, KDStoreBuff[i].Index, Vec(KDStoreBuff[i].buff)]);
end;

class function TKDT156DI16.Vec(const s: SystemString): TKDT156DI16_Vec;
var
  t: TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j: NativeInt;
begin
  for i := 0 to KDT156DI16_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            Inc(j);
            if j >= KDT156DI16_Axis then
                Break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT156DI16.Vec(const v: TKDT156DI16_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT156DI16_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT156DI16.Distance(const v1, v2: TKDT156DI16_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT156DI16_Axis - 1 do
      Result := Result + (v2[i] - v1[i]) * (v2[i] - v1[i]);
end;

procedure TKDT156DI16.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT156DI16_Source; const Data: Pointer);
begin
  Source.buff := TestBuff[IndexFor];
  Source.Token := umlIntToStr(IndexFor);
end;

class procedure TKDT156DI16.Test;
var
  TKDT156DI16_Test: TKDT156DI16;
  t: TTimeTick;
  i, j: NativeInt;
  TestResultBuff: TKDT156DI16_DynamicVecBuffer;
  TestResultIndex: TKMIntegerArray;
  KMeanOutIndex: TKMIntegerArray;
  errored: Boolean;
  m64: TMemoryStream64;
  p: PKDT156DI16_Node;
  n: TPascalString;
begin
  errored := False;
  n := PFormat('test %s...', [ClassName]);
  t := GetTimeTick;

  n.Append('...build');
  TKDT156DI16_Test := TKDT156DI16.Create;

  n.Append('...');
  SetLength(TKDT156DI16_Test.TestBuff, 1000);
  for i := 0 to length(TKDT156DI16_Test.TestBuff) - 1 do
    for j := 0 to KDT156DI16_Axis - 1 do
        TKDT156DI16_Test.TestBuff[i][j] := i * KDT156DI16_Axis + j;

{$IFDEF FPC}
  TKDT156DI16_Test.BuildKDTreeM(length(TKDT156DI16_Test.TestBuff), nil, @TKDT156DI16_Test.Test_BuildM);
{$ELSE FPC}
  TKDT156DI16_Test.BuildKDTreeM(length(TKDT156DI16_Test.TestBuff), nil, TKDT156DI16_Test.Test_BuildM);
{$ENDIF FPC}
  { save/load test }
  n.Append('...save/load');
  m64 := TMemoryStream64.CustomCreate(1024 * 1024);
  TKDT156DI16_Test.SaveToStream(m64);
  m64.Position := 0;
  TKDT156DI16_Test.LoadFromStream(m64);
  for i := 0 to length(TKDT156DI16_Test.TestBuff) - 1 do
    begin
      p := TKDT156DI16_Test.Search(TKDT156DI16_Test.TestBuff[i]);
      if p^.Vec^.Index <> i then
          errored := True;
      if not p^.Vec^.Token.Same(umlIntToStr(i)) then
          errored := True;
      if errored then
          Break;
    end;
  DisposeObject(m64);

  if not errored then
    begin
      { parallel search test }
      n.Append('...parallel');
      SetLength(TestResultBuff, length(TKDT156DI16_Test.TestBuff));
      SetLength(TestResultIndex, length(TKDT156DI16_Test.TestBuff));
      TKDT156DI16_Test.Search(TKDT156DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if Distance(TKDT156DI16_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
            errored := True;
    end;

  if not errored then
    begin
      n.Append('...kMean');
      TKDT156DI16_Test.Clear;
      { kMean test }
      TKDT156DI16_Test.BuildKDTreeWithCluster(TKDT156DI16_Test.TestBuff, 10, 1, KMeanOutIndex);
      { parallel search test }
      TKDT156DI16_Test.Search(TKDT156DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if TestResultIndex[i] <> KMeanOutIndex[i] then
            errored := True;
    end;

  SetLength(TKDT156DI16_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT156DI16_Test.Clear;

  n.Append('...');
  if errored then
      n.Append('error!')
  else
      n.Append('passed ok %dms', [GetTimeTick - t]);
  DisposeObject(TKDT156DI16_Test);
  DoStatus(n);
  n := '';
end;

function TKDT192DI16.InternalBuildKdTree(const KDSourceBufferPtr: PKDT192DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT192DI16_Node;
  function SortCompare(const p1, p2: PKDT192DI16_Source; const axis: NativeInt): ShortInt;
  begin
    if p1^.buff[axis] = p2^.buff[axis] then
      begin
        if p1^.Index = p2^.Index then
            Result := 0
        else if p1^.Index < p2^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.buff[axis] < p2^.buff[axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT192DI16_SourceBuffer; L, R: NativeInt; const axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT192DI16_Source;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer^[(L + R) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, axis) < 0 do
            Inc(i);
        while SortCompare(SortBuffer^[j], p, axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, axis);
      L := i;
    until i >= R;
  end;

var
  M: NativeInt;
  axis: NativeInt;
  kdBuffPtr: PKDT192DI16_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      new(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.Vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);
    end
  else
    begin
      axis := Depth mod KDT192DI16_Axis;
      M := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr^[0], 0, PlanCount - 1, axis);

      new(Result);
      Result^.Parent := nil;
      Result^.Vec := kdBuffPtr^[M];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], M, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[M + 1], PlanCount - (M + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT192DI16.GetData(const Index: NativeInt): PKDT192DI16_Source;
begin
  Result := @KDStoreBuff[Index];
end;

constructor TKDT192DI16.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT192DI16.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT192DI16.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT192DI16_Node(KDNodes[i]));
      Inc(i);
    end;

  for i := 0 to length(KDStoreBuff) - 1 do
      KDStoreBuff[i].Token := '';

  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT192DI16.StoreBuffPtr: PKDT192DI16_DyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT192DI16.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT192DI16_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT192DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT192DI16.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT192DI16_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT192DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT192DI16.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT192DI16_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT192DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{ k-means++ clusterization }
procedure TKDT192DI16.BuildKDTreeWithCluster(const inBuff: TKDT192DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  SetLength(Source, length(inBuff), KDT192DI16_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT192DI16_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT192DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT192DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT192DI16.BuildKDTreeWithCluster(const inBuff: TKDT192DI16_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TKMIntegerArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT192DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT192DI16_BuildCall);
var
  TempStoreBuff: TKDT192DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT192DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT192DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT192DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT192DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT192DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT192DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT192DI16_BuildMethod);
var
  TempStoreBuff: TKDT192DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT192DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT192DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT192DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT192DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT192DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT192DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT192DI16_BuildProc);
var
  TempStoreBuff: TKDT192DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT192DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT192DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT192DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT192DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT192DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

function TKDT192DI16.Search(const buff: TKDT192DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT192DI16_Node;

var
  NearestNeighbour: PKDT192DI16_Node;

  function FindParentNode(const buffPtr: PKDT192DI16_Vec; NodePtr: PKDT192DI16_Node): PKDT192DI16_Node;
  var
    Next: PKDT192DI16_Node;
    Depth, axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        axis := Depth mod KDT192DI16_Axis;
        if buffPtr^[axis] > Next^.Vec^.buff[axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT192DI16_Node; const buffPtr: PKDT192DI16_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    Inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := Distance(buffPtr^, NodePtr^.Vec^.buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.Vec^.Index < NearestNeighbour^.Vec^.Index) then
        NearestNeighbour := NodePtr;

    axis := Depth mod KDT192DI16_Axis;
    Dist := NodePtr^.Vec^.buff[axis] - buffPtr^[axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.Vec^.buff[axis] > buffPtr^[axis] then
            ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const buffPtr: PKDT192DI16_Vec; const p1, p2: PKDT192DI16_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := Distance(buffPtr^, p1^.Vec^.buff);
    d2 := Distance(buffPtr^, p2^.Vec^.buff);
    if d1 = d2 then
      begin
        if p1^.Vec^.Index = p2^.Vec^.Index then
            Result := 0
        else if p1^.Vec^.Index < p2^.Vec^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; L, R: NativeInt; const buffPtr: PKDT192DI16_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT192DI16_Node;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer[(L + R) shr 1];
      repeat
        while SortCompare(buffPtr, SortBuffer[i], p) < 0 do
            Inc(i);
        while SortCompare(buffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, buffPtr);
      L := i;
    until i >= R;
  end;

var
  Parent: PKDT192DI16_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := Distance(buff, Parent^.Vec^.buff);

  ScanSubtree(RootNode, @buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT192DI16_Node(NearestNodes[0]);
    end;
end;

function TKDT192DI16.Search(const buff: TKDT192DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT192DI16_Node;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT192DI16.Search(const buff: TKDT192DI16_Vec; var SearchedDistanceMin: Double): PKDT192DI16_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT192DI16.Search(const buff: TKDT192DI16_Vec): PKDT192DI16_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT192DI16.SearchToken(const buff: TKDT192DI16_Vec): TPascalString;
var
  p: PKDT192DI16_Node;
begin
  p := Search(buff);
  if p <> nil then
      Result := p^.Vec^.Token
  else
      Result := '';
end;

procedure TKDT192DI16.Search(const inBuff: TKDT192DI16_DynamicVecBuffer; var OutBuff: TKDT192DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT192DI16_DynamicVecBuffer;
  outBuffPtr: PKDT192DI16_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT192DI16_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outBuffPtr^[pass] := p^.Vec^.buff;
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT192DI16_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outBuffPtr^[pass] := p^.Vec^.buff;
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT192DI16_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.Vec^.buff;
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT192DI16.Search(const inBuff: TKDT192DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT192DI16_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT192DI16_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT192DI16_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT192DI16_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT192DI16.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  ID := KDT192DI16_Axis;

  stream.write(st, 4);
  stream.write(ID, 4);

  stream.write(cnt, 8);

  i := 0;
  while i < cnt do
    begin
      stream.write(KDStoreBuff[i].buff[0], SizeOf(TKDT192DI16_Vec));
      stream.write(KDStoreBuff[i].Index, 8);
      token_B := KDStoreBuff[i].Token.Bytes;
      token_L := length(token_B);
      stream.write(token_L, 4);
      if token_L > 0 then
        begin
          stream.write(token_B[0], token_L);
          SetLength(token_B, 0);
        end;
      Inc(i);
    end;
end;

procedure TKDT192DI16.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  Clear;

  stream.read(st, 4);
  stream.read(ID, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if ID <> KDT192DI16_Axis then
      RaiseInfo('kdtree axis error!');

  stream.read(cnt, 8);

  SetLength(KDStoreBuff, cnt);

  i := 0;
  try
    while i < cnt do
      begin
        if stream.read(KDStoreBuff[i].buff[0], SizeOf(TKDT192DI16_Vec)) <> SizeOf(TKDT192DI16_Vec) then
          begin
            Clear;
            Exit;
          end;
        if stream.read(KDStoreBuff[i].Index, 8) <> 8 then
          begin
            Clear;
            Exit;
          end;
        if stream.read(token_L, 4) <> 4 then
          begin
            Clear;
            Exit;
          end;
        if token_L > 0 then
          begin
            SetLength(token_B, token_L);
            if stream.read(token_B[0], token_L) <> token_L then
              begin
                Clear;
                Exit;
              end;
            KDStoreBuff[i].Token.Bytes := token_B;
            SetLength(token_B, 0);
          end
        else
            KDStoreBuff[i].Token := '';
        Inc(i);
      end;
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      Inc(i);
    end;

  if cnt > 0 then
      RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT192DI16.SaveToFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(FileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT192DI16.LoadFromFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT192DI16.PrintNodeTree(const NodePtr: PKDT192DI16_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT192DI16_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.Vec^.Index, Vec(p^.Vec^.buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT192DI16.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d - %d : %s ', [i, KDStoreBuff[i].Index, Vec(KDStoreBuff[i].buff)]);
end;

class function TKDT192DI16.Vec(const s: SystemString): TKDT192DI16_Vec;
var
  t: TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j: NativeInt;
begin
  for i := 0 to KDT192DI16_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            Inc(j);
            if j >= KDT192DI16_Axis then
                Break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT192DI16.Vec(const v: TKDT192DI16_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT192DI16_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT192DI16.Distance(const v1, v2: TKDT192DI16_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT192DI16_Axis - 1 do
      Result := Result + (v2[i] - v1[i]) * (v2[i] - v1[i]);
end;

procedure TKDT192DI16.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT192DI16_Source; const Data: Pointer);
begin
  Source.buff := TestBuff[IndexFor];
  Source.Token := umlIntToStr(IndexFor);
end;

class procedure TKDT192DI16.Test;
var
  TKDT192DI16_Test: TKDT192DI16;
  t: TTimeTick;
  i, j: NativeInt;
  TestResultBuff: TKDT192DI16_DynamicVecBuffer;
  TestResultIndex: TKMIntegerArray;
  KMeanOutIndex: TKMIntegerArray;
  errored: Boolean;
  m64: TMemoryStream64;
  p: PKDT192DI16_Node;
  n: TPascalString;
begin
  errored := False;
  n := PFormat('test %s...', [ClassName]);
  t := GetTimeTick;

  n.Append('...build');
  TKDT192DI16_Test := TKDT192DI16.Create;

  n.Append('...');
  SetLength(TKDT192DI16_Test.TestBuff, 1000);
  for i := 0 to length(TKDT192DI16_Test.TestBuff) - 1 do
    for j := 0 to KDT192DI16_Axis - 1 do
        TKDT192DI16_Test.TestBuff[i][j] := i * KDT192DI16_Axis + j;

{$IFDEF FPC}
  TKDT192DI16_Test.BuildKDTreeM(length(TKDT192DI16_Test.TestBuff), nil, @TKDT192DI16_Test.Test_BuildM);
{$ELSE FPC}
  TKDT192DI16_Test.BuildKDTreeM(length(TKDT192DI16_Test.TestBuff), nil, TKDT192DI16_Test.Test_BuildM);
{$ENDIF FPC}
  { save/load test }
  n.Append('...save/load');
  m64 := TMemoryStream64.CustomCreate(1024 * 1024);
  TKDT192DI16_Test.SaveToStream(m64);
  m64.Position := 0;
  TKDT192DI16_Test.LoadFromStream(m64);
  for i := 0 to length(TKDT192DI16_Test.TestBuff) - 1 do
    begin
      p := TKDT192DI16_Test.Search(TKDT192DI16_Test.TestBuff[i]);
      if p^.Vec^.Index <> i then
          errored := True;
      if not p^.Vec^.Token.Same(umlIntToStr(i)) then
          errored := True;
      if errored then
          Break;
    end;
  DisposeObject(m64);

  if not errored then
    begin
      { parallel search test }
      n.Append('...parallel');
      SetLength(TestResultBuff, length(TKDT192DI16_Test.TestBuff));
      SetLength(TestResultIndex, length(TKDT192DI16_Test.TestBuff));
      TKDT192DI16_Test.Search(TKDT192DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if Distance(TKDT192DI16_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
            errored := True;
    end;

  if not errored then
    begin
      n.Append('...kMean');
      TKDT192DI16_Test.Clear;
      { kMean test }
      TKDT192DI16_Test.BuildKDTreeWithCluster(TKDT192DI16_Test.TestBuff, 10, 1, KMeanOutIndex);
      { parallel search test }
      TKDT192DI16_Test.Search(TKDT192DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if TestResultIndex[i] <> KMeanOutIndex[i] then
            errored := True;
    end;

  SetLength(TKDT192DI16_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT192DI16_Test.Clear;

  n.Append('...');
  if errored then
      n.Append('error!')
  else
      n.Append('passed ok %dms', [GetTimeTick - t]);
  DisposeObject(TKDT192DI16_Test);
  DoStatus(n);
  n := '';
end;

function TKDT256DI16.InternalBuildKdTree(const KDSourceBufferPtr: PKDT256DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT256DI16_Node;
  function SortCompare(const p1, p2: PKDT256DI16_Source; const axis: NativeInt): ShortInt;
  begin
    if p1^.buff[axis] = p2^.buff[axis] then
      begin
        if p1^.Index = p2^.Index then
            Result := 0
        else if p1^.Index < p2^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.buff[axis] < p2^.buff[axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT256DI16_SourceBuffer; L, R: NativeInt; const axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT256DI16_Source;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer^[(L + R) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, axis) < 0 do
            Inc(i);
        while SortCompare(SortBuffer^[j], p, axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, axis);
      L := i;
    until i >= R;
  end;

var
  M: NativeInt;
  axis: NativeInt;
  kdBuffPtr: PKDT256DI16_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      new(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.Vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);
    end
  else
    begin
      axis := Depth mod KDT256DI16_Axis;
      M := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr^[0], 0, PlanCount - 1, axis);

      new(Result);
      Result^.Parent := nil;
      Result^.Vec := kdBuffPtr^[M];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], M, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[M + 1], PlanCount - (M + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT256DI16.GetData(const Index: NativeInt): PKDT256DI16_Source;
begin
  Result := @KDStoreBuff[Index];
end;

constructor TKDT256DI16.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT256DI16.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT256DI16.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT256DI16_Node(KDNodes[i]));
      Inc(i);
    end;

  for i := 0 to length(KDStoreBuff) - 1 do
      KDStoreBuff[i].Token := '';

  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT256DI16.StoreBuffPtr: PKDT256DI16_DyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT256DI16.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT256DI16_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT256DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT256DI16.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT256DI16_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT256DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT256DI16.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT256DI16_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT256DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{ k-means++ clusterization }
procedure TKDT256DI16.BuildKDTreeWithCluster(const inBuff: TKDT256DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  SetLength(Source, length(inBuff), KDT256DI16_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT256DI16_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT256DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT256DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT256DI16.BuildKDTreeWithCluster(const inBuff: TKDT256DI16_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TKMIntegerArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT256DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT256DI16_BuildCall);
var
  TempStoreBuff: TKDT256DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT256DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT256DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT256DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT256DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT256DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT256DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT256DI16_BuildMethod);
var
  TempStoreBuff: TKDT256DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT256DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT256DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT256DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT256DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT256DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT256DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT256DI16_BuildProc);
var
  TempStoreBuff: TKDT256DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT256DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT256DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT256DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT256DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT256DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

function TKDT256DI16.Search(const buff: TKDT256DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT256DI16_Node;

var
  NearestNeighbour: PKDT256DI16_Node;

  function FindParentNode(const buffPtr: PKDT256DI16_Vec; NodePtr: PKDT256DI16_Node): PKDT256DI16_Node;
  var
    Next: PKDT256DI16_Node;
    Depth, axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        axis := Depth mod KDT256DI16_Axis;
        if buffPtr^[axis] > Next^.Vec^.buff[axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT256DI16_Node; const buffPtr: PKDT256DI16_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    Inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := Distance(buffPtr^, NodePtr^.Vec^.buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.Vec^.Index < NearestNeighbour^.Vec^.Index) then
        NearestNeighbour := NodePtr;

    axis := Depth mod KDT256DI16_Axis;
    Dist := NodePtr^.Vec^.buff[axis] - buffPtr^[axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.Vec^.buff[axis] > buffPtr^[axis] then
            ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const buffPtr: PKDT256DI16_Vec; const p1, p2: PKDT256DI16_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := Distance(buffPtr^, p1^.Vec^.buff);
    d2 := Distance(buffPtr^, p2^.Vec^.buff);
    if d1 = d2 then
      begin
        if p1^.Vec^.Index = p2^.Vec^.Index then
            Result := 0
        else if p1^.Vec^.Index < p2^.Vec^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; L, R: NativeInt; const buffPtr: PKDT256DI16_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT256DI16_Node;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer[(L + R) shr 1];
      repeat
        while SortCompare(buffPtr, SortBuffer[i], p) < 0 do
            Inc(i);
        while SortCompare(buffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, buffPtr);
      L := i;
    until i >= R;
  end;

var
  Parent: PKDT256DI16_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := Distance(buff, Parent^.Vec^.buff);

  ScanSubtree(RootNode, @buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT256DI16_Node(NearestNodes[0]);
    end;
end;

function TKDT256DI16.Search(const buff: TKDT256DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT256DI16_Node;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT256DI16.Search(const buff: TKDT256DI16_Vec; var SearchedDistanceMin: Double): PKDT256DI16_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT256DI16.Search(const buff: TKDT256DI16_Vec): PKDT256DI16_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT256DI16.SearchToken(const buff: TKDT256DI16_Vec): TPascalString;
var
  p: PKDT256DI16_Node;
begin
  p := Search(buff);
  if p <> nil then
      Result := p^.Vec^.Token
  else
      Result := '';
end;

procedure TKDT256DI16.Search(const inBuff: TKDT256DI16_DynamicVecBuffer; var OutBuff: TKDT256DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT256DI16_DynamicVecBuffer;
  outBuffPtr: PKDT256DI16_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT256DI16_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outBuffPtr^[pass] := p^.Vec^.buff;
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT256DI16_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outBuffPtr^[pass] := p^.Vec^.buff;
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT256DI16_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.Vec^.buff;
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT256DI16.Search(const inBuff: TKDT256DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT256DI16_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT256DI16_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT256DI16_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT256DI16_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT256DI16.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  ID := KDT256DI16_Axis;

  stream.write(st, 4);
  stream.write(ID, 4);

  stream.write(cnt, 8);

  i := 0;
  while i < cnt do
    begin
      stream.write(KDStoreBuff[i].buff[0], SizeOf(TKDT256DI16_Vec));
      stream.write(KDStoreBuff[i].Index, 8);
      token_B := KDStoreBuff[i].Token.Bytes;
      token_L := length(token_B);
      stream.write(token_L, 4);
      if token_L > 0 then
        begin
          stream.write(token_B[0], token_L);
          SetLength(token_B, 0);
        end;
      Inc(i);
    end;
end;

procedure TKDT256DI16.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  Clear;

  stream.read(st, 4);
  stream.read(ID, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if ID <> KDT256DI16_Axis then
      RaiseInfo('kdtree axis error!');

  stream.read(cnt, 8);

  SetLength(KDStoreBuff, cnt);

  i := 0;
  try
    while i < cnt do
      begin
        if stream.read(KDStoreBuff[i].buff[0], SizeOf(TKDT256DI16_Vec)) <> SizeOf(TKDT256DI16_Vec) then
          begin
            Clear;
            Exit;
          end;
        if stream.read(KDStoreBuff[i].Index, 8) <> 8 then
          begin
            Clear;
            Exit;
          end;
        if stream.read(token_L, 4) <> 4 then
          begin
            Clear;
            Exit;
          end;
        if token_L > 0 then
          begin
            SetLength(token_B, token_L);
            if stream.read(token_B[0], token_L) <> token_L then
              begin
                Clear;
                Exit;
              end;
            KDStoreBuff[i].Token.Bytes := token_B;
            SetLength(token_B, 0);
          end
        else
            KDStoreBuff[i].Token := '';
        Inc(i);
      end;
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      Inc(i);
    end;

  if cnt > 0 then
      RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT256DI16.SaveToFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(FileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT256DI16.LoadFromFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT256DI16.PrintNodeTree(const NodePtr: PKDT256DI16_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT256DI16_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.Vec^.Index, Vec(p^.Vec^.buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT256DI16.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d - %d : %s ', [i, KDStoreBuff[i].Index, Vec(KDStoreBuff[i].buff)]);
end;

class function TKDT256DI16.Vec(const s: SystemString): TKDT256DI16_Vec;
var
  t: TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j: NativeInt;
begin
  for i := 0 to KDT256DI16_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            Inc(j);
            if j >= KDT256DI16_Axis then
                Break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT256DI16.Vec(const v: TKDT256DI16_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT256DI16_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT256DI16.Distance(const v1, v2: TKDT256DI16_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT256DI16_Axis - 1 do
      Result := Result + (v2[i] - v1[i]) * (v2[i] - v1[i]);
end;

procedure TKDT256DI16.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT256DI16_Source; const Data: Pointer);
begin
  Source.buff := TestBuff[IndexFor];
  Source.Token := umlIntToStr(IndexFor);
end;

class procedure TKDT256DI16.Test;
var
  TKDT256DI16_Test: TKDT256DI16;
  t: TTimeTick;
  i, j: NativeInt;
  TestResultBuff: TKDT256DI16_DynamicVecBuffer;
  TestResultIndex: TKMIntegerArray;
  KMeanOutIndex: TKMIntegerArray;
  errored: Boolean;
  m64: TMemoryStream64;
  p: PKDT256DI16_Node;
  n: TPascalString;
begin
  errored := False;
  n := PFormat('test %s...', [ClassName]);
  t := GetTimeTick;

  n.Append('...build');
  TKDT256DI16_Test := TKDT256DI16.Create;

  n.Append('...');
  SetLength(TKDT256DI16_Test.TestBuff, 1000);
  for i := 0 to length(TKDT256DI16_Test.TestBuff) - 1 do
    for j := 0 to KDT256DI16_Axis - 1 do
        TKDT256DI16_Test.TestBuff[i][j] := i * KDT256DI16_Axis + j;

{$IFDEF FPC}
  TKDT256DI16_Test.BuildKDTreeM(length(TKDT256DI16_Test.TestBuff), nil, @TKDT256DI16_Test.Test_BuildM);
{$ELSE FPC}
  TKDT256DI16_Test.BuildKDTreeM(length(TKDT256DI16_Test.TestBuff), nil, TKDT256DI16_Test.Test_BuildM);
{$ENDIF FPC}
  { save/load test }
  n.Append('...save/load');
  m64 := TMemoryStream64.CustomCreate(1024 * 1024);
  TKDT256DI16_Test.SaveToStream(m64);
  m64.Position := 0;
  TKDT256DI16_Test.LoadFromStream(m64);
  for i := 0 to length(TKDT256DI16_Test.TestBuff) - 1 do
    begin
      p := TKDT256DI16_Test.Search(TKDT256DI16_Test.TestBuff[i]);
      if p^.Vec^.Index <> i then
          errored := True;
      if not p^.Vec^.Token.Same(umlIntToStr(i)) then
          errored := True;
      if errored then
          Break;
    end;
  DisposeObject(m64);

  if not errored then
    begin
      { parallel search test }
      n.Append('...parallel');
      SetLength(TestResultBuff, length(TKDT256DI16_Test.TestBuff));
      SetLength(TestResultIndex, length(TKDT256DI16_Test.TestBuff));
      TKDT256DI16_Test.Search(TKDT256DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if Distance(TKDT256DI16_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
            errored := True;
    end;

  if not errored then
    begin
      n.Append('...kMean');
      TKDT256DI16_Test.Clear;
      { kMean test }
      TKDT256DI16_Test.BuildKDTreeWithCluster(TKDT256DI16_Test.TestBuff, 10, 1, KMeanOutIndex);
      { parallel search test }
      TKDT256DI16_Test.Search(TKDT256DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if TestResultIndex[i] <> KMeanOutIndex[i] then
            errored := True;
    end;

  SetLength(TKDT256DI16_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT256DI16_Test.Clear;

  n.Append('...');
  if errored then
      n.Append('error!')
  else
      n.Append('passed ok %dms', [GetTimeTick - t]);
  DisposeObject(TKDT256DI16_Test);
  DoStatus(n);
  n := '';
end;

function TKDT384DI16.InternalBuildKdTree(const KDSourceBufferPtr: PKDT384DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT384DI16_Node;
  function SortCompare(const p1, p2: PKDT384DI16_Source; const axis: NativeInt): ShortInt;
  begin
    if p1^.buff[axis] = p2^.buff[axis] then
      begin
        if p1^.Index = p2^.Index then
            Result := 0
        else if p1^.Index < p2^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.buff[axis] < p2^.buff[axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT384DI16_SourceBuffer; L, R: NativeInt; const axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT384DI16_Source;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer^[(L + R) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, axis) < 0 do
            Inc(i);
        while SortCompare(SortBuffer^[j], p, axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, axis);
      L := i;
    until i >= R;
  end;

var
  M: NativeInt;
  axis: NativeInt;
  kdBuffPtr: PKDT384DI16_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      new(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.Vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);
    end
  else
    begin
      axis := Depth mod KDT384DI16_Axis;
      M := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr^[0], 0, PlanCount - 1, axis);

      new(Result);
      Result^.Parent := nil;
      Result^.Vec := kdBuffPtr^[M];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], M, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[M + 1], PlanCount - (M + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT384DI16.GetData(const Index: NativeInt): PKDT384DI16_Source;
begin
  Result := @KDStoreBuff[Index];
end;

constructor TKDT384DI16.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT384DI16.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT384DI16.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT384DI16_Node(KDNodes[i]));
      Inc(i);
    end;

  for i := 0 to length(KDStoreBuff) - 1 do
      KDStoreBuff[i].Token := '';

  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT384DI16.StoreBuffPtr: PKDT384DI16_DyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT384DI16.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT384DI16_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT384DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT384DI16.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT384DI16_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT384DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT384DI16.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT384DI16_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT384DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{ k-means++ clusterization }
procedure TKDT384DI16.BuildKDTreeWithCluster(const inBuff: TKDT384DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  SetLength(Source, length(inBuff), KDT384DI16_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT384DI16_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT384DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT384DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT384DI16.BuildKDTreeWithCluster(const inBuff: TKDT384DI16_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TKMIntegerArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT384DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT384DI16_BuildCall);
var
  TempStoreBuff: TKDT384DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT384DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT384DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT384DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT384DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT384DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT384DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT384DI16_BuildMethod);
var
  TempStoreBuff: TKDT384DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT384DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT384DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT384DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT384DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT384DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT384DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT384DI16_BuildProc);
var
  TempStoreBuff: TKDT384DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT384DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT384DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT384DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT384DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT384DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

function TKDT384DI16.Search(const buff: TKDT384DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT384DI16_Node;

var
  NearestNeighbour: PKDT384DI16_Node;

  function FindParentNode(const buffPtr: PKDT384DI16_Vec; NodePtr: PKDT384DI16_Node): PKDT384DI16_Node;
  var
    Next: PKDT384DI16_Node;
    Depth, axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        axis := Depth mod KDT384DI16_Axis;
        if buffPtr^[axis] > Next^.Vec^.buff[axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT384DI16_Node; const buffPtr: PKDT384DI16_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    Inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := Distance(buffPtr^, NodePtr^.Vec^.buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.Vec^.Index < NearestNeighbour^.Vec^.Index) then
        NearestNeighbour := NodePtr;

    axis := Depth mod KDT384DI16_Axis;
    Dist := NodePtr^.Vec^.buff[axis] - buffPtr^[axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.Vec^.buff[axis] > buffPtr^[axis] then
            ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const buffPtr: PKDT384DI16_Vec; const p1, p2: PKDT384DI16_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := Distance(buffPtr^, p1^.Vec^.buff);
    d2 := Distance(buffPtr^, p2^.Vec^.buff);
    if d1 = d2 then
      begin
        if p1^.Vec^.Index = p2^.Vec^.Index then
            Result := 0
        else if p1^.Vec^.Index < p2^.Vec^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; L, R: NativeInt; const buffPtr: PKDT384DI16_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT384DI16_Node;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer[(L + R) shr 1];
      repeat
        while SortCompare(buffPtr, SortBuffer[i], p) < 0 do
            Inc(i);
        while SortCompare(buffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, buffPtr);
      L := i;
    until i >= R;
  end;

var
  Parent: PKDT384DI16_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := Distance(buff, Parent^.Vec^.buff);

  ScanSubtree(RootNode, @buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT384DI16_Node(NearestNodes[0]);
    end;
end;

function TKDT384DI16.Search(const buff: TKDT384DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT384DI16_Node;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT384DI16.Search(const buff: TKDT384DI16_Vec; var SearchedDistanceMin: Double): PKDT384DI16_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT384DI16.Search(const buff: TKDT384DI16_Vec): PKDT384DI16_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT384DI16.SearchToken(const buff: TKDT384DI16_Vec): TPascalString;
var
  p: PKDT384DI16_Node;
begin
  p := Search(buff);
  if p <> nil then
      Result := p^.Vec^.Token
  else
      Result := '';
end;

procedure TKDT384DI16.Search(const inBuff: TKDT384DI16_DynamicVecBuffer; var OutBuff: TKDT384DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT384DI16_DynamicVecBuffer;
  outBuffPtr: PKDT384DI16_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT384DI16_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outBuffPtr^[pass] := p^.Vec^.buff;
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT384DI16_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outBuffPtr^[pass] := p^.Vec^.buff;
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT384DI16_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.Vec^.buff;
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT384DI16.Search(const inBuff: TKDT384DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT384DI16_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT384DI16_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT384DI16_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT384DI16_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT384DI16.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  ID := KDT384DI16_Axis;

  stream.write(st, 4);
  stream.write(ID, 4);

  stream.write(cnt, 8);

  i := 0;
  while i < cnt do
    begin
      stream.write(KDStoreBuff[i].buff[0], SizeOf(TKDT384DI16_Vec));
      stream.write(KDStoreBuff[i].Index, 8);
      token_B := KDStoreBuff[i].Token.Bytes;
      token_L := length(token_B);
      stream.write(token_L, 4);
      if token_L > 0 then
        begin
          stream.write(token_B[0], token_L);
          SetLength(token_B, 0);
        end;
      Inc(i);
    end;
end;

procedure TKDT384DI16.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  Clear;

  stream.read(st, 4);
  stream.read(ID, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if ID <> KDT384DI16_Axis then
      RaiseInfo('kdtree axis error!');

  stream.read(cnt, 8);

  SetLength(KDStoreBuff, cnt);

  i := 0;
  try
    while i < cnt do
      begin
        if stream.read(KDStoreBuff[i].buff[0], SizeOf(TKDT384DI16_Vec)) <> SizeOf(TKDT384DI16_Vec) then
          begin
            Clear;
            Exit;
          end;
        if stream.read(KDStoreBuff[i].Index, 8) <> 8 then
          begin
            Clear;
            Exit;
          end;
        if stream.read(token_L, 4) <> 4 then
          begin
            Clear;
            Exit;
          end;
        if token_L > 0 then
          begin
            SetLength(token_B, token_L);
            if stream.read(token_B[0], token_L) <> token_L then
              begin
                Clear;
                Exit;
              end;
            KDStoreBuff[i].Token.Bytes := token_B;
            SetLength(token_B, 0);
          end
        else
            KDStoreBuff[i].Token := '';
        Inc(i);
      end;
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      Inc(i);
    end;

  if cnt > 0 then
      RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT384DI16.SaveToFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(FileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT384DI16.LoadFromFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT384DI16.PrintNodeTree(const NodePtr: PKDT384DI16_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT384DI16_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.Vec^.Index, Vec(p^.Vec^.buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT384DI16.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d - %d : %s ', [i, KDStoreBuff[i].Index, Vec(KDStoreBuff[i].buff)]);
end;

class function TKDT384DI16.Vec(const s: SystemString): TKDT384DI16_Vec;
var
  t: TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j: NativeInt;
begin
  for i := 0 to KDT384DI16_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            Inc(j);
            if j >= KDT384DI16_Axis then
                Break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT384DI16.Vec(const v: TKDT384DI16_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT384DI16_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT384DI16.Distance(const v1, v2: TKDT384DI16_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT384DI16_Axis - 1 do
      Result := Result + (v2[i] - v1[i]) * (v2[i] - v1[i]);
end;

procedure TKDT384DI16.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT384DI16_Source; const Data: Pointer);
begin
  Source.buff := TestBuff[IndexFor];
  Source.Token := umlIntToStr(IndexFor);
end;

class procedure TKDT384DI16.Test;
var
  TKDT384DI16_Test: TKDT384DI16;
  t: TTimeTick;
  i, j: NativeInt;
  TestResultBuff: TKDT384DI16_DynamicVecBuffer;
  TestResultIndex: TKMIntegerArray;
  KMeanOutIndex: TKMIntegerArray;
  errored: Boolean;
  m64: TMemoryStream64;
  p: PKDT384DI16_Node;
  n: TPascalString;
begin
  errored := False;
  n := PFormat('test %s...', [ClassName]);
  t := GetTimeTick;

  n.Append('...build');
  TKDT384DI16_Test := TKDT384DI16.Create;

  n.Append('...');
  SetLength(TKDT384DI16_Test.TestBuff, 1000);
  for i := 0 to length(TKDT384DI16_Test.TestBuff) - 1 do
    for j := 0 to KDT384DI16_Axis - 1 do
        TKDT384DI16_Test.TestBuff[i][j] := i * KDT384DI16_Axis + j;

{$IFDEF FPC}
  TKDT384DI16_Test.BuildKDTreeM(length(TKDT384DI16_Test.TestBuff), nil, @TKDT384DI16_Test.Test_BuildM);
{$ELSE FPC}
  TKDT384DI16_Test.BuildKDTreeM(length(TKDT384DI16_Test.TestBuff), nil, TKDT384DI16_Test.Test_BuildM);
{$ENDIF FPC}
  { save/load test }
  n.Append('...save/load');
  m64 := TMemoryStream64.CustomCreate(1024 * 1024);
  TKDT384DI16_Test.SaveToStream(m64);
  m64.Position := 0;
  TKDT384DI16_Test.LoadFromStream(m64);
  for i := 0 to length(TKDT384DI16_Test.TestBuff) - 1 do
    begin
      p := TKDT384DI16_Test.Search(TKDT384DI16_Test.TestBuff[i]);
      if p^.Vec^.Index <> i then
          errored := True;
      if not p^.Vec^.Token.Same(umlIntToStr(i)) then
          errored := True;
      if errored then
          Break;
    end;
  DisposeObject(m64);

  if not errored then
    begin
      { parallel search test }
      n.Append('...parallel');
      SetLength(TestResultBuff, length(TKDT384DI16_Test.TestBuff));
      SetLength(TestResultIndex, length(TKDT384DI16_Test.TestBuff));
      TKDT384DI16_Test.Search(TKDT384DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if Distance(TKDT384DI16_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
            errored := True;
    end;

  if not errored then
    begin
      n.Append('...kMean');
      TKDT384DI16_Test.Clear;
      { kMean test }
      TKDT384DI16_Test.BuildKDTreeWithCluster(TKDT384DI16_Test.TestBuff, 10, 1, KMeanOutIndex);
      { parallel search test }
      TKDT384DI16_Test.Search(TKDT384DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if TestResultIndex[i] <> KMeanOutIndex[i] then
            errored := True;
    end;

  SetLength(TKDT384DI16_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT384DI16_Test.Clear;

  n.Append('...');
  if errored then
      n.Append('error!')
  else
      n.Append('passed ok %dms', [GetTimeTick - t]);
  DisposeObject(TKDT384DI16_Test);
  DoStatus(n);
  n := '';
end;

function TKDT512DI16.InternalBuildKdTree(const KDSourceBufferPtr: PKDT512DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT512DI16_Node;
  function SortCompare(const p1, p2: PKDT512DI16_Source; const axis: NativeInt): ShortInt;
  begin
    if p1^.buff[axis] = p2^.buff[axis] then
      begin
        if p1^.Index = p2^.Index then
            Result := 0
        else if p1^.Index < p2^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.buff[axis] < p2^.buff[axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT512DI16_SourceBuffer; L, R: NativeInt; const axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT512DI16_Source;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer^[(L + R) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, axis) < 0 do
            Inc(i);
        while SortCompare(SortBuffer^[j], p, axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, axis);
      L := i;
    until i >= R;
  end;

var
  M: NativeInt;
  axis: NativeInt;
  kdBuffPtr: PKDT512DI16_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      new(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.Vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);
    end
  else
    begin
      axis := Depth mod KDT512DI16_Axis;
      M := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr^[0], 0, PlanCount - 1, axis);

      new(Result);
      Result^.Parent := nil;
      Result^.Vec := kdBuffPtr^[M];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], M, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[M + 1], PlanCount - (M + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT512DI16.GetData(const Index: NativeInt): PKDT512DI16_Source;
begin
  Result := @KDStoreBuff[Index];
end;

constructor TKDT512DI16.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT512DI16.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT512DI16.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT512DI16_Node(KDNodes[i]));
      Inc(i);
    end;

  for i := 0 to length(KDStoreBuff) - 1 do
      KDStoreBuff[i].Token := '';

  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT512DI16.StoreBuffPtr: PKDT512DI16_DyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT512DI16.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT512DI16_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT512DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT512DI16.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT512DI16_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT512DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT512DI16.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT512DI16_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT512DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{ k-means++ clusterization }
procedure TKDT512DI16.BuildKDTreeWithCluster(const inBuff: TKDT512DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  SetLength(Source, length(inBuff), KDT512DI16_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT512DI16_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT512DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT512DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT512DI16.BuildKDTreeWithCluster(const inBuff: TKDT512DI16_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TKMIntegerArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT512DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT512DI16_BuildCall);
var
  TempStoreBuff: TKDT512DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT512DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT512DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT512DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT512DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT512DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT512DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT512DI16_BuildMethod);
var
  TempStoreBuff: TKDT512DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT512DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT512DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT512DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT512DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT512DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT512DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT512DI16_BuildProc);
var
  TempStoreBuff: TKDT512DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT512DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT512DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT512DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT512DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT512DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

function TKDT512DI16.Search(const buff: TKDT512DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT512DI16_Node;

var
  NearestNeighbour: PKDT512DI16_Node;

  function FindParentNode(const buffPtr: PKDT512DI16_Vec; NodePtr: PKDT512DI16_Node): PKDT512DI16_Node;
  var
    Next: PKDT512DI16_Node;
    Depth, axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        axis := Depth mod KDT512DI16_Axis;
        if buffPtr^[axis] > Next^.Vec^.buff[axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT512DI16_Node; const buffPtr: PKDT512DI16_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    Inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := Distance(buffPtr^, NodePtr^.Vec^.buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.Vec^.Index < NearestNeighbour^.Vec^.Index) then
        NearestNeighbour := NodePtr;

    axis := Depth mod KDT512DI16_Axis;
    Dist := NodePtr^.Vec^.buff[axis] - buffPtr^[axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.Vec^.buff[axis] > buffPtr^[axis] then
            ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const buffPtr: PKDT512DI16_Vec; const p1, p2: PKDT512DI16_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := Distance(buffPtr^, p1^.Vec^.buff);
    d2 := Distance(buffPtr^, p2^.Vec^.buff);
    if d1 = d2 then
      begin
        if p1^.Vec^.Index = p2^.Vec^.Index then
            Result := 0
        else if p1^.Vec^.Index < p2^.Vec^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; L, R: NativeInt; const buffPtr: PKDT512DI16_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT512DI16_Node;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer[(L + R) shr 1];
      repeat
        while SortCompare(buffPtr, SortBuffer[i], p) < 0 do
            Inc(i);
        while SortCompare(buffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, buffPtr);
      L := i;
    until i >= R;
  end;

var
  Parent: PKDT512DI16_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := Distance(buff, Parent^.Vec^.buff);

  ScanSubtree(RootNode, @buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT512DI16_Node(NearestNodes[0]);
    end;
end;

function TKDT512DI16.Search(const buff: TKDT512DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT512DI16_Node;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT512DI16.Search(const buff: TKDT512DI16_Vec; var SearchedDistanceMin: Double): PKDT512DI16_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT512DI16.Search(const buff: TKDT512DI16_Vec): PKDT512DI16_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT512DI16.SearchToken(const buff: TKDT512DI16_Vec): TPascalString;
var
  p: PKDT512DI16_Node;
begin
  p := Search(buff);
  if p <> nil then
      Result := p^.Vec^.Token
  else
      Result := '';
end;

procedure TKDT512DI16.Search(const inBuff: TKDT512DI16_DynamicVecBuffer; var OutBuff: TKDT512DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT512DI16_DynamicVecBuffer;
  outBuffPtr: PKDT512DI16_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT512DI16_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outBuffPtr^[pass] := p^.Vec^.buff;
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT512DI16_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outBuffPtr^[pass] := p^.Vec^.buff;
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT512DI16_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.Vec^.buff;
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT512DI16.Search(const inBuff: TKDT512DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT512DI16_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT512DI16_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT512DI16_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT512DI16_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT512DI16.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  ID := KDT512DI16_Axis;

  stream.write(st, 4);
  stream.write(ID, 4);

  stream.write(cnt, 8);

  i := 0;
  while i < cnt do
    begin
      stream.write(KDStoreBuff[i].buff[0], SizeOf(TKDT512DI16_Vec));
      stream.write(KDStoreBuff[i].Index, 8);
      token_B := KDStoreBuff[i].Token.Bytes;
      token_L := length(token_B);
      stream.write(token_L, 4);
      if token_L > 0 then
        begin
          stream.write(token_B[0], token_L);
          SetLength(token_B, 0);
        end;
      Inc(i);
    end;
end;

procedure TKDT512DI16.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  Clear;

  stream.read(st, 4);
  stream.read(ID, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if ID <> KDT512DI16_Axis then
      RaiseInfo('kdtree axis error!');

  stream.read(cnt, 8);

  SetLength(KDStoreBuff, cnt);

  i := 0;
  try
    while i < cnt do
      begin
        if stream.read(KDStoreBuff[i].buff[0], SizeOf(TKDT512DI16_Vec)) <> SizeOf(TKDT512DI16_Vec) then
          begin
            Clear;
            Exit;
          end;
        if stream.read(KDStoreBuff[i].Index, 8) <> 8 then
          begin
            Clear;
            Exit;
          end;
        if stream.read(token_L, 4) <> 4 then
          begin
            Clear;
            Exit;
          end;
        if token_L > 0 then
          begin
            SetLength(token_B, token_L);
            if stream.read(token_B[0], token_L) <> token_L then
              begin
                Clear;
                Exit;
              end;
            KDStoreBuff[i].Token.Bytes := token_B;
            SetLength(token_B, 0);
          end
        else
            KDStoreBuff[i].Token := '';
        Inc(i);
      end;
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      Inc(i);
    end;

  if cnt > 0 then
      RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT512DI16.SaveToFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(FileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT512DI16.LoadFromFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT512DI16.PrintNodeTree(const NodePtr: PKDT512DI16_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT512DI16_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.Vec^.Index, Vec(p^.Vec^.buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT512DI16.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d - %d : %s ', [i, KDStoreBuff[i].Index, Vec(KDStoreBuff[i].buff)]);
end;

class function TKDT512DI16.Vec(const s: SystemString): TKDT512DI16_Vec;
var
  t: TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j: NativeInt;
begin
  for i := 0 to KDT512DI16_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            Inc(j);
            if j >= KDT512DI16_Axis then
                Break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT512DI16.Vec(const v: TKDT512DI16_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT512DI16_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT512DI16.Distance(const v1, v2: TKDT512DI16_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT512DI16_Axis - 1 do
      Result := Result + (v2[i] - v1[i]) * (v2[i] - v1[i]);
end;

procedure TKDT512DI16.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT512DI16_Source; const Data: Pointer);
begin
  Source.buff := TestBuff[IndexFor];
  Source.Token := umlIntToStr(IndexFor);
end;

class procedure TKDT512DI16.Test;
var
  TKDT512DI16_Test: TKDT512DI16;
  t: TTimeTick;
  i, j: NativeInt;
  TestResultBuff: TKDT512DI16_DynamicVecBuffer;
  TestResultIndex: TKMIntegerArray;
  KMeanOutIndex: TKMIntegerArray;
  errored: Boolean;
  m64: TMemoryStream64;
  p: PKDT512DI16_Node;
  n: TPascalString;
begin
  errored := False;
  n := PFormat('test %s...', [ClassName]);
  t := GetTimeTick;

  n.Append('...build');
  TKDT512DI16_Test := TKDT512DI16.Create;

  n.Append('...');
  SetLength(TKDT512DI16_Test.TestBuff, 1000);
  for i := 0 to length(TKDT512DI16_Test.TestBuff) - 1 do
    for j := 0 to KDT512DI16_Axis - 1 do
        TKDT512DI16_Test.TestBuff[i][j] := i * KDT512DI16_Axis + j;

{$IFDEF FPC}
  TKDT512DI16_Test.BuildKDTreeM(length(TKDT512DI16_Test.TestBuff), nil, @TKDT512DI16_Test.Test_BuildM);
{$ELSE FPC}
  TKDT512DI16_Test.BuildKDTreeM(length(TKDT512DI16_Test.TestBuff), nil, TKDT512DI16_Test.Test_BuildM);
{$ENDIF FPC}
  { save/load test }
  n.Append('...save/load');
  m64 := TMemoryStream64.CustomCreate(1024 * 1024);
  TKDT512DI16_Test.SaveToStream(m64);
  m64.Position := 0;
  TKDT512DI16_Test.LoadFromStream(m64);
  for i := 0 to length(TKDT512DI16_Test.TestBuff) - 1 do
    begin
      p := TKDT512DI16_Test.Search(TKDT512DI16_Test.TestBuff[i]);
      if p^.Vec^.Index <> i then
          errored := True;
      if not p^.Vec^.Token.Same(umlIntToStr(i)) then
          errored := True;
      if errored then
          Break;
    end;
  DisposeObject(m64);

  if not errored then
    begin
      { parallel search test }
      n.Append('...parallel');
      SetLength(TestResultBuff, length(TKDT512DI16_Test.TestBuff));
      SetLength(TestResultIndex, length(TKDT512DI16_Test.TestBuff));
      TKDT512DI16_Test.Search(TKDT512DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if Distance(TKDT512DI16_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
            errored := True;
    end;

  if not errored then
    begin
      n.Append('...kMean');
      TKDT512DI16_Test.Clear;
      { kMean test }
      TKDT512DI16_Test.BuildKDTreeWithCluster(TKDT512DI16_Test.TestBuff, 10, 1, KMeanOutIndex);
      { parallel search test }
      TKDT512DI16_Test.Search(TKDT512DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if TestResultIndex[i] <> KMeanOutIndex[i] then
            errored := True;
    end;

  SetLength(TKDT512DI16_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT512DI16_Test.Clear;

  n.Append('...');
  if errored then
      n.Append('error!')
  else
      n.Append('passed ok %dms', [GetTimeTick - t]);
  DisposeObject(TKDT512DI16_Test);
  DoStatus(n);
  n := '';
end;

function TKDT800DI16.InternalBuildKdTree(const KDSourceBufferPtr: PKDT800DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT800DI16_Node;
  function SortCompare(const p1, p2: PKDT800DI16_Source; const axis: NativeInt): ShortInt;
  begin
    if p1^.buff[axis] = p2^.buff[axis] then
      begin
        if p1^.Index = p2^.Index then
            Result := 0
        else if p1^.Index < p2^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.buff[axis] < p2^.buff[axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT800DI16_SourceBuffer; L, R: NativeInt; const axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT800DI16_Source;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer^[(L + R) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, axis) < 0 do
            Inc(i);
        while SortCompare(SortBuffer^[j], p, axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, axis);
      L := i;
    until i >= R;
  end;

var
  M: NativeInt;
  axis: NativeInt;
  kdBuffPtr: PKDT800DI16_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      new(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.Vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);
    end
  else
    begin
      axis := Depth mod KDT800DI16_Axis;
      M := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr^[0], 0, PlanCount - 1, axis);

      new(Result);
      Result^.Parent := nil;
      Result^.Vec := kdBuffPtr^[M];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], M, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[M + 1], PlanCount - (M + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT800DI16.GetData(const Index: NativeInt): PKDT800DI16_Source;
begin
  Result := @KDStoreBuff[Index];
end;

constructor TKDT800DI16.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT800DI16.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT800DI16.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT800DI16_Node(KDNodes[i]));
      Inc(i);
    end;

  for i := 0 to length(KDStoreBuff) - 1 do
      KDStoreBuff[i].Token := '';

  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT800DI16.StoreBuffPtr: PKDT800DI16_DyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT800DI16.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT800DI16_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT800DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT800DI16.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT800DI16_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT800DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT800DI16.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT800DI16_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT800DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{ k-means++ clusterization }
procedure TKDT800DI16.BuildKDTreeWithCluster(const inBuff: TKDT800DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  SetLength(Source, length(inBuff), KDT800DI16_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT800DI16_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT800DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT800DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT800DI16.BuildKDTreeWithCluster(const inBuff: TKDT800DI16_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TKMIntegerArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT800DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT800DI16_BuildCall);
var
  TempStoreBuff: TKDT800DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT800DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT800DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT800DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT800DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT800DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT800DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT800DI16_BuildMethod);
var
  TempStoreBuff: TKDT800DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT800DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT800DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT800DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT800DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT800DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT800DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT800DI16_BuildProc);
var
  TempStoreBuff: TKDT800DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT800DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT800DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT800DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT800DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT800DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

function TKDT800DI16.Search(const buff: TKDT800DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT800DI16_Node;

var
  NearestNeighbour: PKDT800DI16_Node;

  function FindParentNode(const buffPtr: PKDT800DI16_Vec; NodePtr: PKDT800DI16_Node): PKDT800DI16_Node;
  var
    Next: PKDT800DI16_Node;
    Depth, axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        axis := Depth mod KDT800DI16_Axis;
        if buffPtr^[axis] > Next^.Vec^.buff[axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT800DI16_Node; const buffPtr: PKDT800DI16_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    Inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := Distance(buffPtr^, NodePtr^.Vec^.buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.Vec^.Index < NearestNeighbour^.Vec^.Index) then
        NearestNeighbour := NodePtr;

    axis := Depth mod KDT800DI16_Axis;
    Dist := NodePtr^.Vec^.buff[axis] - buffPtr^[axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.Vec^.buff[axis] > buffPtr^[axis] then
            ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const buffPtr: PKDT800DI16_Vec; const p1, p2: PKDT800DI16_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := Distance(buffPtr^, p1^.Vec^.buff);
    d2 := Distance(buffPtr^, p2^.Vec^.buff);
    if d1 = d2 then
      begin
        if p1^.Vec^.Index = p2^.Vec^.Index then
            Result := 0
        else if p1^.Vec^.Index < p2^.Vec^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; L, R: NativeInt; const buffPtr: PKDT800DI16_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT800DI16_Node;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer[(L + R) shr 1];
      repeat
        while SortCompare(buffPtr, SortBuffer[i], p) < 0 do
            Inc(i);
        while SortCompare(buffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, buffPtr);
      L := i;
    until i >= R;
  end;

var
  Parent: PKDT800DI16_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := Distance(buff, Parent^.Vec^.buff);

  ScanSubtree(RootNode, @buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT800DI16_Node(NearestNodes[0]);
    end;
end;

function TKDT800DI16.Search(const buff: TKDT800DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT800DI16_Node;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT800DI16.Search(const buff: TKDT800DI16_Vec; var SearchedDistanceMin: Double): PKDT800DI16_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT800DI16.Search(const buff: TKDT800DI16_Vec): PKDT800DI16_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT800DI16.SearchToken(const buff: TKDT800DI16_Vec): TPascalString;
var
  p: PKDT800DI16_Node;
begin
  p := Search(buff);
  if p <> nil then
      Result := p^.Vec^.Token
  else
      Result := '';
end;

procedure TKDT800DI16.Search(const inBuff: TKDT800DI16_DynamicVecBuffer; var OutBuff: TKDT800DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT800DI16_DynamicVecBuffer;
  outBuffPtr: PKDT800DI16_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT800DI16_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outBuffPtr^[pass] := p^.Vec^.buff;
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT800DI16_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outBuffPtr^[pass] := p^.Vec^.buff;
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT800DI16_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.Vec^.buff;
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT800DI16.Search(const inBuff: TKDT800DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT800DI16_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT800DI16_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT800DI16_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT800DI16_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT800DI16.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  ID := KDT800DI16_Axis;

  stream.write(st, 4);
  stream.write(ID, 4);

  stream.write(cnt, 8);

  i := 0;
  while i < cnt do
    begin
      stream.write(KDStoreBuff[i].buff[0], SizeOf(TKDT800DI16_Vec));
      stream.write(KDStoreBuff[i].Index, 8);
      token_B := KDStoreBuff[i].Token.Bytes;
      token_L := length(token_B);
      stream.write(token_L, 4);
      if token_L > 0 then
        begin
          stream.write(token_B[0], token_L);
          SetLength(token_B, 0);
        end;
      Inc(i);
    end;
end;

procedure TKDT800DI16.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  Clear;

  stream.read(st, 4);
  stream.read(ID, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if ID <> KDT800DI16_Axis then
      RaiseInfo('kdtree axis error!');

  stream.read(cnt, 8);

  SetLength(KDStoreBuff, cnt);

  i := 0;
  try
    while i < cnt do
      begin
        if stream.read(KDStoreBuff[i].buff[0], SizeOf(TKDT800DI16_Vec)) <> SizeOf(TKDT800DI16_Vec) then
          begin
            Clear;
            Exit;
          end;
        if stream.read(KDStoreBuff[i].Index, 8) <> 8 then
          begin
            Clear;
            Exit;
          end;
        if stream.read(token_L, 4) <> 4 then
          begin
            Clear;
            Exit;
          end;
        if token_L > 0 then
          begin
            SetLength(token_B, token_L);
            if stream.read(token_B[0], token_L) <> token_L then
              begin
                Clear;
                Exit;
              end;
            KDStoreBuff[i].Token.Bytes := token_B;
            SetLength(token_B, 0);
          end
        else
            KDStoreBuff[i].Token := '';
        Inc(i);
      end;
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      Inc(i);
    end;

  if cnt > 0 then
      RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT800DI16.SaveToFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(FileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT800DI16.LoadFromFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT800DI16.PrintNodeTree(const NodePtr: PKDT800DI16_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT800DI16_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.Vec^.Index, Vec(p^.Vec^.buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT800DI16.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d - %d : %s ', [i, KDStoreBuff[i].Index, Vec(KDStoreBuff[i].buff)]);
end;

class function TKDT800DI16.Vec(const s: SystemString): TKDT800DI16_Vec;
var
  t: TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j: NativeInt;
begin
  for i := 0 to KDT800DI16_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            Inc(j);
            if j >= KDT800DI16_Axis then
                Break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT800DI16.Vec(const v: TKDT800DI16_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT800DI16_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT800DI16.Distance(const v1, v2: TKDT800DI16_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT800DI16_Axis - 1 do
      Result := Result + (v2[i] - v1[i]) * (v2[i] - v1[i]);
end;

procedure TKDT800DI16.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT800DI16_Source; const Data: Pointer);
begin
  Source.buff := TestBuff[IndexFor];
  Source.Token := umlIntToStr(IndexFor);
end;

class procedure TKDT800DI16.Test;
var
  TKDT800DI16_Test: TKDT800DI16;
  t: TTimeTick;
  i, j: NativeInt;
  TestResultBuff: TKDT800DI16_DynamicVecBuffer;
  TestResultIndex: TKMIntegerArray;
  KMeanOutIndex: TKMIntegerArray;
  errored: Boolean;
  m64: TMemoryStream64;
  p: PKDT800DI16_Node;
  n: TPascalString;
begin
  errored := False;
  n := PFormat('test %s...', [ClassName]);
  t := GetTimeTick;

  n.Append('...build');
  TKDT800DI16_Test := TKDT800DI16.Create;

  n.Append('...');
  SetLength(TKDT800DI16_Test.TestBuff, 1000);
  for i := 0 to length(TKDT800DI16_Test.TestBuff) - 1 do
    for j := 0 to KDT800DI16_Axis - 1 do
        TKDT800DI16_Test.TestBuff[i][j] := i * KDT800DI16_Axis + j;

{$IFDEF FPC}
  TKDT800DI16_Test.BuildKDTreeM(length(TKDT800DI16_Test.TestBuff), nil, @TKDT800DI16_Test.Test_BuildM);
{$ELSE FPC}
  TKDT800DI16_Test.BuildKDTreeM(length(TKDT800DI16_Test.TestBuff), nil, TKDT800DI16_Test.Test_BuildM);
{$ENDIF FPC}
  { save/load test }
  n.Append('...save/load');
  m64 := TMemoryStream64.CustomCreate(1024 * 1024);
  TKDT800DI16_Test.SaveToStream(m64);
  m64.Position := 0;
  TKDT800DI16_Test.LoadFromStream(m64);
  for i := 0 to length(TKDT800DI16_Test.TestBuff) - 1 do
    begin
      p := TKDT800DI16_Test.Search(TKDT800DI16_Test.TestBuff[i]);
      if p^.Vec^.Index <> i then
          errored := True;
      if not p^.Vec^.Token.Same(umlIntToStr(i)) then
          errored := True;
      if errored then
          Break;
    end;
  DisposeObject(m64);

  if not errored then
    begin
      { parallel search test }
      n.Append('...parallel');
      SetLength(TestResultBuff, length(TKDT800DI16_Test.TestBuff));
      SetLength(TestResultIndex, length(TKDT800DI16_Test.TestBuff));
      TKDT800DI16_Test.Search(TKDT800DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if Distance(TKDT800DI16_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
            errored := True;
    end;

  if not errored then
    begin
      n.Append('...kMean');
      TKDT800DI16_Test.Clear;
      { kMean test }
      TKDT800DI16_Test.BuildKDTreeWithCluster(TKDT800DI16_Test.TestBuff, 10, 1, KMeanOutIndex);
      { parallel search test }
      TKDT800DI16_Test.Search(TKDT800DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if TestResultIndex[i] <> KMeanOutIndex[i] then
            errored := True;
    end;

  SetLength(TKDT800DI16_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT800DI16_Test.Clear;

  n.Append('...');
  if errored then
      n.Append('error!')
  else
      n.Append('passed ok %dms', [GetTimeTick - t]);
  DisposeObject(TKDT800DI16_Test);
  DoStatus(n);
  n := '';
end;

function TKDT1024DI16.InternalBuildKdTree(const KDSourceBufferPtr: PKDT1024DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1024DI16_Node;
  function SortCompare(const p1, p2: PKDT1024DI16_Source; const axis: NativeInt): ShortInt;
  begin
    if p1^.buff[axis] = p2^.buff[axis] then
      begin
        if p1^.Index = p2^.Index then
            Result := 0
        else if p1^.Index < p2^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.buff[axis] < p2^.buff[axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT1024DI16_SourceBuffer; L, R: NativeInt; const axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT1024DI16_Source;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer^[(L + R) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, axis) < 0 do
            Inc(i);
        while SortCompare(SortBuffer^[j], p, axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, axis);
      L := i;
    until i >= R;
  end;

var
  M: NativeInt;
  axis: NativeInt;
  kdBuffPtr: PKDT1024DI16_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      new(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.Vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);
    end
  else
    begin
      axis := Depth mod KDT1024DI16_Axis;
      M := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr^[0], 0, PlanCount - 1, axis);

      new(Result);
      Result^.Parent := nil;
      Result^.Vec := kdBuffPtr^[M];

      KDNodes[NodeCounter] := Result;
      Inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], M, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[M + 1], PlanCount - (M + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT1024DI16.GetData(const Index: NativeInt): PKDT1024DI16_Source;
begin
  Result := @KDStoreBuff[Index];
end;

constructor TKDT1024DI16.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT1024DI16.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT1024DI16.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT1024DI16_Node(KDNodes[i]));
      Inc(i);
    end;

  for i := 0 to length(KDStoreBuff) - 1 do
      KDStoreBuff[i].Token := '';

  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT1024DI16.StoreBuffPtr: PKDT1024DI16_DyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT1024DI16.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1024DI16_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT1024DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT1024DI16.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1024DI16_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT1024DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT1024DI16.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1024DI16_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].Index := i;
      KDStoreBuff[i].Token := '';
      FillPtrByte(@KDStoreBuff[i].buff[0], SizeOf(TKDT1024DI16_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      Inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{ k-means++ clusterization }
procedure TKDT1024DI16.BuildKDTreeWithCluster(const inBuff: TKDT1024DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TKMIntegerArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  SetLength(Source, length(inBuff), KDT1024DI16_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT1024DI16_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT1024DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT1024DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT1024DI16.BuildKDTreeWithCluster(const inBuff: TKDT1024DI16_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TKMIntegerArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT1024DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT1024DI16_BuildCall);
var
  TempStoreBuff: TKDT1024DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT1024DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1024DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1024DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT1024DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT1024DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1024DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT1024DI16_BuildMethod);
var
  TempStoreBuff: TKDT1024DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT1024DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1024DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1024DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT1024DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT1024DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1024DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TKMIntegerArray; const Data: Pointer; const OnTrigger: TKDT1024DI16_BuildProc);
var
  TempStoreBuff: TKDT1024DI16_DyanmicStoreBuffer;
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j: NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].Index := i;
      TempStoreBuff[i].Token := '';
      FillPtrByte(@TempStoreBuff[i].buff[0], SizeOf(TKDT1024DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      Inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1024DI16_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1024DI16_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].buff[j];

  if KMeansCluster(Source, KDT1024DI16_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].Index := i;
          KDStoreBuff[i].Token := '';
          for j := 0 to KDT1024DI16_Axis - 1 do
              KDStoreBuff[i].buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].Index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

function TKDT1024DI16.Search(const buff: TKDT1024DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1024DI16_Node;

var
  NearestNeighbour: PKDT1024DI16_Node;

  function FindParentNode(const buffPtr: PKDT1024DI16_Vec; NodePtr: PKDT1024DI16_Node): PKDT1024DI16_Node;
  var
    Next: PKDT1024DI16_Node;
    Depth, axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        axis := Depth mod KDT1024DI16_Axis;
        if buffPtr^[axis] > Next^.Vec^.buff[axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT1024DI16_Node; const buffPtr: PKDT1024DI16_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    Inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := Distance(buffPtr^, NodePtr^.Vec^.buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.Vec^.Index < NearestNeighbour^.Vec^.Index) then
        NearestNeighbour := NodePtr;

    axis := Depth mod KDT1024DI16_Axis;
    Dist := NodePtr^.Vec^.buff[axis] - buffPtr^[axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.Vec^.buff[axis] > buffPtr^[axis] then
            ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, buffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, buffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const buffPtr: PKDT1024DI16_Vec; const p1, p2: PKDT1024DI16_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := Distance(buffPtr^, p1^.Vec^.buff);
    d2 := Distance(buffPtr^, p2^.Vec^.buff);
    if d1 = d2 then
      begin
        if p1^.Vec^.Index = p2^.Vec^.Index then
            Result := 0
        else if p1^.Vec^.Index < p2^.Vec^.Index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; L, R: NativeInt; const buffPtr: PKDT1024DI16_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT1024DI16_Node;
  begin
    repeat
      i := L;
      j := R;
      p := SortBuffer[(L + R) shr 1];
      repeat
        while SortCompare(buffPtr, SortBuffer[i], p) < 0 do
            Inc(i);
        while SortCompare(buffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            Inc(i);
            Dec(j);
          end;
      until i > j;
      if L < j then
          InternalSort(SortBuffer, L, j, buffPtr);
      L := i;
    until i >= R;
  end;

var
  Parent: PKDT1024DI16_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := Distance(buff, Parent^.Vec^.buff);

  ScanSubtree(RootNode, @buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT1024DI16_Node(NearestNodes[0]);
    end;
end;

function TKDT1024DI16.Search(const buff: TKDT1024DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1024DI16_Node;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT1024DI16.Search(const buff: TKDT1024DI16_Vec; var SearchedDistanceMin: Double): PKDT1024DI16_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT1024DI16.Search(const buff: TKDT1024DI16_Vec): PKDT1024DI16_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter: NativeInt;
begin
  Result := Search(buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT1024DI16.SearchToken(const buff: TKDT1024DI16_Vec): TPascalString;
var
  p: PKDT1024DI16_Node;
begin
  p := Search(buff);
  if p <> nil then
      Result := p^.Vec^.Token
  else
      Result := '';
end;

procedure TKDT1024DI16.Search(const inBuff: TKDT1024DI16_DynamicVecBuffer; var OutBuff: TKDT1024DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT1024DI16_DynamicVecBuffer;
  outBuffPtr: PKDT1024DI16_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT1024DI16_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outBuffPtr^[pass] := p^.Vec^.buff;
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT1024DI16_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outBuffPtr^[pass] := p^.Vec^.buff;
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1024DI16_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.Vec^.buff;
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1024DI16.Search(const inBuff: TKDT1024DI16_DynamicVecBuffer; var OutIndex: TKMIntegerArray);

{$IFDEF parallel}
var
  inBuffPtr: PKDT1024DI16_DynamicVecBuffer;
  outIndexPtr: PKMIntegerArray;

{$IFDEF FPC}
  procedure FPC_ParallelFor(pass: Integer);
  var
    p: PKDT1024DI16_Node;
  begin
    p := Search(inBuffPtr^[pass]);
    outIndexPtr^[pass] := p^.Vec^.Index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  GlobalMemoryHook.V := False;
  try
{$IFDEF FPC}
    FPCParallelFor(@FPC_ParallelFor, 0, length(inBuff) - 1);
{$ELSE FPC}
    DelphiParallelFor(0, length(inBuff) - 1,
      procedure(pass: Int64)
      var
        p: PKDT1024DI16_Node;
      begin
        p := Search(inBuffPtr^[pass]);
        outIndexPtr^[pass] := p^.Vec^.Index;
      end);
{$ENDIF FPC}
  finally
      GlobalMemoryHook.V := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1024DI16_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.Vec^.Index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1024DI16.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  ID := KDT1024DI16_Axis;

  stream.write(st, 4);
  stream.write(ID, 4);

  stream.write(cnt, 8);

  i := 0;
  while i < cnt do
    begin
      stream.write(KDStoreBuff[i].buff[0], SizeOf(TKDT1024DI16_Vec));
      stream.write(KDStoreBuff[i].Index, 8);
      token_B := KDStoreBuff[i].Token.Bytes;
      token_L := length(token_B);
      stream.write(token_L, 4);
      if token_L > 0 then
        begin
          stream.write(token_B[0], token_L);
          SetLength(token_B, 0);
        end;
      Inc(i);
    end;
end;

procedure TKDT1024DI16.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  st, ID: Integer;
  i: NativeInt;
  token_B: TBytes;
  token_L: Integer;
begin
  Clear;

  stream.read(st, 4);
  stream.read(ID, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if ID <> KDT1024DI16_Axis then
      RaiseInfo('kdtree axis error!');

  stream.read(cnt, 8);

  SetLength(KDStoreBuff, cnt);

  i := 0;
  try
    while i < cnt do
      begin
        if stream.read(KDStoreBuff[i].buff[0], SizeOf(TKDT1024DI16_Vec)) <> SizeOf(TKDT1024DI16_Vec) then
          begin
            Clear;
            Exit;
          end;
        if stream.read(KDStoreBuff[i].Index, 8) <> 8 then
          begin
            Clear;
            Exit;
          end;
        if stream.read(token_L, 4) <> 4 then
          begin
            Clear;
            Exit;
          end;
        if token_L > 0 then
          begin
            SetLength(token_B, token_L);
            if stream.read(token_B[0], token_L) <> token_L then
              begin
                Clear;
                Exit;
              end;
            KDStoreBuff[i].Token.Bytes := token_B;
            SetLength(token_B, 0);
          end
        else
            KDStoreBuff[i].Token := '';
        Inc(i);
      end;
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      Inc(i);
    end;

  if cnt > 0 then
      RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT1024DI16.SaveToFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(FileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1024DI16.LoadFromFile(FileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1024DI16.PrintNodeTree(const NodePtr: PKDT1024DI16_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT1024DI16_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.Vec^.Index, Vec(p^.Vec^.buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT1024DI16.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d - %d : %s ', [i, KDStoreBuff[i].Index, Vec(KDStoreBuff[i].buff)]);
end;

class function TKDT1024DI16.Vec(const s: SystemString): TKDT1024DI16_Vec;
var
  t: TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j: NativeInt;
begin
  for i := 0 to KDT1024DI16_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            Inc(j);
            if j >= KDT1024DI16_Axis then
                Break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT1024DI16.Vec(const v: TKDT1024DI16_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT1024DI16_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT1024DI16.Distance(const v1, v2: TKDT1024DI16_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT1024DI16_Axis - 1 do
      Result := Result + (v2[i] - v1[i]) * (v2[i] - v1[i]);
end;

procedure TKDT1024DI16.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT1024DI16_Source; const Data: Pointer);
begin
  Source.buff := TestBuff[IndexFor];
  Source.Token := umlIntToStr(IndexFor);
end;

class procedure TKDT1024DI16.Test;
var
  TKDT1024DI16_Test: TKDT1024DI16;
  t: TTimeTick;
  i, j: NativeInt;
  TestResultBuff: TKDT1024DI16_DynamicVecBuffer;
  TestResultIndex: TKMIntegerArray;
  KMeanOutIndex: TKMIntegerArray;
  errored: Boolean;
  m64: TMemoryStream64;
  p: PKDT1024DI16_Node;
  n: TPascalString;
begin
  errored := False;
  n := PFormat('test %s...', [ClassName]);
  t := GetTimeTick;

  n.Append('...build');
  TKDT1024DI16_Test := TKDT1024DI16.Create;

  n.Append('...');
  SetLength(TKDT1024DI16_Test.TestBuff, 1000);
  for i := 0 to length(TKDT1024DI16_Test.TestBuff) - 1 do
    for j := 0 to KDT1024DI16_Axis - 1 do
        TKDT1024DI16_Test.TestBuff[i][j] := i * KDT1024DI16_Axis + j;

{$IFDEF FPC}
  TKDT1024DI16_Test.BuildKDTreeM(length(TKDT1024DI16_Test.TestBuff), nil, @TKDT1024DI16_Test.Test_BuildM);
{$ELSE FPC}
  TKDT1024DI16_Test.BuildKDTreeM(length(TKDT1024DI16_Test.TestBuff), nil, TKDT1024DI16_Test.Test_BuildM);
{$ENDIF FPC}
  { save/load test }
  n.Append('...save/load');
  m64 := TMemoryStream64.CustomCreate(1024 * 1024);
  TKDT1024DI16_Test.SaveToStream(m64);
  m64.Position := 0;
  TKDT1024DI16_Test.LoadFromStream(m64);
  for i := 0 to length(TKDT1024DI16_Test.TestBuff) - 1 do
    begin
      p := TKDT1024DI16_Test.Search(TKDT1024DI16_Test.TestBuff[i]);
      if p^.Vec^.Index <> i then
          errored := True;
      if not p^.Vec^.Token.Same(umlIntToStr(i)) then
          errored := True;
      if errored then
          Break;
    end;
  DisposeObject(m64);

  if not errored then
    begin
      { parallel search test }
      n.Append('...parallel');
      SetLength(TestResultBuff, length(TKDT1024DI16_Test.TestBuff));
      SetLength(TestResultIndex, length(TKDT1024DI16_Test.TestBuff));
      TKDT1024DI16_Test.Search(TKDT1024DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if Distance(TKDT1024DI16_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
            errored := True;
    end;

  if not errored then
    begin
      n.Append('...kMean');
      TKDT1024DI16_Test.Clear;
      { kMean test }
      TKDT1024DI16_Test.BuildKDTreeWithCluster(TKDT1024DI16_Test.TestBuff, 10, 1, KMeanOutIndex);
      { parallel search test }
      TKDT1024DI16_Test.Search(TKDT1024DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

      for i := 0 to length(TestResultIndex) - 1 do
        if TestResultIndex[i] <> KMeanOutIndex[i] then
            errored := True;
    end;

  SetLength(TKDT1024DI16_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT1024DI16_Test.Clear;

  n.Append('...');
  if errored then
      n.Append('error!')
  else
      n.Append('passed ok %dms', [GetTimeTick - t]);
  DisposeObject(TKDT1024DI16_Test);
  DoStatus(n);
  n := '';
end;


procedure Test_All;
begin
  TKDT1DI16.Test();
  TKDT2DI16.Test();
  TKDT3DI16.Test();
  TKDT4DI16.Test();
  TKDT5DI16.Test();
  TKDT6DI16.Test();
  TKDT7DI16.Test();
  TKDT8DI16.Test();
  TKDT9DI16.Test();
  TKDT10DI16.Test();
  TKDT11DI16.Test();
  TKDT12DI16.Test();
  TKDT13DI16.Test();
  TKDT14DI16.Test();
  TKDT15DI16.Test();
  TKDT16DI16.Test();
  TKDT17DI16.Test();
  TKDT18DI16.Test();
  TKDT19DI16.Test();
  TKDT20DI16.Test();
  TKDT21DI16.Test();
  TKDT22DI16.Test();
  TKDT23DI16.Test();
  TKDT24DI16.Test();
  TKDT48DI16.Test();
  TKDT52DI16.Test();
  TKDT64DI16.Test();
  TKDT96DI16.Test();
  TKDT128DI16.Test();
  TKDT156DI16.Test();
  TKDT192DI16.Test();
  TKDT256DI16.Test();
  TKDT384DI16.Test();
  TKDT512DI16.Test();
  TKDT800DI16.Test();
  TKDT1024DI16.Test();
end;





initialization

finalization

end.

